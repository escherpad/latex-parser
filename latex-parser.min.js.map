{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///latex-parser.min.js","webpack:///webpack/bootstrap d0873b549b14dc732a68","webpack:///./sources/lib/Utils.ts","webpack:///./sources/lib/Latex.ts","webpack:///./sources/lib/LatexStyle.ts","webpack:///./sources/lib/LatexTree.ts","webpack:///./sources/lib/SyntaxTree.ts","webpack:///./sources/lib/LatexParser.ts","webpack:///./sources/main.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","updateProperties","target","values","opt_keys","opt_attributes","arguments","length","undefined","writable","TypeError","key","create","Array","forEach","targetKey","_key","testProperties","opt_skipUndefined","every","_key2","isNumber","x","isString","mustNotBeUndefined","Error","_classCallCheck","instance","Constructor","isMode","modes","mustBeMode","isOperationProperties","mustBeOperationProperties","_createClass","defineProperties","props","descriptor","protoProps","staticProps","Lexeme","CELL_SEPARATOR","BRACKETS","BINARY_OPERATOR","CHAR","DIGIT","DIRECTIVE","DISPLAY_EQUATION","FILE_PATH","FLOATING_BOX","HORIZONTAL_SKIP","INLINE_EQUATION","LABEL","LENGTH","LETTER","LINE_BREAK","NUMBER","LIST","LIST_ITEM","PARAGRAPH_SEPARATOR","PICTURE","POST_OPERATOR","PRE_OPERATOR","RAW","SPACE","SUBSCRIPT","SUPERSCRIPT","TABLE","TABULAR_PARAMETERS","TAG","UNKNOWN","VERTICAL_SKIP","WORD","WRAPPER","MATH","TEXT","VERTICAL","Directive","State","opt_initialModeStates","modeStates_","update","modeStates","modeKey","mode","BEGIN","END","GROUP","Operation","opt_initialProperties","directive","operand","other","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","setPrototypeOf","__proto__","isArray","mustBeArray","mustBePackageProperties","isPackageProperties","keys","some","k","isParameterProperties","ignored","mustBeParameterProperties","isCommand","Command","mustBeCommand","isEnvironment","Environment","Symbol","Parameter","Item","LatexStyle","_typeof","iterator","obj","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_Utils","_Latex","symbols_","commands_","environments_","packageName","stylePackage","symbols","iSymbol","symbol","_Symbol","pattern","symbolPatternFirstChar","push","commands","iCommand","command","environments","iEnvironment","environment","envName","storedEnv","filteredSymbols","filter","styleItem","commandName","filteredCommands","environmentName","filteredEnvironments","state","patternFirstChar","SyntaxError","test","env","lexeme","_Item","_this","operations","map","operation","operations_","iOperation","equals","slice","_Item2","_this2","parameters","parameters_","parameter","patternComponents","match","patternComponents_","patternPart","parameterIndex","Number","substring","html","iParameter","patternComponent","join","_Symbol2","_this3","_Item3","_this4","isCommandToken","CommandToken","mustBeEnvironmentToken","isEnvironmentToken","EnvironmentToken","getBeginCommandToken","beginCommandToken","getEndCommandToken","endCommandToken","getEnvironment","_LatexStyle","SourceToken","SpaceToken","EnvironmentBodyToken","ParameterToken","SymbolToken","Token","LatexTree","_SyntaxTree2","_SyntaxTree","rootToken","source","SyntaxTree","_Node","superInitialProperties","parentNode","parentToken","childNodes","childTokens","Node","parentNodeClass_","_Token","initialProperties","skipNodeClass","nPatternChars","iPatternChar","patternChar","parameterToken","childNode","toString","_Token2","hasBrackets","hasSpacePrefix","symbolToken","childIndex","_SymbolToken","_this5","_Token3","_this6","bodyToken","beginToken","endToken","_Token4","apply","_Token5","_this8","lineBreakCount","isFinite","_Token6","_this9","default","_toConsumableArray","arr","arr2","from","rootNode","tree","insertChildSubtree","optParentNode","node","childNodes_","indexOf","childNodesToCover","nodeChildNodes","splice","subtreeSize","nodeChildNode","nodeSubtreeSize","nodeOrNodeIndex","_childNodes_","nodeChildIndex","concat","parseToken_","context","latexStyle","token","parseSpaceToken_","position","contextBackup","copy","parseEnvironmentToken_","parseCommandToken_","parseSymbolsToken_","processParsedToken_","parseParameterToken_","opt_endLabel","currentTokenBackup","currentToken","updateState","spacePrefixState","_LatexTree","charNumber","parseUntilLabel_","nameMatch","currentState","environmentToken","parsePatterns_","environmentBodyToken","endFound","cmdMatch","sourceCharacter","parsePattern_","nPatternComponents","iPatternComponent","parameterEndLabel","parseCommentLine_","parsedToken","endLabel","opt_lexeme","commentMatch","comments","lineNumber","isSpace","nLineBreaks","Context","LatexParser","opt_context","parsedTokens","opt_source","stateStack","opt_target","newModeStates","pop","_LatexParser"],"mappings":"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","file":"latex-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.updateProperties = updateProperties;\nexports.testProperties = testProperties;\nexports.isNumber = isNumber;\nexports.isString = isString;\nexports.mustNotBeUndefined = mustNotBeUndefined;\nfunction updateProperties(target, values, opt_keys) {\n    var opt_attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        writable: true,\n        enumerable: true,\n        configurable: true\n    };\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = { writable: true, enumerable: true, configurable: true };\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        }\n    } else if (opt_keys instanceof Array) {\n        opt_keys.forEach(function (key) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key = opt_keys[targetKey];\n            if (values[_key] !== undefined) Object.defineProperty(target, targetKey, Object.create(opt_attributes, { value: { value: values[_key] } }));\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\nfunction testProperties(target, values, opt_keys) {\n    var opt_skipUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true;\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined)) return false;\n        }\n    } else if (opt_keys instanceof Array) {\n        return opt_keys.every(function (key) {\n            return target[key] === values[key] || values[key] === undefined && opt_skipUndefined;\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key2 = opt_keys[targetKey];\n            if (target[targetKey] !== values[_key2] && !(values[_key2] === undefined && opt_skipUndefined)) return false;\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true;\n}\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction mustNotBeUndefined(x) {\n    if (!x) throw new Error();\n    return x;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isMode = isMode;\nexports.mustBeMode = mustBeMode;\nexports.isOperationProperties = isOperationProperties;\nexports.mustBeOperationProperties = mustBeOperationProperties;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Lexeme = exports.Lexeme = {\n    CELL_SEPARATOR: \"CELL_SEPARATOR\",\n    BRACKETS: \"BRACKETS\",\n    BINARY_OPERATOR: \"BINARY_OPERATOR\",\n    CHAR: \"CHAR\",\n    DIGIT: \"DIGIT\",\n    DIRECTIVE: \"DIRECTIVE\",\n    DISPLAY_EQUATION: \"DISPLAY_EQUATION\",\n    FILE_PATH: \"FILE_PATH\",\n    FLOATING_BOX: \"FLOATING_BOX\",\n    HORIZONTAL_SKIP: \"HORIZONTAL_SKIP\",\n    INLINE_EQUATION: \"INLINE_EQUATION\",\n    LABEL: \"LABEL\",\n    LENGTH: \"LENGTH\",\n    LETTER: \"LETTER\",\n    LINE_BREAK: \"LINE_BREAK\",\n    NUMBER: \"NUMBER\",\n    LIST: \"LIST\",\n    LIST_ITEM: \"LIST_ITEM\",\n    PARAGRAPH_SEPARATOR: \"PARAGRAPH_SEPARATOR\",\n    PICTURE: \"PICTURE\",\n    POST_OPERATOR: \"POST_OPERATOR\",\n    PRE_OPERATOR: \"PRE_OPERATOR\",\n    RAW: \"RAW\",\n    SPACE: \"SPACE\",\n    SUBSCRIPT: \"SUBSCRIPT\",\n    SUPERSCRIPT: \"SUPERSCRIPT\",\n    TABLE: \"TABLE\",\n    TABULAR_PARAMETERS: \"TABULAR_PARAMETERS\",\n    TAG: \"TAG\",\n    UNKNOWN: \"UNKNOWN\",\n    VERTICAL_SKIP: \"VERTICAL_SKIP\",\n    WORD: \"WORD\",\n    WRAPPER: \"WRAPPER\"\n};\nvar modes = exports.modes = {\n    LIST: \"LIST\",\n    MATH: \"MATH\",\n    PICTURE: \"PICTURE\",\n    TABLE: \"TABLE\",\n    TEXT: \"TEXT\",\n    VERTICAL: \"VERTICAL\"\n};\nfunction isMode(x) {\n    return modes.hasOwnProperty(x);\n}\nfunction mustBeMode(x) {\n    if (!isMode(x)) throw new Error();\n    return x;\n}\n\nvar State = exports.State = function () {\n    function State() {\n        var opt_initialModeStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, State);\n\n        Object.defineProperty(this, \"modeStates_\", { value: {}, enumerable: false });\n        this.modeStates_[modes.LIST] = false;\n        this.modeStates_[modes.MATH] = false;\n        this.modeStates_[modes.PICTURE] = false;\n        this.modeStates_[modes.TABLE] = false;\n        this.modeStates_[modes.TEXT] = true;\n        this.modeStates_[modes.VERTICAL] = false;\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n    _createClass(State, [{\n        key: \"copy\",\n        value: function copy() {\n            return new State(this.modeStates_);\n        }\n    }, {\n        key: \"update\",\n        value: function update(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                this.modeStates_[mode] = modeStates[modeKey];\n            }\n        }\n    }, {\n        key: \"test\",\n        value: function test(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n            }\n            return true;\n        }\n    }]);\n\n    return State;\n}();\n\nvar Directive = exports.Directive = {\n    BEGIN: \"BEGIN\",\n    END: \"END\"\n};\nvar GROUP = exports.GROUP = \"GROUP\";\nfunction isOperationProperties(x) {\n    return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\n}\nfunction mustBeOperationProperties(x) {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\n\nvar Operation = exports.Operation = function () {\n    function Operation(opt_initialProperties) {\n        _classCallCheck(this, Operation);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var directive = Directive[opt_initialProperties.directive];\n        if (!directive) throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, \"directive\", { value: directive, enumerable: true });\n        switch (opt_initialProperties.operand) {\n            case GROUP:\n                Object.defineProperty(this, \"operand\", { value: GROUP, enumerable: true });\n                break;\n            default:\n                var mode = modes[opt_initialProperties.operand];\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\n                Object.defineProperty(this, \"operand\", { value: mode, enumerable: true });\n        }\n    }\n\n    _createClass(Operation, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Operation)) return false;\n            return this.directive === other.directive && this.operand === other.operand;\n        }\n    }]);\n\n    return Operation;\n}();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Environment = exports.Command = exports.Symbol = exports.Parameter = exports.Item = exports.LatexStyle = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.mustBePackageProperties = mustBePackageProperties;\nexports.isPackageProperties = isPackageProperties;\nexports.isParameterProperties = isParameterProperties;\nexports.mustBeParameterProperties = mustBeParameterProperties;\nexports.isCommand = isCommand;\nexports.mustBeCommand = mustBeCommand;\nexports.isEnvironment = isEnvironment;\n\nvar _Utils = __webpack_require__(0);\n\nvar _Latex = __webpack_require__(1);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction isArray(x) {\n    return x.constructor === Array;\n}\nfunction mustBeArray(x) {\n    if (!isArray(x)) throw new Error();\n    return x;\n}\nfunction mustBePackageProperties(x) {\n    if (!isPackageProperties(x)) throw new Error(\"Invalid format for PackageProperties\");\n    return x;\n}\nfunction isPackageProperties(x) {\n    return !Object.keys(x).some(function (k) {\n        switch (k) {\n            case \"symbols\":\n            case \"commands\":\n            case \"environments\":\n                return false;\n            default:\n                return true;\n        }\n    });\n}\n\nvar LatexStyle = exports.LatexStyle = function () {\n    function LatexStyle() {\n        _classCallCheck(this, LatexStyle);\n\n        this.symbols_ = {};\n        this.commands_ = {};\n        this.environments_ = {};\n    }\n\n    _createClass(LatexStyle, [{\n        key: \"loadPackage\",\n        value: function loadPackage(packageName, stylePackage) {\n            if (stylePackage.symbols !== undefined) {\n                if (!(stylePackage.symbols instanceof Array)) throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n                for (var iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                    var symbol = new _Symbol(stylePackage.symbols[iSymbol]);\n                    if (symbol.pattern) {\n                        var symbolPatternFirstChar = symbol.pattern[0];\n                        if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar)) this.symbols_[symbolPatternFirstChar] = [];\n                        var symbols = this.symbols_[symbolPatternFirstChar];\n                        symbols.push({ symbol: symbol, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.commands !== undefined) {\n                if (!(stylePackage.commands instanceof Array)) throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n                for (var iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                    var command = new Command(stylePackage.commands[iCommand]);\n                    if (command.name) {\n                        (this.commands_[command.name] || (this.commands_[command.name] = [])).push({ command: command, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.environments !== undefined) {\n                if (!(stylePackage.environments instanceof Array)) throw new TypeError(\"\\\"stylePackage.environments\\\" isn't an Array\");\n                for (var iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0; --iEnvironment) {\n                    var environment = new Environment(stylePackage.environments[iEnvironment]);\n                    var envName = environment.name;\n                    if (envName) {\n                        var storedEnv = this.environments_[envName];\n                        if (storedEnv === undefined) {\n                            storedEnv = [];\n                            this.environments_[envName] = storedEnv;\n                        }\n                        storedEnv.push({ environment: environment, packageName: packageName });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"unloadPackage\",\n        value: function unloadPackage(packageName) {\n            for (var symbolPatternFirstChar in this.symbols_) {\n                if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                    var filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredSymbols.length) {\n                        this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                    } else {\n                        delete this.symbols_[symbolPatternFirstChar];\n                    }\n                }\n            }for (var commandName in this.commands_) {\n                if (this.commands_.hasOwnProperty(commandName)) {\n                    var filteredCommands = mustBeArray(this.commands_[commandName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredCommands.length) {\n                        this.commands_[commandName] = filteredCommands;\n                    } else {\n                        delete this.commands_[commandName];\n                    }\n                }\n            }for (var environmentName in this.environments_) {\n                if (this.environments_.hasOwnProperty(environmentName)) {\n                    var filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredEnvironments.length) {\n                        this.environments_[environmentName] = filteredEnvironments;\n                    } else {\n                        delete this.environments_[environmentName];\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"symbols\",\n        value: function symbols(state, patternFirstChar) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var symbols = this.symbols_[patternFirstChar];\n            if (symbols === undefined) return [];\n            var filteredSymbols = [];\n            for (var iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) {\n                var symbol = symbols[iSymbol].symbol;\n                if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n            }\n            return filteredSymbols;\n        }\n    }, {\n        key: \"commands\",\n        value: function commands(state, name) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var commands = this.commands_[name];\n            if (!commands) return [];\n            var filteredCommands = [];\n            for (var iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) {\n                var command = commands[iCommand].command;\n                if (state.test(command.modes)) filteredCommands.push(command);\n            }\n            return filteredCommands;\n        }\n    }, {\n        key: \"environments\",\n        value: function environments(state, name) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError(\"state isn't State instance\");\n            var environments = this.environments_[name];\n            if (!environments) return [];\n            return mustBeArray(environments).filter(function (env) {\n                return state.test(env.modes);\n            });\n        }\n    }]);\n\n    return LatexStyle;\n}();\n\nvar Item = exports.Item = function () {\n    function Item() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Item);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break;\n            default:\n                var lexeme = _Latex.Lexeme[opt_initialProperties.lexeme];\n                if (lexeme === undefined) throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, \"lexeme\", { value: lexeme });\n        }\n        if (opt_initialProperties.modes !== undefined) {\n            if (!(opt_initialProperties.modes instanceof Object)) throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, \"modes\", { value: {} });\n            for (var modeKey in opt_initialProperties.modes) {\n                var mode = (0, _Latex.mustBeMode)(modeKey);\n                if (mode === undefined) throw new TypeError(\"\\\"initialProperties.modes[\" + modeKey + \"]\\\" isn't a Mode option\");\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n    _createClass(Item, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Item)) return false;\n            return this.lexeme === other.lexeme && (0, _Utils.testProperties)(this.modes, other.modes, _Latex.modes, false);\n        }\n    }]);\n\n    return Item;\n}();\n\nObject.defineProperties(Item.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    modes: { value: {}, enumerable: true }\n});\nfunction isParameterProperties(ignored) {\n    return true;\n}\nfunction mustBeParameterProperties(x) {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\n\nvar Parameter = exports.Parameter = function (_Item) {\n    _inherits(Parameter, _Item);\n\n    function Parameter() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Parameter);\n\n        var _this = _possibleConstructorReturn(this, (Parameter.__proto__ || Object.getPrototypeOf(Parameter)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this, \"operations_\", {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Latex.Operation(operation);\n                })\n            });\n        }\n        return _this;\n    }\n\n    _createClass(Parameter, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Parameter)) return false;\n            if (!_get(Parameter.prototype.__proto__ || Object.getPrototypeOf(Parameter.prototype), \"equals\", this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            return this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            });\n        }\n    }, {\n        key: \"operations\",\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }]);\n\n    return Parameter;\n}(Item);\n\nObject.defineProperties(Parameter.prototype, {\n    operations: { enumerable: true }\n});\nObject.defineProperties(Parameter.prototype, {\n    operations_: { value: [], enumerable: false }\n});\n\nvar _Symbol = function (_Item2) {\n    _inherits(_Symbol, _Item2);\n\n    function _Symbol() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, _Symbol);\n\n        var _this2 = _possibleConstructorReturn(this, (_Symbol.__proto__ || Object.getPrototypeOf(_Symbol)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this2);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this2, \"operations_\", {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Latex.Operation((0, _Latex.mustBeOperationProperties)(operation));\n                })\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) {\n            if (!(opt_initialProperties.parameters instanceof Array)) throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            _this2.parameters_ = opt_initialProperties.parameters.map(function (parameter) {\n                return new Parameter(mustBeParameterProperties(parameter));\n            });\n        }\n        if (opt_initialProperties.pattern !== undefined) {\n            if (typeof opt_initialProperties.pattern !== \"string\") throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            var patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) {\n                _this2.patternComponents_ = patternComponents.map(function (patternPart) {\n                    switch (patternPart[0]) {\n                        case \" \":\n                        case \"\\t\":\n                            return undefined;\n                        case \"#\":\n                            var parameterIndex = Number(patternPart.substring(1)) - 1;\n                            if (!_this2.parameters_[parameterIndex]) throw new TypeError('\"initialProperties.pattern\" contains the incorrect parameter number ' + patternPart.substring(1));\n                            return parameterIndex;\n                        default:\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) {\n            if (typeof opt_initialProperties.html !== \"string\") throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            Object.defineProperty(_this2, \"html\", { value: opt_initialProperties.html, enumerable: true });\n        }\n        return _this2;\n    }\n\n    _createClass(_Symbol, [{\n        key: \"parameter\",\n        value: function parameter(parameterIndex) {\n            return this.parameters_[parameterIndex] || undefined;\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof _Symbol)) return false;\n            if (!_get(_Symbol.prototype.__proto__ || Object.getPrototypeOf(_Symbol.prototype), \"equals\", this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            if (!this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            })) return false;\n            if (this.parameters_.length !== other.parameters_.length) return false;\n            if (!this.parameters_.every(function (parameter, iParameter) {\n                return parameter.equals(other.parameters_[iParameter]);\n            })) return false;\n            return this.html === other.html;\n        }\n    }, {\n        key: \"operations\",\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }, {\n        key: \"parameters\",\n        get: function get() {\n            return this.parameters_.slice();\n        }\n    }, {\n        key: \"patternComponents\",\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.patternComponents_.slice());\n        }\n    }, {\n        key: \"pattern\",\n        get: function get() {\n            return this.patternComponents_.map(function (patternComponent) {\n                if ((0, _Utils.isNumber)(patternComponent)) {\n                    return \"#\" + (patternComponent + 1);\n                }\n                switch (typeof patternComponent === \"undefined\" ? \"undefined\" : _typeof(patternComponent)) {\n                    case \"string\":\n                        return patternComponent;\n                    default:\n                        return \" \";\n                }\n            }).join(\"\");\n        }\n    }]);\n\n    return _Symbol;\n}(Item);\n\nexports.Symbol = _Symbol;\n\nObject.defineProperties(_Symbol.prototype, {\n    operations: { enumerable: true },\n    parameters: { enumerable: true },\n    patternComponents: { enumerable: true },\n    pattern: { enumerable: true }\n});\nObject.defineProperties(_Symbol.prototype, {\n    operations_: { value: [], enumerable: false, writable: true },\n    parameters_: { value: [], enumerable: false, writable: true },\n    patternComponents_: { value: [], enumerable: false, writable: true },\n    html: { value: \"\", enumerable: true, writable: true }\n});\n\nvar Command = exports.Command = function (_Symbol2) {\n    _inherits(Command, _Symbol2);\n\n    function Command() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Command);\n\n        var _this3 = _possibleConstructorReturn(this, (Command.__proto__ || Object.getPrototypeOf(Command)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this3);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== \"string\") throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this3, \"name\", { value: opt_initialProperties.name });\n        }\n        return _this3;\n    }\n\n    _createClass(Command, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Command)) return false;\n            if (!_get(Command.prototype.__proto__ || Object.getPrototypeOf(Command.prototype), \"equals\", this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Command;\n}(_Symbol);\n\nObject.defineProperties(Command.prototype, {\n    name: { value: \"\", enumerable: true }\n});\nfunction isCommand(c) {\n    return c instanceof Command;\n}\nfunction mustBeCommand(c) {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\n\nvar Environment = exports.Environment = function (_Item3) {\n    _inherits(Environment, _Item3);\n\n    function Environment() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Environment);\n\n        var _this4 = _possibleConstructorReturn(this, (Environment.__proto__ || Object.getPrototypeOf(Environment)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this4);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== \"string\") throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this4, \"name\", { value: opt_initialProperties.name });\n        }\n        return _this4;\n    }\n\n    _createClass(Environment, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Environment)) return false;\n            if (!_get(Environment.prototype.__proto__ || Object.getPrototypeOf(Environment.prototype), \"equals\", this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Environment;\n}(Item);\n\nObject.defineProperties(Environment.prototype, {\n    name: { value: \"\", enumerable: true }\n});\nfunction isEnvironment(x) {\n    return x instanceof Environment;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SourceToken = exports.SpaceToken = exports.EnvironmentBodyToken = exports.EnvironmentToken = exports.CommandToken = exports.ParameterToken = exports.SymbolToken = exports.Token = exports.LatexTree = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isCommandToken = isCommandToken;\nexports.mustBeEnvironmentToken = mustBeEnvironmentToken;\nexports.isEnvironmentToken = isEnvironmentToken;\n\nvar _LatexStyle = __webpack_require__(2);\n\nvar _SyntaxTree2 = __webpack_require__(4);\n\nvar _Latex = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar LatexTree = exports.LatexTree = function (_SyntaxTree) {\n    _inherits(LatexTree, _SyntaxTree);\n\n    function LatexTree(rootToken, source) {\n        _classCallCheck(this, LatexTree);\n\n        if (!(rootToken instanceof Token)) throw new TypeError('\"rootToken\" isn\\'t a Token instance');\n        return _possibleConstructorReturn(this, (LatexTree.__proto__ || Object.getPrototypeOf(LatexTree)).call(this, rootToken, source));\n    }\n\n    return LatexTree;\n}(_SyntaxTree2.SyntaxTree);\n\nvar Token = exports.Token = function (_Node) {\n    _inherits(Token, _Node);\n\n    function Token() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Token);\n\n        if (opt_initialProperties === undefined) {\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this));\n        } else if (opt_initialProperties instanceof Object) {\n            var superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this, superInitialProperties));\n        } else {\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n        return _possibleConstructorReturn(_this2);\n    }\n\n    _createClass(Token, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), \"toString\", this).call(this, true) : \"Token{\" + _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), \"toString\", this).call(this, true) + \"}\";\n        }\n    }]);\n\n    return Token;\n}(_SyntaxTree2.Node);\n\nObject.defineProperties(Token.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    parentNodeClass_: { value: Token }\n});\n\nvar SymbolToken = exports.SymbolToken = function (_Token) {\n    _inherits(SymbolToken, _Token);\n\n    function SymbolToken(initialProperties) {\n        _classCallCheck(this, SymbolToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this3 = _possibleConstructorReturn(this, (SymbolToken.__proto__ || Object.getPrototypeOf(SymbolToken)).call(this, initialProperties));\n\n        if (initialProperties.symbol) {\n            if (!(initialProperties.symbol instanceof _LatexStyle.Symbol)) throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            Object.defineProperty(_this3, \"symbol\", { value: initialProperties.symbol, enumerable: true });\n        } else {\n            if (typeof initialProperties.pattern !== \"string\") throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            Object.defineProperty(_this3, \"pattern\", { value: initialProperties.pattern });\n        }\n        return _this3;\n    }\n\n    _createClass(SymbolToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = \"\";\n            var iParameter = 0;\n            var pattern = this.pattern;\n            for (var nPatternChars = pattern.length, iPatternChar = 0; iPatternChar < nPatternChars; ++iPatternChar) {\n                var patternChar = pattern[iPatternChar];\n                if (patternChar === \"#\") {\n                    ++iPatternChar;\n                    var parameterToken = this.childNode(iParameter++);\n                    source += parameterToken ? parameterToken.toString(true) : \"??\";\n                } else {\n                    source += patternChar;\n                }\n            }\n            return skipNodeClass ? source : \"SymbolToken\" + (this.symbol ? \"\" : \"[?]\") + \"{\" + source + \"}\";\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.symbol ? this.symbol.lexeme : undefined;\n        }\n    }, {\n        key: \"pattern\",\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.symbol).pattern;\n        }\n    }]);\n\n    return SymbolToken;\n}(Token);\n\nObject.defineProperties(SymbolToken.prototype, {\n    symbol: { value: undefined, enumerable: true }\n});\nObject.defineProperties(SymbolToken.prototype, {\n    pattern: { enumerable: true }\n});\n\nvar ParameterToken = exports.ParameterToken = function (_Token2) {\n    _inherits(ParameterToken, _Token2);\n\n    function ParameterToken(initialProperties) {\n        _classCallCheck(this, ParameterToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this4 = _possibleConstructorReturn(this, (ParameterToken.__proto__ || Object.getPrototypeOf(ParameterToken)).call(this, initialProperties));\n\n        if (!initialProperties.hasBrackets) Object.defineProperty(_this4, \"hasBrackets\", { value: false, enumerable: true });\n        if (initialProperties.hasSpacePrefix) Object.defineProperty(_this4, \"hasSpacePrefix\", { value: true, enumerable: true });\n        return _this4;\n    }\n\n    _createClass(ParameterToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = this.hasSpacePrefix ? \" \" : \"\";\n            source += this.hasBrackets ? \"{\" + _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), \"toString\", this).call(this, true) + \"}\" : _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), \"toString\", this).call(this, true);\n            return skipNodeClass ? source : \"ParameterToken{\" + source + \"}\";\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n        }\n    }, {\n        key: \"parameter\",\n        get: function get() {\n            var symbolToken = this.parentNode;\n            var symbol = (0, _Utils.mustNotBeUndefined)(symbolToken.symbol);\n            var parameterIndex = symbolToken.childIndex(this);\n            if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0) return symbol.parameter(parameterIndex);\n        }\n    }]);\n\n    return ParameterToken;\n}(Token);\n\nObject.defineProperties(ParameterToken.prototype, {\n    hasBrackets: { value: true, enumerable: true },\n    hasSpacePrefix: { value: false, enumerable: true },\n    parentNodeClass_: { value: SymbolToken }\n});\nObject.defineProperties(ParameterToken.prototype, {\n    parameter: { enumerable: true }\n});\n\nvar CommandToken = exports.CommandToken = function (_SymbolToken) {\n    _inherits(CommandToken, _SymbolToken);\n\n    function CommandToken(initialProperties) {\n        _classCallCheck(this, CommandToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var superInitialProperties = Object.create(initialProperties);\n        if (initialProperties.command) {\n            if (!(initialProperties.command instanceof _LatexStyle.Command)) throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            superInitialProperties.symbol = initialProperties.command;\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n        } else {\n            if (typeof initialProperties.name !== \"string\") throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = \"\";\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n\n            Object.defineProperty(_this5, \"name\", { value: initialProperties.name });\n        }\n        return _possibleConstructorReturn(_this5);\n    }\n\n    _createClass(CommandToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = \"\\\\\" + this.name + _get(CommandToken.prototype.__proto__ || Object.getPrototypeOf(CommandToken.prototype), \"toString\", this).call(this, true);\n            return skipNodeClass ? source : \"CommandToken\" + ((0, _LatexStyle.isCommand)(this.symbol) ? \"\" : \"[?]\") + \"{\" + source + \"}\";\n        }\n    }, {\n        key: \"command\",\n        get: function get() {\n            return (0, _LatexStyle.mustBeCommand)(this.symbol);\n        }\n    }, {\n        key: \"name\",\n        get: function get() {\n            return this.command.name;\n        }\n    }]);\n\n    return CommandToken;\n}(SymbolToken);\n\nObject.defineProperties(CommandToken.prototype, {\n    command: { enumerable: true },\n    name: { enumerable: true }\n});\nfunction isCommandToken(x) {\n    return x && x instanceof CommandToken;\n}\n\nvar EnvironmentToken = exports.EnvironmentToken = function (_Token3) {\n    _inherits(EnvironmentToken, _Token3);\n\n    function EnvironmentToken(initialProperties) {\n        _classCallCheck(this, EnvironmentToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this6 = _possibleConstructorReturn(this, (EnvironmentToken.__proto__ || Object.getPrototypeOf(EnvironmentToken)).call(this, initialProperties));\n\n        if (!(initialProperties.environment instanceof _LatexStyle.Environment)) throw new TypeError('\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        Object.defineProperty(_this6, \"environment\", {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n        return _this6;\n    }\n\n    _createClass(EnvironmentToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var beginCommandToken = this.beginCommandToken;\n            var endCommandToken = this.endCommandToken;\n            var bodyToken = this.bodyToken;\n            var source = \"\\\\begin{\" + this.environment.name + \"}\";\n            source += beginCommandToken ? SymbolToken.prototype.toString.call(beginCommandToken, true) : \"??\";\n            source += bodyToken ? bodyToken.toString(true) : \"??\";\n            source += \"\\\\end{\" + this.environment.name + \"}\";\n            source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : \"??\";\n            return skipNodeClass ? source : \"EnvironmentToken{\" + source + \"}\";\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.environment.lexeme;\n        }\n    }, {\n        key: \"beginCommandToken\",\n        get: function get() {\n            var beginCommandToken = this.childNode(0);\n            return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\n        }\n    }, {\n        key: \"endCommandToken\",\n        get: function get() {\n            var endCommandToken = this.childNode(2);\n            return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\n        }\n    }, {\n        key: \"bodyToken\",\n        get: function get() {\n            var bodyToken = this.childNode(1);\n            return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\n        }\n    }]);\n\n    return EnvironmentToken;\n}(Token);\n\nObject.defineProperties(EnvironmentToken.prototype, {\n    beginToken: { enumerable: true },\n    endToken: { enumerable: true }\n});\nfunction mustBeEnvironmentToken(x) {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\nfunction isEnvironmentToken(x) {\n    return x instanceof EnvironmentToken;\n}\nfunction getBeginCommandToken(x) {\n    if (isCommandToken(x.beginCommandToken)) return x.beginCommandToken;\n}\nfunction getEndCommandToken(x) {\n    if (isCommandToken(x.endCommandToken)) return x.endCommandToken;\n}\nfunction getEnvironment(x) {\n    if (x.environment && (0, _LatexStyle.isEnvironment)(x.environment)) return x.environment;\n}\n\nvar EnvironmentBodyToken = exports.EnvironmentBodyToken = function (_Token4) {\n    _inherits(EnvironmentBodyToken, _Token4);\n\n    function EnvironmentBodyToken() {\n        _classCallCheck(this, EnvironmentBodyToken);\n\n        return _possibleConstructorReturn(this, (EnvironmentBodyToken.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken)).apply(this, arguments));\n    }\n\n    _createClass(EnvironmentBodyToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), \"toString\", this).call(this, true) : \"EnvironmentBodyToken{\" + _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), \"toString\", this).call(this, true) + \"}\";\n        }\n    }, {\n        key: \"environment\",\n        get: function get() {\n            return this.parentNode && getEnvironment(this.parentNode);\n        }\n    }, {\n        key: \"environmentToken\",\n        get: function get() {\n            return this.parentNode && mustBeEnvironmentToken(this.parentNode);\n        }\n    }, {\n        key: \"beginCommandToken\",\n        get: function get() {\n            return this.parentNode && getBeginCommandToken(this.parentNode);\n        }\n    }, {\n        key: \"endCommandToken\",\n        get: function get() {\n            return this.parentNode && getEndCommandToken(this.parentNode);\n        }\n    }]);\n\n    return EnvironmentBodyToken;\n}(Token);\n\nObject.defineProperties(EnvironmentBodyToken.prototype, {\n    parentNodeClass_: { value: EnvironmentToken }\n});\n\nvar SpaceToken = exports.SpaceToken = function (_Token5) {\n    _inherits(SpaceToken, _Token5);\n\n    function SpaceToken(initialProperties) {\n        _classCallCheck(this, SpaceToken);\n\n        if (initialProperties === undefined) {\n            var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this));\n\n            return _possibleConstructorReturn(_this8);\n        } else if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this, initialProperties));\n\n        if (initialProperties.lineBreakCount) {\n            if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0) throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\n            Object.defineProperty(_this8, \"lineBreakCount\", {\n                value: initialProperties.lineBreakCount,\n                enumerable: true\n            });\n        }\n        return _possibleConstructorReturn(_this8);\n    }\n\n    _createClass(SpaceToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (skipNodeClass) {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return \" \";\n                    case 1:\n                        return \"\\n\";\n                    default:\n                        return \"\\n\\n\";\n                }\n            } else {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return \"SpaceToken{ }\";\n                    case 1:\n                        return \"SpaceToken{\\n}\";\n                    default:\n                        return \"SpaceToken{\\n\\n}\";\n                }\n            }\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n        }\n    }]);\n\n    return SpaceToken;\n}(Token);\n\nObject.defineProperties(SpaceToken.prototype, {\n    lineBreakCount: { value: 0, enumerable: true }\n});\n\nvar SourceToken = exports.SourceToken = function (_Token6) {\n    _inherits(SourceToken, _Token6);\n\n    function SourceToken(initialProperties) {\n        _classCallCheck(this, SourceToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this9 = _possibleConstructorReturn(this, (SourceToken.__proto__ || Object.getPrototypeOf(SourceToken)).call(this, initialProperties));\n\n        if (!_Latex.Lexeme[initialProperties.lexeme]) throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\n        Object.defineProperty(_this9, \"lexeme\", { value: initialProperties.lexeme, enumerable: true });\n        if (typeof initialProperties.source !== \"string\") throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\n        Object.defineProperty(_this9, \"source\", { value: initialProperties.source, enumerable: true });\n        return _this9;\n    }\n\n    _createClass(SourceToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? this.source : \"SourceToken[\" + this.lexeme + \"]{\" + this.source + \"}\";\n        }\n    }]);\n\n    return SourceToken;\n}(Token);\n\nexports.default = _SyntaxTree2.SyntaxTree;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Node = exports.SyntaxTree = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\"use strict\";\n\nvar SyntaxTree = exports.SyntaxTree = function SyntaxTree(rootNode, source) {\n    _classCallCheck(this, SyntaxTree);\n\n    if (!(rootNode instanceof Node)) throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n    if (typeof source !== \"string\") throw new TypeError('\"sources\" isn\\'t a string');\n    Object.defineProperty(this, \"rootNode\", { value: rootNode, enumerable: true });\n    Object.defineProperty(this, \"source\", { value: source, enumerable: true });\n    Object.defineProperty(rootNode, \"tree\", { value: this, enumerable: true });\n};\n\nvar Node = exports.Node = function () {\n    function Node(opt_initialProperties) {\n        _classCallCheck(this, Node);\n\n        if (opt_initialProperties !== undefined) {\n            if (!(opt_initialProperties instanceof Object)) throw new TypeError(\"initialProperties isn't an Object instance\");\n            if (opt_initialProperties.childNodes !== undefined) {\n                if (!(opt_initialProperties.childNodes instanceof Array)) throw new TypeError(\"initialProperties.childNodes isn't an Array instance\");\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n            }\n            var optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) {\n                if (!!optParentNode) {\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError(\"initialProperties.parentNode isn't a SyntaxTree.Node instance\");\n                }\n            }\n        }\n    }\n\n    _createClass(Node, [{\n        key: \"childNode\",\n        value: function childNode(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] || undefined;\n            if (node instanceof Node) return node.parentNode === this ? node : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: \"childIndex\",\n        value: function childIndex(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] ? node : undefined;\n            if (node instanceof Node) return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: \"insertChildNode\",\n        value: function insertChildNode(node, childIndex, childNodesToCover) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n            if (!this.hasOwnProperty(\"childNodes_\")) Object.defineProperty(this, \"childNodes_\", { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            if (childNodesToCover === undefined) childNodesToCover = 0;\n            var nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n            Object.defineProperty(this, \"subtreeSize\", {\n                value: this.subtreeSize + 1,\n                enumerable: true,\n                configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, \"subtreeSize\", { value: parentNode.subtreeSize + 1 });\n            }\n            Object.defineProperty(node, \"parentNode\", {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n            if (nodeChildNodes.length) {\n                Object.defineProperty(node, \"childNodes_\", { value: nodeChildNodes, configurable: true });\n                var subtreeSize = 1;\n                nodeChildNodes.forEach(function (nodeChildNode) {\n                    subtreeSize += nodeChildNode.subtreeSize;\n                });\n                Object.defineProperty(node, \"subtreeSize\", {\n                    value: subtreeSize,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n            return node;\n        }\n    }, {\n        key: \"insertChildSubtree\",\n        value: function insertChildSubtree(node, childIndex) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (!this.hasOwnProperty(\"childNodes_\")) Object.defineProperty(this, \"childNodes_\", { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            this.childNodes_.splice(childIndex, 0, node);\n            var nodeSubtreeSize = node.subtreeSize;\n            Object.defineProperty(this, \"subtreeSize\", {\n                value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, \"subtreeSize\", {\n                    value: parentNode.subtreeSize + nodeSubtreeSize\n                });\n            }\n            Object.defineProperty(node, \"parentNode\", {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }, {\n        key: \"removeChildNode\",\n        value: function removeChildNode(nodeOrNodeIndex) {\n            var _childNodes_;\n\n            var nodeChildIndex = this.childIndex(nodeOrNodeIndex);\n            if (nodeChildIndex === undefined) return undefined;\n            var node = this.childNodes_[nodeChildIndex];\n            (_childNodes_ = this.childNodes_).splice.apply(_childNodes_, [nodeChildIndex, 1].concat(_toConsumableArray(node.childNodes_)));\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, \"subtreeSize\", { value: this.subtreeSize - 1 });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, \"subtreeSize\", { value: parentNode.subtreeSize - 1 });\n            }\n            delete node.parentNode;\n            delete node.childNodes_;\n            delete node.subtreeSize;\n            return node;\n        }\n    }, {\n        key: \"removeChildSubtree\",\n        value: function removeChildSubtree(node) {\n            var nodeChildIndex = this.childIndex(node);\n            if (nodeChildIndex === undefined) return undefined;\n            node = this.childNodes_.splice(nodeChildIndex, 1)[0];\n            var nodeSubtreeSize = node.subtreeSize;\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, \"subtreeSize\", { value: this.subtreeSize - nodeSubtreeSize });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, \"subtreeSize\", {\n                    value: parentNode.subtreeSize - nodeSubtreeSize\n                });\n            }\n            delete node.parentNode;\n            return node;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = \"\";\n            this.childNodes_.forEach(function (childNode) {\n                source += childNode.toString(true);\n            });\n            return skipNodeClass ? source : \"SourceTree.Node{\" + source + \"}\";\n        }\n    }, {\n        key: \"childNodes\",\n        get: function get() {\n            return this.childNodes_.slice();\n        }\n    }]);\n\n    return Node;\n}();\n\nObject.defineProperties(Node.prototype, {\n    childNodes: { enumerable: true }\n});\nObject.defineProperties(Node.prototype, {\n    tree: { value: undefined, enumerable: true },\n    parentNode: { value: undefined, enumerable: true },\n    subtreeSize: { value: 1, enumerable: true },\n    childNodes_: { value: [], enumerable: false },\n    parentNodeClass_: { value: Node, enumerable: false }\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Context = exports.LatexParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _LatexStyle = __webpack_require__(2);\n\nvar _LatexTree = __webpack_require__(3);\n\nvar _Latex = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction parseToken_(context, latexStyle) {\n    var token = parseSpaceToken_(context);\n    if (!token) {\n        if (context.position >= context.source.length) return undefined;\n        var contextBackup = context.copy();\n        if (!(token = parseEnvironmentToken_(context, latexStyle))) {\n            contextBackup.copy(context);\n            if (!(token = parseCommandToken_(context, latexStyle))) {\n                contextBackup.copy(context);\n                if (!(token = parseSymbolsToken_(context, latexStyle))) {\n                    return undefined;\n                }\n            }\n        }\n    }\n    processParsedToken_(context, token);\n    return token;\n}\nfunction parseParameterToken_(context, latexStyle, parameter, opt_endLabel) {\n    var currentTokenBackup = context.currentToken;\n    context.updateState(parameter.operations);\n    if (opt_endLabel === undefined) {\n        var spacePrefixState = parseSpaceToken_(context) !== undefined;\n        if (context.source[context.position] === \"{\") {\n            context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState });\n            ++context.position;\n            ++context.charNumber;\n            if (!parseUntilLabel_(context, latexStyle, \"}\", parameter.lexeme)) return undefined;\n            ++context.position;\n            ++context.charNumber;\n        } else {\n            context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState });\n            if (parseToken_(context, latexStyle) === undefined) return undefined;\n        }\n    } else {\n        context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: false });\n        if (!parseUntilLabel_(context, latexStyle, opt_endLabel, parameter.lexeme)) return undefined;\n    }\n    var parameterToken = context.currentToken;\n    context.currentToken = currentTokenBackup;\n    processParsedToken_(context, parameterToken);\n    return parameterToken;\n}\nfunction parseEnvironmentToken_(context, latexStyle) {\n    if (context.source.substring(context.position).indexOf(\"\\\\begin\") !== 0) return undefined;\n    context.position += 6;\n    parseSpaceToken_(context);\n    var nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n    if (!nameMatch) return undefined;\n    var name = nameMatch[1];\n    context.position += nameMatch[0].length;\n    context.charNumber += nameMatch[0].length;\n    var currentTokenBackup = context.currentToken;\n    var environment = latexStyle.environments(context.currentState, name)[0];\n    var environmentToken = context.currentToken = environment ? new _LatexTree.EnvironmentToken({ environment: environment.environment }) : new _LatexTree.EnvironmentToken({ name: name });\n    var symbols = latexStyle.commands(context.currentState, name);\n    var beginCommandToken = parsePatterns_(context, latexStyle, symbols);\n    if (beginCommandToken === undefined) {\n        beginCommandToken = new _LatexTree.CommandToken({ name: name });\n    }\n    processParsedToken_(context, beginCommandToken);\n    var environmentBodyToken = context.currentToken = new _LatexTree.EnvironmentBodyToken();\n    var endFound = parseUntilLabel_(context, latexStyle, \"\\\\end{\" + name + \"}\");\n    context.currentToken = environmentToken;\n    processParsedToken_(context, environmentBodyToken);\n    var endCommandToken = undefined;\n    if (endFound) {\n        context.position += name.length + 6;\n        context.charNumber += name.length + 6;\n        endCommandToken = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, \"end\" + name));\n    } else {}\n    if (endCommandToken === undefined) {\n        endCommandToken = new _LatexTree.CommandToken({ name: \"end\" + name });\n    }\n    processParsedToken_(context, endCommandToken);\n    context.currentToken = currentTokenBackup;\n    return environmentToken;\n}\nfunction parseCommandToken_(context, latexStyle) {\n    var cmdMatch = context.source.substring(context.position).match(/^\\\\((?:[\\w@]+\\*?)|(?:[^\\w]))/);\n    if (!cmdMatch) return undefined;\n    context.position += cmdMatch[0].length;\n    context.charNumber += cmdMatch[0].length;\n    var token = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, cmdMatch[1]));\n    if (token === undefined) {\n        token = new _LatexTree.CommandToken({ name: cmdMatch[1] });\n    }\n    return token;\n}\nfunction parseSymbolsToken_(context, latexStyle) {\n    var sourceCharacter = context.source[context.position];\n    var token = parsePatterns_(context, latexStyle, latexStyle.symbols(context.currentState, sourceCharacter));\n    if (token === undefined) {\n        ++context.position;\n        ++context.charNumber;\n        token = new _LatexTree.SymbolToken({ pattern: sourceCharacter });\n    } else {}\n    return token;\n}\nfunction parsePatterns_(context, latexStyle, symbols) {\n    var contextBackup = context.copy();\n    var token = undefined;\n    symbols.some(function (symbol) {\n        if (token = parsePattern_(context, latexStyle, symbol)) {\n            return true;\n        } else {\n            contextBackup.copy(context);\n            return false;\n        }\n    });\n    return token;\n}\nfunction parsePattern_(context, latexStyle, symbol) {\n    var currentTokenBackup = context.currentToken;\n    context.currentToken = symbol instanceof _LatexStyle.Command ? new _LatexTree.CommandToken({ command: symbol }) : new _LatexTree.SymbolToken({ symbol: symbol });\n    var patternComponents = symbol.patternComponents;\n    var nPatternComponents = patternComponents.length;\n    var iPatternComponent = 0;\n    for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n        var patternComponent = patternComponents[iPatternComponent];\n        if ((0, _Utils.isNumber)(patternComponent)) {\n            var parameter = symbol.parameter(patternComponent);\n            var parameterEndLabel = patternComponents[iPatternComponent + 1];\n            if (typeof parameterEndLabel === \"string\") {\n                if (parseParameterToken_(context, latexStyle, (0, _Utils.mustNotBeUndefined)(parameter), parameterEndLabel)) {\n                    if (context.source.substring(context.position).indexOf(parameterEndLabel) !== 0) return undefined;\n                    context.position += parameterEndLabel.length;\n                    context.charNumber += parameterEndLabel.length;\n                    ++iPatternComponent;\n                    continue;\n                }\n            } else {\n                if (parseParameterToken_(context, latexStyle, (0, _Utils.mustNotBeUndefined)(parameter))) continue;\n            }\n        } else if ((0, _Utils.isString)(patternComponent)) {\n            while (parseCommentLine_(context)) {}\n            if (context.source.substring(context.position).indexOf(patternComponent) === 0) {\n                context.position += patternComponent.length;\n                context.charNumber += patternComponent.length;\n                continue;\n            }\n        } else if (parseSpaceToken_(context)) continue;\n        break;\n    }\n    if (iPatternComponent < nPatternComponents) return undefined;\n    var parsedToken = context.currentToken;\n    context.currentToken = currentTokenBackup;\n    context.updateState(symbol.operations);\n    return parsedToken;\n}\nfunction parseUntilLabel_(context, latexStyle, endLabel, opt_lexeme) {\n    switch (opt_lexeme) {\n        default:\n            {\n                while (context.source.substring(context.position).indexOf(endLabel) !== 0) {\n                    if (context.position >= context.source.length) {\n                        return false;\n                    }\n                    parseToken_(context, latexStyle);\n                }\n                return true;\n            }\n    }\n}\nfunction parseCommentLine_(context) {\n    var commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false;\n    context.comments.push(commentMatch[1]);\n    context.position += commentMatch[0].length;\n    if (!commentMatch[2]) {\n        context.charNumber += commentMatch[0].length;\n    } else {\n        ++context.lineNumber;\n        context.charNumber = commentMatch[2].length - 1;\n    }\n    return true;\n}\nfunction processParsedToken_(context, token) {\n    if (context.currentToken) {\n        context.currentToken.insertChildSubtree(token);\n    }\n}\nfunction parseSpaceToken_(context) {\n    var isSpace = false;\n    var nLineBreaks = 0;\n    while (context.position < context.source.length) {\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) {\n            case \" \":\n            case \"\\t\":\n                isSpace = true;\n                ++context.position;\n                ++context.charNumber;\n                continue;\n            case \"\\n\":\n                isSpace = true;\n                ++nLineBreaks;\n                ++context.position;\n                ++context.lineNumber;\n                context.charNumber = 0;\n                continue;\n        }\n        break;\n    }\n    return isSpace ? new _LatexTree.SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\n}\n\nvar LatexParser = exports.LatexParser = function () {\n    function LatexParser(latexStyle) {\n        _classCallCheck(this, LatexParser);\n\n        if (!(latexStyle instanceof _LatexStyle.LatexStyle)) throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\n        Object.defineProperty(this, \"latexStyle\", { value: latexStyle, enumerable: true });\n    }\n\n    _createClass(LatexParser, [{\n        key: \"parse\",\n        value: function parse(source, opt_context) {\n            if (typeof source !== \"string\") throw new TypeError(\"\\\"sources\\\" isn't a string\");\n            var context = void 0;\n            if (opt_context === undefined) {\n                context = new Context(source);\n            } else if (opt_context instanceof Context) {\n                context = opt_context;\n                context.source += source;\n            } else {\n                throw new TypeError(\"\\\"context\\\" isn't a LatexParser.Context instance\");\n            }\n            var parsedTokens = [];\n            var parsedToken = void 0;\n            while (parsedToken = parseToken_(context, this.latexStyle)) {\n                parsedTokens.push(parsedToken);\n            }return parsedTokens;\n        }\n    }]);\n\n    return LatexParser;\n}();\n\nvar Context = exports.Context = function () {\n    function Context() {\n        var opt_source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n        _classCallCheck(this, Context);\n\n        this.source = opt_source;\n        this.position = 0;\n        this.lineNumber = 0;\n        this.charNumber = 0;\n        this.currentToken = undefined;\n        this.currentState = new _Latex.State();\n        this.stateStack = [];\n        this.comments = [];\n    }\n\n    _createClass(Context, [{\n        key: \"copy\",\n        value: function copy(opt_target) {\n            var target = opt_target || new Context();\n            target.source = this.source;\n            target.position = this.position;\n            target.lineNumber = this.lineNumber;\n            target.charNumber = this.charNumber;\n            target.currentToken = this.currentToken;\n            target.currentState = this.currentState.copy();\n            target.stateStack = this.stateStack.slice();\n            target.comments = this.comments.slice();\n            return target;\n        }\n    }, {\n        key: \"updateState\",\n        value: function updateState(operations) {\n            var _this = this;\n\n            if (!(operations instanceof Array)) throw new TypeError('\"operations\" isn\\'t an Array instance');\n            var newModeStates = {};\n            operations.forEach(function (operation) {\n                switch (operation.directive) {\n                    case _Latex.Directive.BEGIN:\n                        switch (operation.operand) {\n                            case _Latex.GROUP:\n                                _this.currentState.update(newModeStates);\n                                newModeStates = {};\n                                _this.stateStack.push(_this.currentState.copy());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = true;\n                        }\n                        break;\n                    case _Latex.Directive.END:\n                        switch (operation.operand) {\n                            case _Latex.GROUP:\n                                newModeStates = {};\n                                if (_this.stateStack.length < 1) throw new Error(\"state stack is empty\");\n                                _this.currentState = (0, _Utils.mustNotBeUndefined)(_this.stateStack.pop());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = false;\n                        }\n                        break;\n                }\n            });\n            this.currentState.update(newModeStates);\n        }\n    }]);\n\n    return Context;\n}();\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(0);\n\nObject.keys(_Utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Utils[key];\n    }\n  });\n});\n\nvar _Latex = __webpack_require__(1);\n\nObject.keys(_Latex).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Latex[key];\n    }\n  });\n});\n\nvar _LatexStyle = __webpack_require__(2);\n\nObject.keys(_LatexStyle).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexStyle[key];\n    }\n  });\n});\n\nvar _SyntaxTree = __webpack_require__(4);\n\nObject.keys(_SyntaxTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _SyntaxTree[key];\n    }\n  });\n});\n\nvar _LatexTree = __webpack_require__(3);\n\nObject.keys(_LatexTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexTree[key];\n    }\n  });\n});\n\nvar _LatexParser = __webpack_require__(5);\n\nObject.keys(_LatexParser).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexParser[key];\n    }\n  });\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// latex-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d0873b549b14dc732a68","/**\n * @fileoverview General JavaScript utils\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\nexport type StringMap = { [s: string]: string };\n\nexport type TargetObject = any;\nexport type ValuesObject = any;\n\nexport type OptKeys = StringMap | string[];\n\nexport interface OptAttributes {\n    writable: boolean;\n    enumerable: boolean;\n    configurable: boolean;\n}\n/**\n * Update object properties by property values\n * @param {!Object} target the object to copy properties to\n * @param {!Object} values the object with property values (undefined values will be skipped)\n * @param {(!Object.<string,string>|!Array.<string>)=} opt_keys\n *        list of keys or map of the target keys to the property names, all the enumerable\n *        properties will be used if undefined\n * @param {{writable:boolean,enumerable:boolean,configurable:boolean}=} opt_attributes\n *        property attributes, { writable: true, enumerable: true, configurable: true } by default\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport function updateProperties(target: TargetObject,\n                                 values: ValuesObject,\n                                 opt_keys?: OptKeys,\n                                 opt_attributes: OptAttributes = {\n                                     writable: true,\n                                     enumerable: true,\n                                     configurable: true\n                                 }) {\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return; // do noting is the sources is undefined\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = {writable: true, enumerable: true, configurable: true};\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) { // if the key map isn't defined\n        for (const key in values) { // for all the enumerable properties\n            //noinspection JSUnfilteredForInLoop\n            if (values[key] !== undefined) {\n                //noinspection JSUnfilteredForInLoop\n                Object.defineProperty(target, key, // update the property\n                    // using the defined value\n                    Object.create(opt_attributes, {value: {value: values[key]}})\n                );\n            }\n        }\n    } else if (opt_keys instanceof Array) { // if the list of the keys is defined\n        opt_keys.forEach(key => {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, // update the property\n                    Object.create(opt_attributes, {value: {value: values[key]}}) // using the defined value\n                );\n            }\n        });\n    } else if (opt_keys instanceof Object) { // if the map of the keys is defined\n        for (const targetKey in opt_keys) { // for all the target keys\n            //noinspection JSUnfilteredForInLoop\n            const key = opt_keys[targetKey]; // the sources key\n            if (values[key] !== undefined)\n            //noinspection JSUnfilteredForInLoop\n                Object.defineProperty(target, targetKey, // update the property\n                    // using the defined value\n                    Object.create(opt_attributes, {value: {value: values[key]}})\n                );\n        }\n    } else { // if \"keys\" has unsupported value\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\n\n\n/**\n * Test object properties with property values (strict comparing is used)\n * @param {!Object} target the object with properties to test\n * @param {?Object} values the object with property values (undefined values will be skipped)\n * @param {?(Object.<string,string>|Array.<string>)} opt_keys\n *        list of keys or map of the target keys to the property names, all the enumerable\n *        properties will be used if undefined\n * @param {boolean=true} opt_skipUndefined true to skip keys with undefined values, false otherwise\n * @return {boolean} true if all the defined properties are the same false otherwise\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport function testProperties(target: TargetObject,\n                               values?: ValuesObject,\n                               opt_keys?: OptKeys,\n                               opt_skipUndefined = true) {\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true; // do noting is the sources is undefined\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true; // skip undefined by default\n\n    if (opt_keys === undefined) { // if the key map isn't defined\n        for (const key in values) { // for all the enumerable properties\n            //noinspection JSUnfilteredForInLoop // TODO what to do?\n            if (\n                target[key] !== values[key]\n                && !(values[key] === undefined && opt_skipUndefined)\n            )\n                return false; // false if any value is different\n        }\n    } else if (opt_keys instanceof Array) { // if the list of the keys is defined\n        return opt_keys.every(key => {\n            return target[key] === values[key] || (values[key] === undefined && opt_skipUndefined);\n        });\n    } else if (opt_keys instanceof Object) { // if the map of the keys is defined\n        for (const targetKey in opt_keys) { // for all the target keys\n            const key = opt_keys[targetKey]; // the sources key\n            if (target[targetKey] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\n                return false; // false if any value is different\n        }\n    } else { // if \"keys\" has unsupported value\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true; // return true if all the defined properties are the same\n}\n\n\nexport function isNumber(x: any): x is number {\n    return typeof x === \"number\";\n}\n\nexport function isString(x: any): x is string {\n    return typeof x === \"string\";\n}\n\nexport function mustNotBeUndefined<T>(x?: T): T {\n    if (!x) throw new Error();\n    return x;\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Utils.ts","/**\n * @fileoverview General LaTeX definitions\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n\"use strict\";\n\n/**@module */\n\n\n/**\n * LaTeX lexeme\n * @enum {string}\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport const Lexeme = {\n    CELL_SEPARATOR: \"CELL_SEPARATOR\",           // table cell separator\n    BRACKETS: \"BRACKETS\",                       // logical brackets\n    BINARY_OPERATOR: \"BINARY_OPERATOR\",         // mathematical binary operator\n    CHAR: \"CHAR\",                               // character\n    DIGIT: \"DIGIT\",                             // digit\n    DIRECTIVE: \"DIRECTIVE\",                     // LaTeX directive\n    DISPLAY_EQUATION: \"DISPLAY_EQUATION\",       // mathematical equation for display mode\n    FILE_PATH: \"FILE_PATH\",                     // file system path\n    FLOATING_BOX: \"FLOATING_BOX\",               // floating box\n    HORIZONTAL_SKIP: \"HORIZONTAL_SKIP\",         // any type of horizontal skip but not space\n    INLINE_EQUATION: \"INLINE_EQUATION\",         // mathematical equation for inline mode\n    LABEL: \"LABEL\",                             // label identifier\n    LENGTH: \"LENGTH\",                           // linear dimension\n    LETTER: \"LETTER\",                           // word letter\n    LINE_BREAK: \"LINE_BREAK\",                   // text line break\n    NUMBER: \"NUMBER\",                           // sequence of digits\n    LIST: \"LIST\",                               // list of items\n    LIST_ITEM: \"LIST_ITEM\",                     // list item\n    PARAGRAPH_SEPARATOR: \"PARAGRAPH_SEPARATOR\", // paragraph separator\n    PICTURE: \"PICTURE\",                         // picture\n    POST_OPERATOR: \"POST_OPERATOR\",             // mathematical post-operator\n    PRE_OPERATOR: \"PRE_OPERATOR\",               // mathematical pre-operator\n    RAW: \"RAW\",                                 // unprocessable or raw sources\n    SPACE: \"SPACE\",                             // any type of space equivalent\n    SUBSCRIPT: \"SUBSCRIPT\",                     // subscript text\n    SUPERSCRIPT: \"SUPERSCRIPT\",                 // subscript text\n    TABLE: \"TABLE\",                             // table\n    TABULAR_PARAMETERS: \"TABULAR_PARAMETERS\",   // LaTeX tabular parameters\n    TAG: \"TAG\",                                 // formatting tag\n    UNKNOWN: \"UNKNOWN\",                         // unrecognized element\n    VERTICAL_SKIP: \"VERTICAL_SKIP\",             // any type of vertical skip\n    WORD: \"WORD\",                               // sequence of letters\n    WRAPPER: \"WRAPPER\"                          // wrapper for something\n};\nexport type Lexeme = keyof typeof Lexeme;\n\n/**\n * LaTeX modes\n * @enum {string}\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport const modes = {\n    LIST: \"LIST\",        // list of items\n    MATH: \"MATH\",        // mathematical expressionLatex\n    PICTURE: \"PICTURE\",  // picture\n    TABLE: \"TABLE\",      // LaTeX tabular\n    TEXT: \"TEXT\",        // general text\n    VERTICAL: \"VERTICAL\" // vertical spacing\n};\n\nexport type Mode = keyof typeof modes;\n\nexport function isMode(x: any): x is Mode {\n    return modes.hasOwnProperty(x);\n}\n\nexport function mustBeMode(x: any): Mode {\n    if (!isMode(x)) throw new Error();\n    return x;\n}\n\nexport type ModeStates = { [mode: string]: boolean };\n/**\n * LaTeX state encapsulation\n * @class\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport class State {\n    private modeStates_: ModeStates;\n\n\n    /**\n     * Constructor\n     * @param {!Object.<Mode,boolean>=} opt_initialModeStates the initial mode states\n     * @constructor\n     * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n     */\n    constructor(opt_initialModeStates: ModeStates = {}) {\n        Object.defineProperty(this, \"modeStates_\", {value: {}, enumerable: false});\n\n        this.modeStates_[modes.LIST] = false;\n\n        this.modeStates_[modes.MATH] = false;\n\n        this.modeStates_[modes.PICTURE] = false;\n\n        this.modeStates_[modes.TABLE] = false;\n\n        this.modeStates_[modes.TEXT] = true;\n        //noinspection JSUnresolvedVariable\n        this.modeStates_[modes.VERTICAL] = false;\n        // update the mode states\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n\n    /**\n     * Create a copy of this state.\n     * @return {!State} the created copy\n     * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n     */\n    copy() {\n        //noinspection JSValidateTypes,JSUnresolvedVariable\n        return new State(this.modeStates_);\n    }\n\n\n    /**\n     * Update the state with states for modes\n     * @param {!Object.<Mode,boolean>} modeStates the states for modes\n     * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n     */\n    update(modeStates: ModeStates) {\n        for (const modeKey in modeStates) { // for all the given modes\n            //noinspection JSUnfilteredForInLoop\n            const mode = modes[mustBeMode(modeKey)]; // verify the mode key\n            if (mode === undefined) // if the mode is unknown\n                throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n            //noinspection JSUnfilteredForInLoop,JSUnresolvedVariable\n            this.modeStates_[mode] = modeStates[modeKey]; // store the mode state\n        }\n    }\n\n\n    /**\n     * Test the state with mode states\n     * @param {!Object.<Mode,boolean>} modeStates the states for modes\n     * @return {boolean} true if the state fits the modes, false otherwise\n     * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n     */\n    test(modeStates: ModeStates) {\n        for (const modeKey in modeStates) { // for all the given modes\n            const mode = modes[mustBeMode(modeKey)]; // verify the mode key\n            if (mode === undefined) // if the mode is unknown\n                throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n            // exit if the mode has different states\n            if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n        }\n        return true;\n    }\n}\n\n\n/**\n * LaTeX directive\n * @enum {string}\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport const Directive = {\n    BEGIN: \"BEGIN\", // begin something\n    END: \"END\"    // end something\n};\nexport type Directive = keyof typeof Directive;\n\n\n/**\n * Group operand for directives\n * @const {string}\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport const GROUP = \"GROUP\";\nexport type GROUP = \"GROUP\";\n\n\n/**\n * LaTeX operation properties\n * @interface OperationProperties\n * @property {Directive} directive - The directive or undefined if there is no a directive\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport interface OperationProperties {\n    directive: Directive;\n    operand: Mode | GROUP;\n}\nexport function isOperationProperties(x: any): x is OperationProperties {\n    return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\n}\n\nexport function mustBeOperationProperties(x: any): OperationProperties {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\n\n/**\n * LaTeX operation encapsulation\n * @class\n * @property {Directive} directive - The directive or undefined if there is no a directive\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport class Operation {\n    directive: Directive;\n    operand: Mode | GROUP;\n\n\n    /**\n     * Constructor\n     * @param {!OperationProperties=} opt_initialProperties the initial property values\n     * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n     */\n    constructor(opt_initialProperties?: OperationProperties) {\n        // do nothing if the initial properties aren't defined\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        const directive = Directive[opt_initialProperties.directive]; // validate the directive\n        if (!directive)\n            throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, \"directive\", {value: directive, enumerable: true});\n        switch (opt_initialProperties.operand) {\n            case GROUP: // if operand is a group\n                // store the operand\n                Object.defineProperty(this, \"operand\", {value: GROUP, enumerable: true});\n                break;\n            default:\n                const mode = modes[opt_initialProperties.operand]; // validate the operand as a mode\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\n                // store the operand\n                Object.defineProperty(this, \"operand\", {value: mode, enumerable: true});\n        }\n    }\n\n\n    /**\n     * Compare this operation with the other\n     * @param {!Operation} other the operation to compare with\n     * @return {boolean} True if the operations are equal false otherwise\n     * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n     */\n    equals(other: any) {\n        if (!(other instanceof Operation)) return false; // type test\n        return this.directive === other.directive && this.operand === other.operand;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex.ts","/**\n * @fileoverview LaTeX style structures\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n/**@module */\n\n\nimport {isNumber, mustNotBeUndefined, testProperties} from \"./Utils\"; // object property testing function\n\nimport {\n    Lexeme, Mode, modes, mustBeMode, mustBeOperationProperties, Operation, OperationProperties,\n    State\n} from \"./Latex\";\n\n\nfunction isArray(x: any): x is any[] {\n    return x.constructor === Array;\n}\n\nfunction mustBeArray(x: any): any[] {\n    if (!isArray(x))throw new Error();\n    return x;\n}\n\n/**\n * LaTeX style package properties\n * @interface PackageProperties\n * @property {(!Array.<!SymbolProperties>|undefined)} symbols - The symbols of the package in the priority descending order\n * @property {(!Array.<!CommandProperties>|undefined)} commands - The commands of the package in the priority descending order\n * @property {(!Array.<!EnvironmentProperties>|undefined)} environments - The environments of the package\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface PackageProperties {\n    symbols?: SymbolProperties[];\n    commands?: CommandProperties[];\n    environments?: EnvironmentProperties[];\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function mustBePackageProperties(x: any): PackageProperties {\n    if (!isPackageProperties(x)) throw new Error(\"Invalid format for PackageProperties\");\n    return x;\n}\n\nexport function isPackageProperties(x: any): x is PackageProperties {\n    // TODO all props are optional...\n    // symbols?: SymbolProperties[];\n    // commands?: CommandProperties[];\n    // environments?: EnvironmentProperties[];\n\n    return !Object.keys(x).some(k => {\n        switch (k) {\n            case \"symbols\":\n            case \"commands\":\n            case \"environments\":\n                return false;\n            default:\n                return true;\n        }\n    });\n}\n\n/**\n * LaTeX style collection\n * @class\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class LatexStyle {\n    private environments_: { [name: string]: EnvironmentAndPackage[] };\n    private commands_: { [name: string]: CommandAndPackage[] };\n    private symbols_: { [name: string]: SymbolAndPackage[] };\n\n\n    /**\n     * Constructor\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor() {\n        /**\n         * The symbols by the first symbol of the pattern in the priority increasing order\n         * @private {!Object.<string,!Array.<!Symbol>>}\n         * @name symbols_\n         */\n        this.symbols_ = {};\n        /**\n         * The commands by the name in the priority increasing order\n         * @private {!Object.<string,!Array.<!Command>>}\n         * @name commands_\n         */\n        this.commands_ = {};\n        /**\n         * The environments by the name in the priority increasing order\n         * @private {!Object.<string,!Array.<!Environment>>}\n         * @name environments_\n         */\n        this.environments_ = {};\n    }\n\n\n    /**\n     * Load a package with style definitions\n     * @param {string} packageName the name of the style package\n     * @param {PackageProperties} stylePackage the style package\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    loadPackage(packageName: string, stylePackage: PackageProperties) {\n        if (stylePackage.symbols !== undefined) { // if the symbol descriptions are defined\n            if (!(stylePackage.symbols instanceof Array))\n                throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n            // for all the symbol descriptions\n            for (let iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                const symbol: Symbol = new Symbol(stylePackage.symbols[iSymbol]); // the symbol description\n                if (symbol.pattern) { // if the symbol has a pattern\n                    const symbolPatternFirstChar = symbol.pattern[0]; // the first char of the pattern\n                    // the symbols with the same pattern first char\n                    if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar))\n                        this.symbols_[symbolPatternFirstChar] = [];\n                    //noinspection JSMismatchedCollectionQueryUpdate // TODO what to do?\n                    const symbols: SymbolAndPackage[] = this.symbols_[symbolPatternFirstChar];\n\n                    symbols.push({symbol, packageName}); // store the symbol and the package name\n                }\n            }\n        }\n        if (stylePackage.commands !== undefined) { // if the command descriptions are defined\n            if (!(stylePackage.commands instanceof Array))\n                throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n            // for all the command descriptions\n            for (let iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                const command = new Command(stylePackage.commands[iCommand]); // the command description\n                if (command.name) { // if the command has a name\n                    // the commands with the same name\n                    (this.commands_[command.name] || (this.commands_[command.name] = []))\n                        .push({command, packageName}); // store the command and the package name\n                }\n            }\n        }\n        if (stylePackage.environments !== undefined) { // if the environment descriptions are defined\n            if (!(stylePackage.environments instanceof Array))\n                throw new TypeError(`\"stylePackage.environments\" isn't an Array`);\n            // for all the environment descriptions\n            for (let iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0;\n                 --iEnvironment) {\n                // the environment description\n                const environment: Environment = new Environment(stylePackage.environments[iEnvironment]);\n                const envName: string = environment.name;\n                if (envName) { // if the environment has a name\n                    // the environments with the same name\n                    let storedEnv = this.environments_[envName];\n                    if (storedEnv === undefined) {\n                        storedEnv = [];\n                        this.environments_[envName] = storedEnv;\n                    }\n                    storedEnv.push({environment, packageName}); // store the environment and the package name\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Unload a package with style definitions\n     * @param {string} packageName the name of the style package\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    unloadPackage(packageName: string) {\n        // for all the symbol pattern first chars\n        for (const symbolPatternFirstChar in this.symbols_)\n            if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                // the filtered symbols with the same pattern first char\n                const filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(styleItem => {\n                    return styleItem.packageName !== packageName;\n                });\n                // if there are still some symbols with the same pattern first char\n                if (filteredSymbols.length) {\n                    // store the filtered symbol descriptions\n                    this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                } else { // if there are no the symbols with the same pattern first char\n                    delete this.symbols_[symbolPatternFirstChar]; // delete the key-value pair\n                }\n            }\n        // for all the command names\n        for (const commandName in this.commands_) if (this.commands_.hasOwnProperty(commandName)) {\n            // the filtered commands with the same name\n            const filteredCommands = mustBeArray(this.commands_[commandName]).filter(styleItem => {\n                return styleItem.packageName !== packageName;\n            });\n            if (filteredCommands.length) { // if there are still some commands with the same name\n                this.commands_[commandName] = filteredCommands; // store the filtered command descriptions\n            } else { // if there are no the commands with the same name\n                delete this.commands_[commandName]; // delete the key-value pair\n            }\n        }\n        // for all the environment names\n        for (const environmentName in this.environments_)\n            if (this.environments_.hasOwnProperty(environmentName)) {\n                // the filtered environments with the same name\n                const filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(styleItem => {\n                    return styleItem.packageName !== packageName;\n                });\n                // if there are still some environments with the same name\n                if (filteredEnvironments.length) {\n                    // store the filtered environment descriptions\n                    this.environments_[environmentName] = filteredEnvironments;\n                } else { // if there are no the environments with the same name\n                    delete this.environments_[environmentName]; // delete the key-value pair\n                }\n            }\n    }\n\n\n    /**\n     * Get symbols\n     * @param {!State} state the state that the symbols must match to\n     * @param {string} patternFirstChar the first char of the symbol parameter pattern\n     * @return {!Array.<!Symbol>} the list of symbols in the priority descending order\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    symbols(state: State, patternFirstChar: string) {\n        if (!(state instanceof State))\n            throw new SyntaxError('\"state\" isn\\'t a State instance');\n        // all the symbols with the defined first pattern char\n        const symbols = this.symbols_[patternFirstChar];\n        if (symbols === undefined) return []; // return empty list if there are no such symbols\n        const filteredSymbols = []; // the list of the symbols matching to the state\n        for (let iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) { // for all the symbols\n            const symbol = symbols[iSymbol].symbol; // the symbol\n            // store the symbol if it matches to the state\n            //noinspection JSUnresolvedFunction\n            if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n        }\n        return filteredSymbols;\n    }\n\n\n    /**\n     * Get commands\n     * @param {!State} state the state that the commands must match to\n     * @param {!string} name the name of the command\n     * @return {Array.<Command>} the list of commands in the priority descending order\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    commands(state: State, name: string): Command[] {\n        if (!(state instanceof State))\n            throw new SyntaxError('\"state\" isn\\'t a State instance');\n        const commands = this.commands_[name]; // all the commands with the defined name\n        if (!commands) return []; // return empty list if there are no such commands\n        const filteredCommands = []; // the list of the commands matching to the state\n        for (let iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) { // for all the commands\n            const command = commands[iCommand].command; // the command\n            // store the command if it matches to the state\n            //noinspection JSUnresolvedFunction\n            if (state.test(command.modes)) filteredCommands.push(command);\n        }\n        return filteredCommands;\n    }\n\n\n    /**\n     * Get environments\n     * @param {!State} state the state that the environments must match to\n     * @param {!string} name the name of the environment\n     * @return {Array.<Environment>} the list of environments in the priority descending order\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    environments(state: State, name: string): EnvironmentAndPackage[] {\n        if (!(state instanceof State)) throw new SyntaxError(\"state isn't State instance\");\n        const environments: EnvironmentAndPackage[] = this.environments_[name]; // all the environments with the defined name\n        if (!environments) return []; // return empty list if there are no such environments\n\n        // store the environment if it matches to the state\n        return mustBeArray(environments)\n            .filter(env => state.test(env.modes));\n    }\n}\n\n\n/**\n * LaTeX style item properties\n * @interface ItemProperties\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme\n * @property {(!Object.<Mode, boolean>|undefined)} modes -\n *           The modes where the item is defined or not\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface ItemProperties {\n    lexeme?: Lexeme;\n    modes?: { [mode: string]: boolean };\n}\n\n\n/**\n * LaTeX style item encapsulation\n * @class\n * @property {(?Lexeme)} lexeme - The logical lexeme\n * @property {!Object.<Mode, boolean>} modes - The modes where the item is defined or not\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Item {\n    lexeme?: Lexeme;\n    modes: { [mode: string]: boolean };\n\n    /**\n     * Constructor.\n     * @param {!ItemProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: ItemProperties = {}) {\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break; // do nothing if no lexeme defined\n            default:\n                const lexeme = Lexeme[opt_initialProperties.lexeme]; // verify the lexeme\n                if (lexeme === undefined)\n                    throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, \"lexeme\", {value: lexeme});\n        }\n        if (opt_initialProperties.modes !== undefined) {// if the mode states are set\n            if (!(opt_initialProperties.modes instanceof Object))\n                throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, \"modes\", {value: {}}); // create the mode state storage\n            for (const modeKey in opt_initialProperties.modes) { // for all the given modes // TODO better loop\n                const mode: Mode = mustBeMode(modeKey); // verify the mode key\n                if (mode === undefined) // if the mode is unknown\n                    throw new TypeError(`\"initialProperties.modes[${modeKey}]\" isn't a Mode option`);\n                // store the mode state\n                //noinspection JSUnfilteredForInLoop\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n\n    /**\n     * Compare this item with the other one\n     * @param {?Item} other the item to compare with\n     * @return {boolean} true if the items are equal, false otherwise\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    equals(other: any) {\n        if (!(other instanceof Item)) return false;\n        return this.lexeme === other.lexeme &&\n            testProperties(this.modes, other.modes, modes, false);\n    }\n}\n\nObject.defineProperties(Item.prototype, { // default property values\n    lexeme: {value: undefined, enumerable: true}, // no lexeme by default\n    modes: {value: {}, enumerable: true} // no mode mask by default\n});\n\n\n/**\n * LaTeX symbol or command parameter properties\n * @interface ParameterProperties\n * @extends ItemProperties\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations -\n *           The LaTeX operations that are performed before the parameter\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface ParameterProperties extends ItemProperties {\n    operations?: (Operation | OperationProperties)[];\n}\n\nexport function isParameterProperties(ignored: any): ignored is ParameterProperties {\n    return true; // todo fields are all optional\n}\n\nexport function mustBeParameterProperties(x: any): ParameterProperties {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\n\n/**\n * LaTeX symbol or command parameter encapsulation\n * @class\n * @extends Item\n * @property {!Array.<!Operation>} operations -\n *           The LaTeX operations that are performed before this parameter\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Parameter extends Item {\n    //noinspection JSMismatchedCollectionQueryUpdate TODO\n    private operations_: Operation[];\n\n\n    /**\n     * Constructor\n     * @param {!ParameterProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: ParameterProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.operations !== undefined) { // if the operation list is set\n            if (!(opt_initialProperties.operations instanceof Array))\n                throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(this, \"operations_\", { // generate and store the operations list\n                value: opt_initialProperties.operations.map(operation => new Operation(operation))\n            });\n        }\n    }\n\n\n    /**\n     * Get the LaTeX operations that are performed before this parameter\n     * @return {!Array.<!Operation>} the operation list\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get operations(): Operation[] {\n        return this.operations_.slice();\n    }\n\n\n    /**\n     * Compare this parameter with the other one\n     * @param {?Parameter} other the parameter to compare with\n     * @return {boolean} true if the parameters are equal, false otherwise\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    equals(other: any) {\n        if (!(other instanceof Parameter)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n\n        if (this.operations_.length !== other.operations_.length) return false;\n        // test all the operations\n\n        return this.operations_.every((operation, iOperation) =>\n            operation.equals(other.operations_[iOperation]));\n    }\n}\n\nObject.defineProperties(Parameter.prototype, { // make getters and setters enumerable\n    operations: {enumerable: true}\n});\nObject.defineProperties(Parameter.prototype, { // default property values\n    operations_: {value: [], enumerable: false} // empty operation list by default\n});\n\n\n/**\n * LaTeX symbol properties\n * @interface SymbolProperties\n * @extends ItemProperties\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations - The LaTeX operations that\n * @property {(!Array.<!Parameter|!ParameterProperties>|undefined)} parameters - The parameters description list\n * @property {(string|undefined)} pattern - The LaTeX input pattern\n * @property {(string|undefined)} html - The HTML output pattern\n * are performed after the symbol\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface SymbolProperties extends ItemProperties {\n    operations?: (Operation | OperationProperties)[];\n    parameters?: (Parameter | ParameterProperties)[];\n    pattern?: string;\n    html?: string;\n}\n\nexport interface SymbolAndPackage {\n    symbol: Symbol;\n    packageName: string;\n}\n\n/**\n * LaTeX symbol encapsulation\n * @class\n * @extends Item\n * @property {!Array.<!Operation>} operations -\n *           The LaTeX operations that are performed after this symbol\n * @property {!Array.<!Parameter>} parameters - The parameters description list\n * @property {!Array.<undefined|string|number>} patternComponents - The LaTeX input pattern components\n * @property {string} pattern - The LaTeX input pattern\n * @property {string} html - The HTML output pattern\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Symbol extends Item {\n    //noinspection JSMismatchedCollectionQueryUpdate // TODO\n    private operations_: Operation[];\n    //noinspection JSMismatchedCollectionQueryUpdate // TODO\n    private parameters_: Parameter[];\n    //noinspection JSMismatchedCollectionQueryUpdate // TODO\n    private patternComponents_: (undefined | string | number)[];\n\n    html: string;\n\n\n    /**\n     * Constructor\n     * @param {!SymbolProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: SymbolProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.operations !== undefined) { // if the operation list is set\n            if (!(opt_initialProperties.operations instanceof Array))\n                throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(this, \"operations_\", { // generate and store the operations list\n                value: opt_initialProperties.operations.map(operation => new Operation(mustBeOperationProperties(operation)))\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) { // if the parameters list is set\n            if (!(opt_initialProperties.parameters instanceof Array))\n                throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            // generate and store the parameters list\n            this.parameters_ = opt_initialProperties.parameters.map(parameter => new Parameter(mustBeParameterProperties(parameter)));\n        }\n        if (opt_initialProperties.pattern !== undefined) { // if the LaTeX pattern is set\n            if (typeof opt_initialProperties.pattern !== \"string\")\n                throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            // try to parse the pattern\n            const patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) { // if there is a non-trivial pattern\n\n                // store the pattern components\n                this.patternComponents_ = patternComponents.map((patternPart: string): string | undefined | number => {\n                    switch (patternPart[0]) {\n                        case \" \":\n                        case \"\\t\": // if a space part\n                            return undefined; // undefined is a mark for spaces\n                        case \"#\": // if a parameter part\n                            const parameterIndex = Number(patternPart.substring(1)) - 1; // the index of a parameter\n                            if (!this.parameters_[parameterIndex])\n                                throw new TypeError(\n                                    '\"initialProperties.pattern\" contains the incorrect parameter number ' +\n                                    patternPart.substring(1)\n                                );\n                            return parameterIndex;\n                        default: // raw pattern part\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) { // if the LaTeX pattern is set\n            if (typeof opt_initialProperties.html !== \"string\")\n                throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            // store the pattern\n            Object.defineProperty(this, \"html\", {value: opt_initialProperties.html, enumerable: true});\n        }\n    }\n\n    /**\n     * Get the LaTeX operations that are performed after this symbol\n     * @return {!Array.<!Operation>} the operation list\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get operations(): Operation[] {\n        return this.operations_.slice();\n    }\n\n    /**\n     * Get the parameters description list\n     * @return {!Array.<!Latex.Parameter>} the parameter list\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get parameters(): Parameter[] {\n        return this.parameters_.slice();\n    }\n\n    /**\n     * Get the parameter description\n     * @param {number} parameterIndex the index of the parameter\n     * @return {?Latex.Parameter} the parameter or undefined if there is no parameter with such an index\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    parameter(parameterIndex: number): Parameter | undefined {\n        return this.parameters_[parameterIndex] || undefined;\n    }\n\n    /**\n     * Get the pattern components\n     * @return {!Array.<!Latex.Parameter>} the pattern component list\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get patternComponents(): any[] {\n        return mustNotBeUndefined(this.patternComponents_.slice());\n    }\n\n\n    /**\n     * Get the pattern\n     * @return {string} the LaTeX input pattern\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get pattern() {\n        return this.patternComponents_.map(patternComponent => {\n            if (isNumber(patternComponent)) {\n                return \"#\" + (patternComponent + 1);\n            }\n            switch (typeof patternComponent) {\n                case \"string\":\n                    return patternComponent;\n                default:\n                    return \" \";\n            }\n        }).join(\"\");\n    }\n\n    /**\n     * Compare this symbol with the other one\n     * @param {?Symbol} other the symbol to compare with\n     * @return {boolean} true if the symbols are equal, false otherwise\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    equals(other: any): boolean {\n        if (!(other instanceof Symbol)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n\n        if (this.operations_.length !== other.operations_.length) return false;\n        // test all the operations\n\n        if (!this.operations_.every((operation, iOperation) =>\n                operation.equals(other.operations_[iOperation])))\n            return false;\n\n        if (this.parameters_.length !== other.parameters_.length) return false;\n        // test all the parameters\n\n        if (!this.parameters_.every((parameter, iParameter) =>\n                parameter.equals(other.parameters_[iParameter])))\n            return false;\n        return this.html === other.html;\n    }\n}\n\nObject.defineProperties(Symbol.prototype, { // make getters and setters enumerable\n    operations: {enumerable: true},\n    parameters: {enumerable: true},\n    patternComponents: {enumerable: true},\n    pattern: {enumerable: true}\n});\n\nObject.defineProperties(Symbol.prototype, { // default property values\n    operations_: {value: [], enumerable: false, writable: true}, // empty operation list\n    parameters_: {value: [], enumerable: false, writable: true}, // empty parameter list\n    patternComponents_: {value: [], enumerable: false, writable: true}, // empty pattern\n    html: {value: \"\", enumerable: true, writable: true} // empty HTML pattern\n});\n\n\n/**\n * LaTeX command properties\n * @interface CommandProperties\n * @extends SymbolProperties\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface CommandProperties extends SymbolProperties {\n    name?: string;\n}\n\nexport interface CommandAndPackage {\n    command: Command;\n    packageName: string;\n}\n\n/**\n * LaTeX command encapsulation\n * @class\n * @extends Symbol\n * @property {string} name - The command name (a sequence of letters and optional star)\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Command extends Symbol {\n    name: string;\n\n\n    /**\n     * Constructor\n     * @param {!CommandProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: CommandProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.name !== undefined) { // if the name is set\n            if (typeof opt_initialProperties.name !== \"string\")\n                throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            // store the name\n            Object.defineProperty(this, \"name\", {value: opt_initialProperties.name});\n        }\n    }\n\n\n    /**\n     * Compare this command with the other one\n     * @param {?Command} other the command to compare with\n     * @return {boolean} true if the commands are equal, false otherwise\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    equals(other: any) {\n        if (!(other instanceof Command)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n        return this.name === other.name;\n    }\n}\n\nObject.defineProperties(Command.prototype, { // default property values\n    name: {value: \"\", enumerable: true} // empty name\n});\nexport function isCommand(c: any): c is Command {\n    return c instanceof Command;\n}\nexport function mustBeCommand(c: any): Command {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\n\n\n/**\n * LaTeX command properties\n * @interface EnvironmentProperties\n * @extends ItemProperties\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface EnvironmentProperties extends ItemProperties {\n    name?: string;\n}\n\nexport interface EnvironmentAndPackage {\n    environment: Environment;\n    packageName?: string;\n}\n\n/**\n * LaTeX environment encapsulation\n * @class\n * @extends Item\n * @property {string} name - The environment name (a sequence of letters and optional star)\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Environment extends Item {\n    name: string;\n\n\n    /**\n     * Constructor\n     * @param {!EnvironmentProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: EnvironmentProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.name !== undefined) { // if the name is set\n            if (typeof opt_initialProperties.name !== \"string\")\n                throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            // store the name\n            Object.defineProperty(this, \"name\", {value: opt_initialProperties.name});\n        }\n    }\n\n\n    /**\n     * Compare this environment with the other one\n     * @param {?Environment} other the environment to compare with\n     * @return {boolean} true if the environments are equal, false otherwise\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    equals(other: any) {\n        if (!(other instanceof Environment)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n        return this.name === other.name;\n    }\n}\n\nObject.defineProperties(Environment.prototype, { // default property values\n    name: {value: \"\", enumerable: true} // empty name\n});\n\nexport function isEnvironment(x: any): x is Environment {\n    return x instanceof Environment;\n}\n\n// export default LatexStyle;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle.ts","/**\n * @fileoverview LaTeX syntax tree structure elements\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n/** @module */\n\n/** @external LatexStyle*/\nimport {isCommand, Command, Environment, isEnvironment, mustBeCommand, Parameter, Symbol} from \"./LatexStyle\"; // LaTeX style structures\n/** @external SyntaxTree */\nimport {SyntaxTree, Node} from \"./SyntaxTree\";\nimport {Lexeme} from \"./Latex\";\nimport {mustNotBeUndefined} from \"./Utils\";\n\n\n/**\n * LaTeX syntax tree structure\n * @class\n * @extends SyntaxTree\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class LatexTree extends SyntaxTree {\n\n    /**\n     * Constructor\n     * @param {!Token} rootToken the root token (must have no parent and no tree)\n     * @param {string} source the sources text that has this syntax tree\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(rootToken: Token, source: string) {\n        if (!(rootToken instanceof Token))\n            throw new TypeError('\"rootToken\" isn\\'t a Token instance');\n        super(rootToken, source); // the superclass constructor\n    }\n}\n\n\n\n/**\n * LaTeX syntax tree token base properties\n * @interface TokenProperties\n * @property {(?Token|undefined)} parentToken - The parent token or undefined if there is no parent\n * @property {(!Array.<Token>|undefined)} childTokens - The list of the child tokens\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface TokenProperties {\n    parentToken?: Token;\n    childTokens?: Token[];\n}\n\n\n/**\n * LaTeX syntax tree token base structure\n * @class\n * @extends SyntaxTree.Node\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme of the token\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Token extends Node {\n    lexeme?: Lexeme;\n\n    /**\n     * Constructor\n     * @param {!TokenProperties=} opt_initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(opt_initialProperties: TokenProperties = {}) {\n        if (opt_initialProperties === undefined) { // if the initial properties are not set\n            super(); // superclass constructor\n        } else if (opt_initialProperties instanceof Object) { // if the initial properties are set\n            // superclass constructor\n            // superclass initial properties\n            const superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n            super(superInitialProperties);\n        } else { // if the initial properties are in unsupported type\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        return skipNodeClass ? super.toString(true) : \"Token{\" + super.toString(true) + \"}\";\n    }\n}\n\nObject.defineProperties(Token.prototype, { // default properties\n    lexeme: {value: undefined, enumerable: true}, // no lexeme\n    parentNodeClass_: {value: Token} // parent node must be an EnvironmentToken instance\n});\n\n\n/**\n * LaTeX symbol token properties\n * @interface SymbolTokenProperties\n * @extends TokenProperties\n * @property {!Symbol|undefined} symbol - The LaTeX symbol or undefined if the symbol is unrecognized\n * @property {string|undefined} pattern - The pattern that corresponds to the unrecognized symbol\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface SymbolTokenProperties extends TokenProperties {\n    symbol?: Symbol;\n    pattern?: string;\n}\n\n\n/**\n * LaTeX symbol token structure\n * @class\n * @extends Token\n * @property {?Symbol} symbol - The corresponding LaTeX symbol or undefined if the symbol is unrecognized\n * @property {string} pattern - The symbol LaTeX pattern\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class SymbolToken extends Token {\n    symbol?: Symbol;\n\n    /**\n     * Constructor\n     * @param {!SymbolTokenProperties} initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(initialProperties: SymbolTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (initialProperties.symbol) { // if the symbol is defined\n            if (!(initialProperties.symbol instanceof Symbol))\n                throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            // store the symbol\n            Object.defineProperty(this, \"symbol\", {value: initialProperties.symbol, enumerable: true});\n        } else { // if the symbol isn't defined\n            if (typeof initialProperties.pattern !== \"string\")\n                throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            // store the unrecognized pattern\n            Object.defineProperty(this, \"pattern\", {value: initialProperties.pattern});\n        }\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get lexeme(): Lexeme | undefined {\n\n        return this.symbol ? this.symbol.lexeme : undefined;\n    }\n\n\n    /**\n     * Get the symbol LaTeX pattern\n     * @return {string} the symbol pattern\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get pattern(): string {\n        return mustNotBeUndefined(this.symbol).pattern;\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        let source = \"\";\n        let iParameter = 0; // the parameter iterator\n\n        const pattern = this.pattern; // LaTeX input pattern\n        // for all the pattern chars\n        for (\n            let nPatternChars = pattern.length, iPatternChar = 0;\n            iPatternChar < nPatternChars;\n            ++iPatternChar\n        ) {\n            const patternChar = pattern[iPatternChar]; // the pattern char\n            if (patternChar === \"#\") { // if a parameter place\n                ++iPatternChar; // go to the next pattern char\n                const parameterToken = this.childNode(iParameter++); // try to get the parameter token\n                source += parameterToken ? parameterToken.toString(true) : \"??\";\n            } else { // if the ordinary pattern char\n                source += patternChar;\n            }\n        }\n        return skipNodeClass ?\n            source :\n            \"SymbolToken\" + (this.symbol ? \"\" : \"[?]\") + \"{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(SymbolToken.prototype, { // default properties\n    symbol: {value: undefined, enumerable: true} // no symbol token\n});\nObject.defineProperties(SymbolToken.prototype, { // make getters and setters enumerable\n    pattern: {enumerable: true}\n});\n\n\n/**\n * LaTeX parameter token properties\n * @interface ParameterTokenProperties\n * @extends TokenProperties\n * @property {boolean} hasBrackets - True if the parameter is bounded by the logical brackets, false otherwise\n * @property {boolean} hasSpacePrefix - True if the parameter is prefixed by a space, false otherwise\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface ParameterTokenProperties extends TokenProperties {\n    hasBrackets: boolean;\n    hasSpacePrefix: boolean;\n}\n\n\n/**\n * LaTeX parameter token structure\n * @class\n * @extends Token\n * @property {boolean} hasBrackets -\n *           True if the parameter is bounded by the logical brackets, false otherwise\n * @property {boolean} hasSpacePrefix -\n *           True if the parameter is prefixed by a space, false otherwise\n * @property {?LatexStyle.Parameter} parameter - The corresponding LaTeX parameter\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class ParameterToken extends Token {\n    public parentNode: SymbolToken;\n\n    private hasBrackets: boolean;\n    hasSpacePrefix: boolean;\n\n    /**\n     * Constructor\n     * @param {!ParameterTokenProperties} initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(initialProperties: ParameterTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (!initialProperties.hasBrackets) // if there are no bounding brackets\n        // store this fact\n            Object.defineProperty(this, \"hasBrackets\", {value: false, enumerable: true});\n        if (initialProperties.hasSpacePrefix) // if there is a space before\n        // store this fact\n            Object.defineProperty(this, \"hasSpacePrefix\", {value: true, enumerable: true});\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get lexeme(): Lexeme | undefined {\n        if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n    }\n\n\n    /**\n     * Get the corresponding LaTeX parameter description\n     * @return {?LatexStyle.Parameter}\n     *         the LaTeX parameter or undefined of there is parent symbol or such a parameter\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get parameter(): Parameter | undefined {\n        /** @type {?SymbolToken} */\n        const symbolToken = this.parentNode; // get the symbol token\n        const symbol = mustNotBeUndefined(symbolToken.symbol);\n        const parameterIndex = symbolToken.childIndex(this);\n        if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0)\n            return symbol.parameter(parameterIndex);\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        let source = this.hasSpacePrefix ? \" \" : \"\";\n        source += this.hasBrackets ? \"{\" + super.toString(true) + \"}\" : super.toString(true);\n        return skipNodeClass ? source : \"ParameterToken{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(ParameterToken.prototype, { // default properties\n    hasBrackets: {value: true, enumerable: true}, // there are bounding brackets\n    hasSpacePrefix: {value: false, enumerable: true}, // there is no space before\n    parentNodeClass_: {value: SymbolToken} // parent node must be a SymbolToken instance\n});\nObject.defineProperties(ParameterToken.prototype, { // make getters and setters enumerable\n    parameter: {enumerable: true}\n});\n\n\n/**\n * LaTeX command token properties\n * @interface CommandTokenProperties\n * @extends TokenProperties\n * @property {!LatexStyle.Command|undefined} command -\n *           The LaTeX command or undefined if the command is unrecognized\n * @property {string|undefined} name - The name that corresponds to the unrecognized command\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface CommandTokenProperties extends TokenProperties {\n    command?: Command;\n    name?: string;\n}\n\n\n/**\n * LaTeX command token structure\n * @class\n * @extends SymbolToken\n * @property {!LatexStyle.Command} command -\n *           The corresponding LaTeX command or undefined if the command is unrecognized\n * @property {string|undefined} name - The LaTeX command name\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class CommandToken extends SymbolToken {\n\n    /**\n     * Constructor\n     * @param {!CommandTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: CommandTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        // copy the initial properties for the superclass\n        const superInitialProperties = Object.create(initialProperties);\n        if (initialProperties.command) { // if the command is defined\n            if (!(initialProperties.command instanceof Command))\n                throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            // the command is the symbol for the superclass\n            superInitialProperties.symbol = initialProperties.command;\n            super(superInitialProperties); // the superclass constructor\n        } else { // if the command isn't defined\n            if (typeof initialProperties.name !== \"string\")\n                throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = \"\";\n            super(superInitialProperties); // the superclass constructor\n            // store the unrecognized name\n            Object.defineProperty(this, \"name\", {value: initialProperties.name});\n        }\n    }\n\n\n    /**\n     * Get the LaTeX command\n     * @return {!LatexStyle.Command} the command description\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get command(): Command {\n        return mustBeCommand(this.symbol);\n    }\n\n\n    /**\n     * Get the LaTeX command name\n     * @return {string} the command name\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get name(): string {\n        return this.command.name;\n    }\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        const source = \"\\\\\" + this.name + super.toString(true);\n        return skipNodeClass ?\n            source :\n            \"CommandToken\" + (isCommand(this.symbol) ? \"\" : \"[?]\") + \"{\" + source + \"}\";\n    }\n}\n\n\nObject.defineProperties(CommandToken.prototype, { // make getters and setters enumerable\n    command: {enumerable: true},\n    name: {enumerable: true}\n});\n\nexport function isCommandToken(x: any): x is CommandToken {\n    return x && x instanceof CommandToken;\n}\n\n\n/**\n * LaTeX environment token properties\n * @interface EnvironmentTokenProperties\n * @extends TokenProperties\n * @property {!LatexStyle.Environment} environment - The LaTeX environment\n * @property\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\n\nexport interface EnvironmentTokenPropertiesWithEnvironment\n    extends EnvironmentTokenProperties {\n    environment: Environment;\n    name: undefined;\n}\n\nexport interface EnvironmentTokenPropertiesWithName\n    extends EnvironmentTokenProperties {\n    environment: undefined;\n    name: string;\n}\n\nexport interface EnvironmentTokenProperties\n    extends TokenProperties {\n    environment?: Environment;\n    name?: string;\n}\n\n/**\n * LaTeX environment token structure\n * @class\n * @extends Token\n * @property {!Environment} environment - The corresponding LaTeX environment\n * @property {?CommandToken} beginCommandToken -\n *           The environment begin command token or undefined is there is no such a token\n * @property {?CommandToken} endCommandToken -\n *           The environment end command token or undefined is there is no such a token\n * @property {?EnvironmentBodyToken} bodyToken -\n *           The environment body token or undefined is there is no such a token\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class EnvironmentToken extends Token {\n    environment: Environment;\n\n    /**\n     * Constructor\n     * @param {!EnvironmentTokenProperties} initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(initialProperties: EnvironmentTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (!(initialProperties.environment instanceof Environment))\n            throw new TypeError(\n                '\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        // store the environment\n        Object.defineProperty(this, \"environment\", {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get lexeme() {\n        return this.environment.lexeme;\n    }\n\n\n    /**\n     * Get the begin command token\n     * @return {?CommandToken} the command token or undefined if there is no begin command\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get beginCommandToken() {\n        const beginCommandToken = this.childNode(0);\n        return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\n    }\n\n\n    /**\n     * Get the end command token\n     * @return {?CommandToken} the command token or undefined if there is no end command\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get endCommandToken() {\n        const endCommandToken = this.childNode(2);\n        return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\n    }\n\n\n    /**\n     * Get the environment body token\n     * @return {?EnvironmentBodyToken} the body or undefined if there is no body\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get bodyToken() {\n        const bodyToken = this.childNode(1);\n        return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        const beginCommandToken = this.beginCommandToken; // the begin command token\n        const endCommandToken = this.endCommandToken; // the end command token\n        const bodyToken = this.bodyToken; // the environment body token\n        let source = \"\\\\begin{\" + this.environment.name + \"}\";\n        source += beginCommandToken ?\n            SymbolToken.prototype.toString.call(beginCommandToken, true) :\n            \"??\";\n        source += bodyToken ? bodyToken.toString(true) : \"??\";\n        source += \"\\\\end{\" + this.environment.name + \"}\";\n        source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : \"??\";\n        return skipNodeClass ? source : \"EnvironmentToken{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(EnvironmentToken.prototype, { // make getters and setters enumerable\n    beginToken: {enumerable: true},\n    endToken: {enumerable: true}\n});\n\nexport function mustBeEnvironmentToken(x: any): EnvironmentToken {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\n\nexport function isEnvironmentToken(x: any): x is EnvironmentToken {\n    return x instanceof EnvironmentToken;\n}\n\n\nfunction getBeginCommandToken(x: any): CommandToken | undefined {\n    if (isCommandToken(x.beginCommandToken))\n        return x.beginCommandToken;\n}\n\nfunction getEndCommandToken(x: any): CommandToken | undefined {\n    if (isCommandToken(x.endCommandToken))\n        return x.endCommandToken;\n}\n\nfunction getEnvironment(x: any): Environment | undefined {\n    if (x.environment && isEnvironment(x.environment))\n        return x.environment;\n}\n\n/**\n * LaTeX environment body token structure\n * @class\n * @extends Token\n * @property {?LatexStyle.Environment} environment -\n *           The LaTeX environment or undefined if there is no parent environment\n * @property {?EnvironmentToken} environmentToken - The parent environment token\n * @property {?CommandToken} beginCommandToken -\n *           The environment begin command token or undefined is there is no such a token\n * @property {?CommandToken} endCommandToken -\n *           The environment end command token or undefined is there is no such a token\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class EnvironmentBodyToken extends Token {\n\n    /**\n     * Get the LaTeX environment\n     * @return {?LatexStyle.Environment} the environment or undefined if there is no parent environment\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get environment(): Environment | undefined {\n        return this.parentNode && getEnvironment(this.parentNode);\n    }\n\n\n    //noinspection JSUnusedGlobalSymbols\n    /**\n     * Get the parent environment token\n     * @return {?EnvironmentToken} the environment or undefined if there is no parent environment\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get environmentToken(): EnvironmentToken | undefined {\n        return this.parentNode && mustBeEnvironmentToken(this.parentNode);\n    }\n\n\n    /**\n     * Get the environment begin command token\n     * @return {?CommandToken} the command token or undefined if there is no begin command\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get beginCommandToken() {\n        return this.parentNode && getBeginCommandToken(this.parentNode);\n    }\n\n\n    /**\n     * Get the environment end command token\n     * @return {(CommandToken|undefined)} the command token or undefined if there is no end command\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get endCommandToken() {\n        return this.parentNode && getEndCommandToken(this.parentNode);\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        return skipNodeClass ?\n            super.toString(true) :\n            \"EnvironmentBodyToken{\" + super.toString(true) + \"}\";\n    }\n}\n\nObject.defineProperties(EnvironmentBodyToken.prototype, { // default properties\n    parentNodeClass_: {value: EnvironmentToken} // parent node must be an EnvironmentToken instance\n});\n\n\n/**\n * LaTeX space token properties\n * @interface SpaceTokenProperties\n * @extends TokenProperties\n * @property {number|undefined} lineBreakCount - The number of line breaks\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface SpaceTokenProperties\n    extends TokenProperties {\n    lineBreakCount?: number;\n}\n\n/**\n * LaTeX space token structure\n * @class\n * @extends Token\n * @property {number} lineBreakCount - The number of line breaks\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class SpaceToken extends Token {\n    lineBreakCount: number;\n\n\n    /**\n     * Constructor\n     * @param {!SpaceTokenProperties} initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(initialProperties: SpaceTokenProperties) {\n        if (initialProperties === undefined) {\n            super();\n            return;\n        }\n        else if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (initialProperties.lineBreakCount) { // if the line break number is defined\n            if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0)\n                throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\n            // store the line break number\n            Object.defineProperty(this, \"lineBreakCount\", {\n                value: initialProperties.lineBreakCount,\n                enumerable: true\n            });\n        }\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get lexeme(): Lexeme {\n        return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false): string {\n        if (skipNodeClass) { // if the node class name must be skipped\n            switch (this.lineBreakCount) {\n                case 0:\n                    return \" \";\n                case 1:\n                    return \"\\n\";\n                default:\n                    return \"\\n\\n\";\n            }\n        } else { // if the node class name must be included\n            switch (this.lineBreakCount) {\n                case 0:\n                    return \"SpaceToken{ }\";\n                case 1:\n                    return \"SpaceToken{\\n}\";\n                default:\n                    return \"SpaceToken{\\n\\n}\";\n            }\n        }\n    }\n}\n\n\nObject.defineProperties(SpaceToken.prototype, { // default properties\n    lineBreakCount: {value: 0, enumerable: true} // line break number\n});\n\n\n/**\n * LaTeX source fragment token properties\n * @interface SourceTokenProperties\n * @extends TokenProperties\n * @property {Lexeme} lexeme - The logical lexeme\n * @property {string} source - The source fragment\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface SourceTokenProperties\n    extends TokenProperties {\n    lexeme: Lexeme;\n    source: string;\n}\n\n/**\n * LaTeX source fragment token structure\n * @class\n * @extends Token\n * @property {string} source - The source fragment\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class SourceToken extends Token {\n    private source: string;\n\n    /**\n     * Constructor\n     * @param {!SourceTokenProperties} initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(initialProperties: SourceTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (!Lexeme[initialProperties.lexeme])\n            throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\n        // store the lexeme\n        Object.defineProperty(this, \"lexeme\", {value: initialProperties.lexeme, enumerable: true});\n        if (typeof initialProperties.source !== \"string\")\n            throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\n        // store the sources\n        Object.defineProperty(this, \"source\", {value: initialProperties.source, enumerable: true});\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false) {\n        return skipNodeClass ? this.source : \"SourceToken[\" + this.lexeme + \"]{\" + this.source + \"}\";\n    }\n}\n\n\nexport default SyntaxTree;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexTree.ts","/**\n * @fileoverview Syntax tree structure elements\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\nimport {isNumber} from \"./Utils\";\n\n\"use strict\";\n\n/**@module */\n\n\n/**\n * Syntax tree structure\n * @class\n * @property {!Node} rootNode - The root node\n * @property {string} source - The source text\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class SyntaxTree {\n    //noinspection JSUnusedGlobalSymbols // TODO\n    readonly rootNode: Node;\n    readonly source: string;\n\n\n    /**\n     * Constructor\n     * @param {!Node} rootNode the root node (must have no parent and no tree)\n     * @param {string} source the sources text that has this syntax tree\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(rootNode: Node, source: string) {\n        if (!(rootNode instanceof Node))\n            throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\n        if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n        if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n\n        if (typeof source !== \"string\")  throw new TypeError('\"sources\" isn\\'t a string');\n        // store the root node\n        Object.defineProperty(this, \"rootNode\", {value: rootNode, enumerable: true});\n        Object.defineProperty(this, \"source\", {value: source, enumerable: true}); // store the sources\n        // update the root node tree\n        Object.defineProperty(rootNode, \"tree\", {value: this, enumerable: true});\n    }\n}\n\n\n\n/**\n * Syntax tree node properties\n * @interface NodeProperties\n * @property {(?Node|undefined)} parentNode - The parent node or undefined if there is no parent\n * @property {(!Array.<Node>|undefined)} childNodes - The list of the child nodes\n * @exports\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport interface NodeProperties {\n    parentNode?: Node;\n    childNodes?: Node[];\n}\n\n\n/**\n * Syntax tree node structure\n * @class\n * @property {?SyntaxTree} tree - The tree or undefined if this node isn't in any tree\n * @property {?Node} parentNode - The parent node or undefined if there is no parent\n * @property {!Array.<Node>} childNodes - The child node list\n * @property {number} subtreeSize - The size of the subtree formed by this node\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class Node {\n    tree: SyntaxTree;\n    public parentNode: Node;\n    private subtreeSize: number;\n    private childNodes_: Node[];\n\n\n    /**\n     * Constructor\n     * @param {!NodeProperties=} opt_initialProperties the initial property values\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(opt_initialProperties?: NodeProperties) {\n        if (opt_initialProperties !== undefined) { // if the initial properties are defined\n            if (!(opt_initialProperties instanceof Object))\n                throw new TypeError(\"initialProperties isn't an Object instance\");\n            if (opt_initialProperties.childNodes !== undefined) { // if the child node list is set\n                if (!(opt_initialProperties.childNodes instanceof Array))\n                    throw new TypeError(\"initialProperties.childNodes isn't an Array instance\");\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n            }\n            const optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) { // if the parent node is set\n                if (!!optParentNode) {\n                    //noinspection JSUnresolvedFunction\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError(\"initialProperties.parentNode isn't a SyntaxTree.Node instance\");\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Get the child nodes\n     * @return {!Array.<Node>} the child node list\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    get childNodes(): Node[] {\n        return this.childNodes_.slice();\n    }\n\n\n    /**\n     * Get the child node\n     * @param {(!Node|number)} node the child node or its child index\n     * @return {?Node} the child node or undefined of there is no such a child node\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    childNode(node: Node | number): Node | undefined {\n        if (isNumber(node)) // if the node child index is given\n            return this.childNodes_[node] || undefined;\n        if (node instanceof Node) // if the child node is given\n            return node.parentNode === this ? node : undefined;\n        throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n    }\n\n\n    /**\n     * Get the child node index\n     * @param {(!Node|number)} node the child node or its child index\n     * @return {(number|undefined)} the child node or undefined of there is no such a child node\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    childIndex(node: Node | number): number | undefined {\n        if (isNumber(node)) // if the node child index is given\n            return this.childNodes_[node] ? node : undefined;\n        if (node instanceof Node) // if the child node is given\n            return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n        throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n    }\n\n\n    /**\n     * Insert a node to this child node list\n     * @param {!Node} node the node to insert (must have no parent and no child nodes)\n     * @param {number=undefined} childIndex\n     *        the position of the node for this child node list, the last by default\n     * @param {number=0} childNodesToCover\n     *        the number of this child nodes to become the child nodes of the new node\n     * @return {?Node} the inserted node or undefined if cannot insert\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    insertChildNode(node: Node, childIndex: number, childNodesToCover: number): Node {\n        if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n        if (node.parentNode) throw new TypeError('\"node\" has a parent');\n        if (node.tree) throw new TypeError('\"node\" is a tree root');\n\n        // TODO\n        // if (!(this instanceof node.parentNodeClass_))\n        //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\n\n        if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n        if (!this.hasOwnProperty(\"childNodes_\")) // if there was no child nodes\n        // init the property\n            Object.defineProperty(this, \"childNodes_\", {value: [], configurable: true});\n        // use the last position by default\n        if (childIndex === undefined) childIndex = this.childNodes_.length;\n        // do not cover any child nodes by default\n        if (childNodesToCover === undefined) childNodesToCover = 0;\n        // replace the child nodes by the new node\n        const nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n        // update the size of the subtree formed by this node\n        Object.defineProperty(this, \"subtreeSize\", {\n            value: this.subtreeSize + 1,\n            enumerable: true,\n            configurable: true\n        });\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            Object.defineProperty(parentNode, \"subtreeSize\", {value: parentNode.subtreeSize + 1});\n        }\n        // update the parent node of the new node\n        Object.defineProperty(node, \"parentNode\", {\n            value: this,\n            enumerable: true,\n            configurable: true\n        });\n        if (nodeChildNodes.length) { // if there are child nodes for the new node\n            // store the child nodes\n            Object.defineProperty(node, \"childNodes_\", {value: nodeChildNodes, configurable: true});\n            let subtreeSize = 1; // initiate the size of the subtree formed by the new node\n            // for all the child nodes of the new node\n            nodeChildNodes.forEach(nodeChildNode => {\n                subtreeSize += nodeChildNode.subtreeSize;\n            });\n            // store the subtree size\n            Object.defineProperty(node, \"subtreeSize\", {\n                value: subtreeSize,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        return node;\n    }\n\n\n    /**\n     * Insert a subtree to this child node list.\n     * @param {!Node} node the subtree to insert root node (must have no parent)\n     * @param {number=} childIndex\n     *        the position of the subtree root for this child node list, the last by default\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    insertChildSubtree(node: Node, childIndex?: number) {\n        if (!(node instanceof Node))\n            throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n        if (node.parentNode) throw new TypeError('\"node\" has a parent');\n        if (node.tree) throw new TypeError('\"node\" is a tree root');\n\n        // todo check\n        // if (!(this instanceof node.parentNodeClass_))\n        //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\n        // init child nodes property if not exists\n        if (!this.hasOwnProperty(\"childNodes_\")) // if there was no child nodes\n        // init the property\n            Object.defineProperty(this, \"childNodes_\", {value: [], configurable: true});\n        // use the last position by default\n        if (childIndex === undefined) childIndex = this.childNodes_.length;\n        this.childNodes_.splice(childIndex, 0, node); // insert the new node to the child list\n        const nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\n        // update the size of the subtree formed by this node\n        Object.defineProperty(this, \"subtreeSize\", {\n            value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n        });\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            Object.defineProperty(parentNode, \"subtreeSize\", {\n                value: parentNode.subtreeSize + nodeSubtreeSize\n            });\n        }\n        // update the parent node of the new node\n        Object.defineProperty(node, \"parentNode\", {\n            value: this,\n            enumerable: true,\n            configurable: true\n        });\n    }\n\n\n    /**\n     * Remove a child node of this node. All its child nodes become the child nodes of this node\n     * @param {(!Node|number)} nodeOrNodeIndex the subtree root or its child index\n     * @return {?Node} the removed node or undefined of there is no such a child node\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    removeChildNode(nodeOrNodeIndex: number | Node): Node | undefined {\n        const nodeChildIndex: number | undefined = this.childIndex(nodeOrNodeIndex); // the child index of the node\n        if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\n\n        const node: Node = this.childNodes_[nodeChildIndex]; // the child node to remove\n\n        // replace the node with its child nodes at this child node list\n        // todo could be more efficient?\n        this.childNodes_.splice(nodeChildIndex, 1, ...node.childNodes_);\n\n        if (this.childNodes_.length) { // if there are child nodes\n            // update this node subtree size\n            Object.defineProperty(this, \"subtreeSize\", {value: this.subtreeSize - 1});\n        } else { // if there are no child nodes\n            delete this.childNodes_; // this node has no child nodes anymore\n            delete this.subtreeSize; // this node has node subtree anymore\n        }\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            Object.defineProperty(parentNode, \"subtreeSize\", {value: parentNode.subtreeSize - 1});\n        }\n        delete node.parentNode; // the node has no parent node anymore\n\n        delete node.childNodes_; // the node has no child nodes anymore\n        delete node.subtreeSize; // the node has no subtree anymore\n        return node;\n    }\n\n\n    /**\n     * Remove a subtree formed by a child node of this node\n     * @param {(!Node|number)} node the subtree root or its child index\n     * @return {?Node} the removed subtree root node or undefined of there is no such a child node\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    removeChildSubtree(node: Node | number): Node | undefined {\n        const nodeChildIndex: number | undefined = this.childIndex(node); // the child index of the node\n        if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\n\n        node = this.childNodes_.splice(nodeChildIndex, 1)[0]; // remove the node from the child list\n        const nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\n        if (this.childNodes_.length) { // if there are child nodes\n            // update this node subtree size\n            Object.defineProperty(this, \"subtreeSize\", {value: this.subtreeSize - nodeSubtreeSize});\n        } else { // if there are no child nodes\n            delete this.childNodes_; // this node has no child nodes anymore\n            delete this.subtreeSize; // this node has node subtree anymore\n        }\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            Object.defineProperty(parentNode, \"subtreeSize\", {\n                value: parentNode.subtreeSize - nodeSubtreeSize\n            });\n        }\n        delete node.parentNode; // the node has no parent node anymore\n        return node;\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    toString(skipNodeClass = false): string {\n        let source = \"\"; // the sources\n        // for all the child nodes\n        this.childNodes_.forEach(childNode => {\n            source += childNode.toString(true);\n        });\n        return skipNodeClass ? source : \"SourceTree.Node{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(Node.prototype, { // make getters and setters enumerable\n    childNodes: {enumerable: true}\n});\nObject.defineProperties(Node.prototype, { // default property values\n    tree: {value: undefined, enumerable: true}, // no tree\n    parentNode: {value: undefined, enumerable: true}, // no parent node\n    subtreeSize: {value: 1, enumerable: true}, // only one node in the subtree\n    childNodes_: {value: [], enumerable: false}, // no child nodes\n    parentNodeClass_: {value: Node, enumerable: false} // parent node must be a Node instance\n});\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree.ts","/**\n * @fileoverview LaTeX parser class\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n/**@module */\n\n\nimport {LatexStyle, Symbol as SymbolItem, Command, Parameter, Environment, EnvironmentAndPackage} from \"./LatexStyle\";\nimport {\n    ParameterToken,\n    CommandToken,\n    SymbolToken,\n    Token,\n    SpaceToken,\n    EnvironmentToken,\n    EnvironmentBodyToken\n} from \"./LatexTree\";\nimport {Directive, GROUP, Lexeme, ModeStates, Operation, State} from \"./Latex\";\nimport {isNumber, isString, mustNotBeUndefined} from \"./Utils\";\n\n\n/**\n * Parse the next token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle the latex style\n * @return {?Token} the parsed token or undefined if the token cannot be parsed\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseToken_(context: Context, latexStyle: LatexStyle): Token | undefined {\n    let token: Token | undefined = parseSpaceToken_(context); // collect comments and try to parse a space token\n    if (!token) { // if cannot parse a space token\n        if (context.position >= context.source.length) return undefined;\n\n        const contextBackup = context.copy(); // backup the current context\n        if (!(token = parseEnvironmentToken_(context, latexStyle))) { // if cannot parse an environment token\n            contextBackup.copy(context); // restore the context\n            if (!(token = parseCommandToken_(context, latexStyle))) { // if cannot parse a command token\n                contextBackup.copy(context); // restore the context\n                if (!(token = parseSymbolsToken_(context, latexStyle))) { // if cannot parse a symbol token\n                    return undefined; // no token can be parsed\n                }\n            }\n        }\n    }\n    //noinspection JSCheckFunctionSignatures\n    processParsedToken_(context, token);\n    //noinspection JSValidateTypes\n    return token; // return the parsed token\n}\n\n\n/**\n * Parse a parameter token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle the latex style\n * @param {!LatexStyle.Parameter} parameter the symbol or command parameter description\n * @param {string=} opt_endLabel\n *        the parameter end label or undefined if there should be a single token\n * @return {?ParameterToken} the parsed parameter token or undefined if cannot parse\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseParameterToken_(context: Context, latexStyle: LatexStyle, parameter: Parameter, opt_endLabel?: string) {\n    const currentTokenBackup = context.currentToken; // store the current token\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n    context.updateState(parameter.operations); // update the LaTeX state\n    if (opt_endLabel === undefined) { // if the parameter must be parsed as a single token\n        // has the param space prefix or not\n        const spacePrefixState = parseSpaceToken_(context) !== undefined;\n        if (context.source[context.position] === \"{\") { // if the parameter is bounded by brackets\n            // create the parameter token\n            context.currentToken =\n                new ParameterToken({hasBrackets: true, hasSpacePrefix: spacePrefixState});\n            ++context.position; // go to the sources next char\n            ++context.charNumber; // go to the current line next char\n            // exit if cannot parse until the closing bracket\n\n            if (!parseUntilLabel_(context, latexStyle, \"}\", parameter.lexeme)) return undefined;\n            ++context.position; // skip the bracket in the sources\n            ++context.charNumber; // skip the bracket in the current line\n        } else { // if the parameter is't bounded by brackets\n            // create the parameter token\n            context.currentToken =\n                new ParameterToken({hasBrackets: false, hasSpacePrefix: spacePrefixState});\n            // exit if cannot parse a parameter token\n            if (parseToken_(context, latexStyle) === undefined) return undefined;\n        }\n    } else { // if the parameter must be parsed until the end label\n        // create the parameter token\n        context.currentToken =\n            new ParameterToken({hasBrackets: false, hasSpacePrefix: false});\n\n        // return if cannot parse\n        if (!parseUntilLabel_(context, latexStyle, opt_endLabel, parameter.lexeme)) return undefined;\n    }\n    const parameterToken = context.currentToken; // the parsed parameter token\n    context.currentToken = currentTokenBackup; // restore the current token\n    //noinspection JSCheckFunctionSignatures\n    processParsedToken_(context, parameterToken);\n    //noinspection JSValidateTypes\n    return parameterToken;\n}\n\n\n/**\n * Parse an environment token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @return {?EnvironmentToken} the parsed token or undefined if cannot parse\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseEnvironmentToken_(context: Context, latexStyle: LatexStyle): EnvironmentToken | undefined {\n    if (context.source.substring(context.position).indexOf(\"\\\\begin\") !== 0) return undefined;\n    context.position += 6; // just after \"\\begin\"\n    parseSpaceToken_(context); // skip spaces\n    // try to obtain the environment name\n    const nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n    if (!nameMatch) return undefined; // exit if cannot bet the environment name\n    const name = nameMatch[1]; // the environment name\n    context.position += nameMatch[0].length; // skip the environment name in the sources\n    context.charNumber += nameMatch[0].length; // skip the environment name in the current line\n    const currentTokenBackup = context.currentToken; // store the current token\n    // try to get the corresponding environment\n    const environment: Environment | EnvironmentAndPackage = latexStyle.environments(context.currentState, name)[0];\n    const environmentToken = context.currentToken = environment ? // the environment token\n        new EnvironmentToken({environment: environment.environment}) :\n        new EnvironmentToken({name: name});\n    // TODO unknown environment notification\n    // try to parse the environment begin command\n    const symbols: Command[] = latexStyle.commands(context.currentState, name);\n    let beginCommandToken: Token | undefined = parsePatterns_(context, latexStyle, symbols);\n    if (beginCommandToken === undefined) { // if cannot parse a command\n        // TODO notification about the unrecognized command\n        // generate unrecognized command token\n        beginCommandToken = new CommandToken({name: name});\n    }\n    //noinspection JSCheckFunctionSignatures\n    processParsedToken_(context, beginCommandToken);\n    const environmentBodyToken = context.currentToken = new EnvironmentBodyToken();\n    const endFound = parseUntilLabel_(context, latexStyle, `\\\\end\\{${name}}`); // try to get to the end\n    context.currentToken = environmentToken;\n    processParsedToken_(context, environmentBodyToken); // process the body token\n    let endCommandToken: Token | undefined = undefined; // the environment end command token\n    if (endFound) { // if the environment end was reached\n        context.position += name.length + 6; // skip the environment name in the sources\n        context.charNumber += name.length + 6; // skip the environment name in the current line\n        endCommandToken = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, `end${name}`));\n    } else { // if cannot find the end of the environment\n        // TODO no environment end notification\n    }\n    if (endCommandToken === undefined) { // if cannot parse a command\n        // TODO notification about the unrecognized command\n        // generate unrecognized command token\n        endCommandToken = new CommandToken({name: \"end\" + name});\n    }\n    processParsedToken_(context, endCommandToken); // process the end command token\n    context.currentToken = currentTokenBackup; // restore the current token\n    return environmentToken;\n}\n\n\n/**\n * Parse a command token.\n *\n * By the rules of TeX syntax, the \"name\" of a macro that starts with a \\ (backslash) character must either\n * - consist of a single non-alphabetical character.\n *   Some examples:\n *     \\, (insert thin space),\n *     \\% ( the % character),\n *     \\\\ (insert line break),\n *     \\[ (open display math), and\n *     \\) (close inline math).\n * or\n * - contain only uppercase and lowercase alphabetical characters: a-z and A-Z. No numerals, and no other characters\n *   belonging to non-letter categories either. (Well, there are certain ways of assigning \"letter-category\" status to\n *   non-letter characters, but that's a topic for a different discussion.)\n *   (https://tex.stackexchange.com/questions/66666/command-macro-name-cannot-include-numbers-and-symbols/66695#66695)\n *\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @return {?CommandToken} the parsed token or undefined if cannot parse\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n * @author Maarten Trompper <maartentrompper@freedom.nl>\n *\n */\nfunction parseCommandToken_(context: Context, latexStyle: LatexStyle): Token | undefined {\n    // try to find a command name\n    // TODO [a-zA-Z] instead of [\\w]?\n    const cmdMatch = context.source.substring(context.position).match(/^\\\\((?:[\\w@]+\\*?)|(?:[^\\w]))/);\n\n    if (!cmdMatch)\n        return undefined; // exit if cannot find a command name\n\n    context.position += cmdMatch[0].length; // set position just after the command name\n    context.charNumber += cmdMatch[0].length; // skip all the command name chars\n\n    // try to parse a command token\n\n    let token: Token | undefined = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, cmdMatch[1]));\n    if (token === undefined) { // if cannot parse a command token\n        // TODO notification about the unrecognized command\n        // generate unrecognized command token\n        token = new CommandToken({name: cmdMatch[1]});\n    }\n    //noinspection JSValidateTypes\n    return token;\n}\n\n\n/**\n * Parse symbols for a token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @return {?Token} the parsed token or undefined if cannot parse\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseSymbolsToken_(context: Context, latexStyle: LatexStyle): Token | undefined {\n    // get the available symbols\n    const sourceCharacter = context.source[context.position]; // the current sources character\n\n    // get the symbols started with the current sources character\n    let token = parsePatterns_(context, latexStyle, latexStyle.symbols(context.currentState, sourceCharacter));\n\n    if (token === undefined) { // if cannot parse a symbol token\n        // TODO notification about the unrecognized symbol\n        ++context.position; // go to the next sources character\n\n        // go to the next line character (the line is the same, \\n was parsed for a space token)\n        ++context.charNumber;\n\n        // generate unrecognized symbol token\n        token = new SymbolToken({pattern: sourceCharacter});\n    } else { // if the token was parsed\n        // TODO parse words and numbers\n    }\n    return token;\n}\n\n\n/**\n * Try to parse a symbol pattern\n * @param {!Context} context the parsing context// generate unrecognized symbol token\n * @param {!LatexStyle} latexStyle the latex style\n * @param {!Array.<!LatexStyle.Symbol>} symbols the symbol or command descriptions in the priority descending order\n * @return {?Token} the parsed symbol or command token or undefined if cannot parse\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parsePatterns_(context: Context, latexStyle: LatexStyle, symbols: SymbolItem[]): Token | undefined {\n    const contextBackup = context.copy(); // backup the current context\n    let token: Token | undefined = undefined; // the parsed token\n\n    // TODO not how some() is meant to be used...?\n    symbols.some(symbol => { // for all the symbols until the parsing success\n        // stop if the token was parsed\n        if (token = parsePattern_(context, latexStyle, symbol)) {\n            return true;\n        } else {\n            contextBackup.copy(context); // restore the context\n            return false; // go to the next symbol\n        }\n    });\n    return token;\n}\n\n\n/**\n * Try to parse a symbol pattern\n * @param {!Context} context the parsing context\n * @param {!LatexStyle>} latexStyle latex style\n * @param {!Array.<!LatexStyle.Symbol>} symbol the symbol or command description\n * @return {?Token} the parsed symbol or command token or undefined if cannot parse\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parsePattern_(context: Context, latexStyle: LatexStyle, symbol: SymbolItem): Token | undefined {\n    const currentTokenBackup = context.currentToken; // store the current token\n    // if a command description is given\n    context.currentToken = symbol instanceof Command ?\n        new CommandToken({command: symbol}) : // generate a command token\n        new SymbolToken({symbol: symbol}); // generate a symbol token\n\n    const patternComponents = symbol.patternComponents; // the symbol pattern components\n    const nPatternComponents = patternComponents.length; // the pattern componen number\n    let iPatternComponent = 0; // the pattern component iterator\n    // for all the pattern components\n    for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n        const patternComponent = patternComponents[iPatternComponent]; // the pattern component\n        if (isNumber(patternComponent)) { // if a parameter is expected\n            const parameter: Parameter | undefined = symbol.parameter(patternComponent); // the parameter description\n            // try to get the end label for the parameter\n            const parameterEndLabel = patternComponents[iPatternComponent + 1];\n            if (typeof parameterEndLabel === \"string\") { // if there is a end label\n                // if can parse the parameter token\n                if (parseParameterToken_(context, latexStyle, mustNotBeUndefined(parameter), parameterEndLabel)) {\n                    // exit if there is no the end label at the positions\n                    if (context.source.substring(context.position).indexOf(parameterEndLabel) !== 0) return undefined;\n                    context.position += parameterEndLabel.length; // skip the end label in the sources\n                    context.charNumber += parameterEndLabel.length; // skip the end label in the line\n                    ++iPatternComponent; // skip the end label in the pattern\n                    continue; // go to the next pattern component\n                }\n            } else { // if there is no a end label\n                // go to the next pattern char if can parse the parameter token\n                if (parseParameterToken_(context, latexStyle, mustNotBeUndefined(parameter))) continue;\n            }\n        }\n        else if (isString(patternComponent)) {\n            while (parseCommentLine_(context)) {\n            } // skip all the comments\n            // if the sources fragment is equal the pattern component\n            if (context.source.substring(context.position).indexOf(patternComponent) === 0) {\n                context.position += patternComponent.length; // skip the pattern component in the sources\n                context.charNumber += patternComponent.length; // skip the pattern component in the line\n                continue; // go to the next pattern component\n            }\n        } else if (parseSpaceToken_(context))\n            continue;\n        break; // stop parsing if there was no continue call\n    }\n    // return if the pattern parsing was broken\n    if (iPatternComponent < nPatternComponents) return undefined;\n    const parsedToken = context.currentToken; // the parsed token to return\n    context.currentToken = currentTokenBackup; // restore the current token\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n    context.updateState(symbol.operations); // update the LaTeX state\n    return parsedToken;\n}\n\n\n/**\n * Parse tokens until the label\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @param {string} endLabel the label to parse until\n * @param {Latex.Lexeme=} opt_lexeme the lexeme of the single token to parse\n * @return {boolean} true if the parsing was successful, false otherwise\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseUntilLabel_(context: Context, latexStyle: LatexStyle, endLabel: string, opt_lexeme?: Lexeme) {\n    switch (opt_lexeme) {\n        // TODO parse special lexemes\n        default: {\n            // while not reached the label\n            while (context.source.substring(context.position).indexOf(endLabel) !== 0) {\n                if (context.position >= context.source.length) { // if there is no more sources\n                    // TODO notification about unexpected sources end\n                    return false;\n                }\n                parseToken_(context, latexStyle);\n            }\n            return true;\n        }\n    }\n}\n\n/**\n * Parse a comment line\n * @param {!Context} context the parsing context\n * @return {boolean} true if there was a comment line, false otherwise\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseCommentLine_(context: Context): boolean {\n    // try to find a comment int the sources tail\n    const commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false; // return if there is no comment at this position\n\n    context.comments.push(commentMatch[1]); // store the comment string\n    context.position += commentMatch[0].length; // position just after the comment\n    if (!commentMatch[2]) { // if there were no line breaks\n        context.charNumber += commentMatch[0].length; // go to the last char\n    } else { // if there was a line break\n        ++context.lineNumber; // one more line\n        context.charNumber = commentMatch[2].length - 1; // skip all the space chars in the new line\n    }\n    return true;\n}\n\n\n/**\n * Fill the parsed token position, comments and parent\n * @param {!Context} context the parsing context\n * @param {!Token} token the token to process\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction processParsedToken_(context: Context, token: Token) {\n    // TODO process comments and position\n    if (context.currentToken) { // if there is a current token\n\n        // console.log(context.currentToken.toString())\n\n        //noinspection JSUnresolvedFunction\n        context.currentToken.insertChildSubtree(token); // store this token as a child of the current\n    }\n}\n\n/**\n * Parse space for a token (space or paragraph separator)\n * @param {!Context} context the parsing context\n * @return {?SpaceToken} the parsed token or undefined if cannot parse a space token\n * @private\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nfunction parseSpaceToken_(context: Context): SpaceToken | undefined {\n    let isSpace = false; // true is the sources fragment is a space token, false otherwise\n    let nLineBreaks = 0; // number of parsed line breaks\n    while (context.position < context.source.length) { // while there is something to parse\n        // go to the next iteration if there was a comment\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) { // depend on the sources current character\n            case \" \":\n            case \"\\t\": // if a space or a tabular\n                isSpace = true; // and one more parsed char\n                ++context.position; // go to the next sources char\n                ++context.charNumber; // the next char of the sources line\n                continue;\n            case \"\\n\": // if a line break\n                isSpace = true; // and one more parsed char\n                ++nLineBreaks; // one more parsed line\n                ++context.position; // go to the next sources char\n                ++context.lineNumber; // the next sources line\n                context.charNumber = 0; // the first char of the line\n                continue; // go to the next iteration\n        }\n        break; // stop if not a space char\n    }\n    // create a space token if needed\n    return isSpace ? new SpaceToken({lineBreakCount: nLineBreaks}) : undefined;\n}\n\n/**\n * LaTeX parser structure\n * @class\n * @property {!LatexStyle} latexStyle latexStyle - The LaTeX style description to be used for parsing\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n */\nexport class LatexParser {\n    latexStyle: LatexStyle;\n\n    /**\n     * Constructor\n     * @param {!LatexStyle} latexStyle latexStyle LaTeX style description to be used for parsing\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    constructor(latexStyle: LatexStyle) {\n        if (!(latexStyle instanceof LatexStyle))\n            throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\n        // store the style description\n        Object.defineProperty(this, \"latexStyle\", {value: latexStyle, enumerable: true});\n    }\n\n\n    /**\n     * Parse LaTeX sources\n     * @param {string} source the sources to parse\n     * @param {(!Context|undefined)} opt_context the parsing context\n     * @return {!Array.<!Token>} the list of the parsed tokens\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    parse(source: string, opt_context?: Context): Token[] {\n        if (typeof source !== \"string\") throw new TypeError(`\"sources\" isn't a string`);\n        let context;\n\n        if (opt_context === undefined) { // if the parsing context isn't defined\n            context = new Context(source); // create the context\n        } else if (opt_context instanceof Context) { // if the parsing context is defined\n            context = opt_context;\n            context.source += source; // update the sources\n        } else { // if unexpected context type\n            throw new TypeError(`\"context\" isn't a LatexParser.Context instance`);\n        }\n\n        const parsedTokens: Token[] = []; // the list of the parsed tokens\n\n        // store the parsed token, stop when cannot parse a token\n        let parsedToken: Token | undefined;\n        while (parsedToken = parseToken_(context, this.latexStyle))\n            parsedTokens.push(parsedToken);\n\n        return parsedTokens;\n    }\n}\n\n\n/**\n * The parsing context\n * @struct\n * @property {string} source - The source to parse\n * @property {number} position - The current position in the source\n * @property {?Token} currentToken - The currently parsing token\n * @property {!Latex.State} currentState - The current LaTeX state\n * @property {!Array.<!Latex.State>} stateStack - The stack of LaTeX sates\n * @property {!Array.<string>} comments - The comment list for the nex token\n * @property {number} lineNumber - The current line number\n * @property {number} charNumber - The current char number in the current line\n * @property {function} copy\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\n */\nexport class Context {\n    source: string;\n    position: number;\n    currentToken?: Token;\n    currentState: State;\n    stateStack: State[];\n    comments: string[];\n    lineNumber: number;\n    charNumber: number;\n\n\n    /**\n     * Constructor\n     * @param {string=} opt_source the sources to parse (empty string by default)\n     */\n    constructor(opt_source = \"\") {\n        this.source = opt_source; // store the sources\n        this.position = 0; // start from the beginning\n        this.lineNumber = 0; // start from the line 0\n        this.charNumber = 0; // start from the char 0\n        this.currentToken = undefined; // no tokens were parsed\n        this.currentState = new State(); // initial LaTeX state\n        this.stateStack = []; // no stored states\n        this.comments = []; // no comments for the next token\n    }\n\n\n    /**\n     * Copy this context\n     * @param {!Context=} opt_target the context to copy to or undefined to create a new one\n     * @return {!Context} the context copy\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    copy(opt_target?: Context): Context {\n        const target = opt_target || new Context(); // the context to copy this context in\n        target.source = this.source;\n        target.position = this.position;\n        target.lineNumber = this.lineNumber;\n        target.charNumber = this.charNumber;\n        target.currentToken = this.currentToken;\n        target.currentState = this.currentState.copy();\n        target.stateStack = this.stateStack.slice();\n        target.comments = this.comments.slice();\n        return target;\n    }\n\n\n    /**\n     * Update the LaTeX state\n     * @param {!Array.<!Latex.Operation>} operations the LaTeX operation list\n     * @author Kirill Chuvilin <k.chuvilin@texnous.org>\n     */\n    updateState(operations: Operation[]) {\n        if (!(operations instanceof Array))\n            throw new TypeError('\"operations\" isn\\'t an Array instance');\n        let newModeStates: ModeStates = {}; // the modes to update\n        operations.forEach((operation: Operation) => {\n\n            switch (operation.directive) {\n                case Directive.BEGIN:\n\n                    switch (operation.operand) {\n                        case GROUP:\n                            this.currentState.update(newModeStates); // store the mode states\n                            newModeStates = {}; // no more states to update\n                            this.stateStack.push(this.currentState.copy()); // store the current state\n                            break;\n                        default:\n\n                            newModeStates[operation.operand] = true; // turn the state on\n                    }\n                    break;\n                case Directive.END:\n\n                    switch (operation.operand) {\n                        case GROUP:\n                            newModeStates = {}; // no need to store the states\n                            if (this.stateStack.length < 1) throw new Error(\"state stack is empty\");\n                            this.currentState = mustNotBeUndefined(this.stateStack.pop()); // restore the current state\n                            break;\n                        default:\n\n                            newModeStates[operation.operand] = false; // turn the state off\n                    }\n                    break;\n            }\n        });\n        this.currentState.update(newModeStates); // store the mode states\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexParser.ts","/**\n * @fileoverview Export file for LaTeX parser utilities.\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\nexport * from \"./lib/Utils\"; // general JavaScript utils\nexport * from \"./lib/Latex\"; // general LaTeX definitions\nexport * from \"./lib/LatexStyle\"; // LaTeX style structures\nexport * from \"./lib/SyntaxTree\"; // syntax tree structure elements\nexport * from \"./lib/LatexTree\"; // LaTeX syntax tree structure elements\nexport * from \"./lib/LatexParser\"; // LaTeX parser class\n\n\n// WEBPACK FOOTER //\n// ./sources/main.ts"],"sourceRoot":""}