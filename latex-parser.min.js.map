{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///latex-parser.min.js","webpack:///webpack/bootstrap 50496e019f194f1dd15e","webpack:///./src/Utils.ts","webpack:///./src/Text/LaTeX/Base/Syntax.ts","webpack:///./src/main.ts","webpack:///./src/Text/TeX/CategoryCode.ts","webpack:///./src/Text/LaTeX/Base/Parser.ts","webpack:///./node_modules/parsimmon/build/parsimmon.umd.min.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","updateProperties","target","values","opt_keys","opt_attributes","arguments","length","undefined","writable","TypeError","key","create","value","Array","forEach","targetKey","_key","testProperties","opt_skipUndefined","every","_key2","isNumber","x","isString","mustNotBeUndefined","msg","Error","mustBeObject","mustBeString","mustBeArray","a","isArray","constructor","concatMap","arr","f","concat","apply","map","mustBeNumber","mconcat","mappend","_len","args","_key3","reduceRight","snd","pair","isMeasure","isBuiltInMeasure","isCustomMeasure","isMeasureType","measureTypes","type","_Utils","isLaTeXBlock","expression","isMathType","isNameHaving","isTextHaving","text","isLaTeXHaving","latex","isArgumentHaving","isSubOrSuperSymbol","SubOrSuperSymbol","SUP","SUB","protectChar","isTypeHaving","anyOfTypes","some","isLaTeXRaw","isLaTeXNoRaw","isTeXEmpty","isTeXChar","isTeXComm","isTeXEnv","isTeXMath","isTeXLineBreak","isTeXBraces","isTeXComment","isTeXRaw","typeTeXRaw","string","category","typeTeXComm","typeTeXCommS","isTeXCommS","typeTeXEnv","noNewPage","measure","isSubOrSuperScript","typeTeXBraces","isFixArg","isOptArg","typeTeXComment","e","keys","newFixArg","newOptArg","newSymArg","newParArg","newMOptArg","newMSymArg","newMParArg","newCommandS","newTeXRaw","characterCategories","_CategoryCode","convertToTeXCharsDefault","newTeXMath","startSymbol","endSymbol","newTeXBraces","newTeXComment","newTeXComm","_len2","newSubOrSuperScript","symbol","newTeXEnv","_len3","stringifyLaTeX","tex","stringifyLaTeXInner","join","soFar","push","t","arg","JSON","stringify","newTeXMathDol","protectString","fromStringLaTeX","typeTeXSeq","mathTypes","pt","mm","cm","in","ex","em","Parentheses","Square","Dollar","newString","charAt","_Syntax","_Parser","str","convertToTeXChars","defaultCategories","categoryMap","chars","char","_toConsumableArray","arr2","from","unsafeUnion","xs","ys","xn","yn","obj","j","k","sort","mergeReplies","result","last","furthest","expected","status","index","manyTillAndMap","manyOf","till","initial","_parsimmon","Parser","input","accum","endCodonFound","_","bigParse","isNotOk","mustBeOk","makeSuccess","manyTill","el","takeAtLeastOneTill","firstChar","makeFailure","strz","textParser","notText","isNotText","match","isSpecialCharacter","specialChars","specialCharsDefault","latexBlockParser","mode","sub","sup","latexBlockParserMathMode","latexBlockParserTextMode","isUppercaseAlph","isLowercaseAlph","fixArg","openingBrace","then","closingBrace","optArg","openingBracket","closingBracket","cmdArg","alt","cmdArgs","atLeast","command","seqMap","commandSymbol","specialChar","takeTill","endCmd","ignored","argz","res","shiftedScript","subOrSuperscriptSymbolParser","isOk","parse","dolMath","environment","env","latexParser","mathSymbol","comment","notTextDefaultAndNotClosingBracket","notTextMathModeAndNotClosingBracket","notTextMathMode","notTextDefault","defaultParserConf","verbatimEnvironments","predicate","takeWhile","takeTillNewline","regexp","maybeNewline","commentSymbol","$","%","\\","{","]","}","^","spaces","skip","'","(",")",",",".","-","\"","!","&","#","~","|","/",":",";","=","[","`"," ","lazy","anonym","many","beginFound","envName","test","subscriptSymbol","superscriptSymbol","parsedStr","mathType","sMath","eMath","r","u","default","toString","slice","split","offset","line","column","h","RegExp","w","v","g","y","lastIndexOf","E","source","b","O","pop","G","F","P","q","or","z","chain","A","B","exec","M","R","L","S","indexOf","W","I","C","desc","D","H","J","T","tryParse","trim","wrap","thru","tie","times","atMost","mark","K","start","end","node","sepBy","sepBy1","lookahead","notFollowedBy","fallback","ap","empty","of","N","Q","U","V","X","Y","Z","all","any","createLanguage","custom","digit","digits","eof","fail","formatError","isParser","letter","letters","noneOf","oneOf","optWhitespace","range","regex","seq","seqObj","succeed","whitespace"],"mappings":"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","file":"latex-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.updateProperties = updateProperties;\nexports.testProperties = testProperties;\nexports.isNumber = isNumber;\nexports.isString = isString;\nexports.mustNotBeUndefined = mustNotBeUndefined;\nexports.mustBeObject = mustBeObject;\nexports.mustBeString = mustBeString;\nexports.mustBeArray = mustBeArray;\nexports.isArray = isArray;\nexports.concatMap = concatMap;\nfunction updateProperties(target, values, opt_keys) {\n    var opt_attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        writable: true,\n        enumerable: true,\n        configurable: true\n    };\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = { writable: true, enumerable: true, configurable: true };\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        }\n    } else if (opt_keys instanceof Array) {\n        opt_keys.forEach(function (key) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key = opt_keys[targetKey];\n            if (values[_key] !== undefined) Object.defineProperty(target, targetKey, Object.create(opt_attributes, { value: { value: values[_key] } }));\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\nfunction testProperties(target, values, opt_keys) {\n    var opt_skipUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true;\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined)) return false;\n        }\n    } else if (opt_keys instanceof Array) {\n        return opt_keys.every(function (key) {\n            return target[key] === values[key] || values[key] === undefined && opt_skipUndefined;\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key2 = opt_keys[targetKey];\n            if (target[targetKey] !== values[_key2] && !(values[_key2] === undefined && opt_skipUndefined)) return false;\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true;\n}\nvar mustBeNumber = exports.mustBeNumber = function mustBeNumber(a, msg) {\n    if (!isNumber(a)) throw new TypeError(msg ? msg : \"Expected number\");\n    return a;\n};\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction mustNotBeUndefined(x, msg) {\n    if (!x) throw new Error(msg);\n    return x;\n}\nfunction mustBeObject(o, msg) {\n    if (!(o instanceof Object)) throw new TypeError(msg ? msg : \"Expected Object\");\n    return o;\n}\nfunction mustBeString(o, msg) {\n    if (typeof o !== \"string\") throw new TypeError(msg ? msg : \"Expected string\");\n    return o;\n}\nfunction mustBeArray(a, msg) {\n    if (!isArray(a)) throw new TypeError(msg ? msg : \"Expected Array\");\n    return a;\n}\nfunction isArray(x) {\n    return !!x && x.constructor === Array;\n}\nvar mconcat = exports.mconcat = function mconcat(mappend) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n    }\n\n    return args.reduceRight(mappend);\n};\nvar snd = exports.snd = function snd(pair) {\n    return pair[1];\n};\nfunction concatMap(arr, f) {\n    return [].concat.apply([], arr.map(f));\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.newTeXMathDol = exports.protectString = exports.fromStringLaTeX = exports.SubOrSuperSymbol = exports.typeTeXCommS = exports.typeTeXComm = exports.typeTeXRaw = exports.typeTeXComment = exports.typeTeXBraces = exports.typeTeXEnv = exports.typeTeXSeq = exports.mathTypes = exports.measureTypes = undefined;\nexports.isMeasure = isMeasure;\nexports.isMeasureType = isMeasureType;\nexports.isBuiltInMeasure = isBuiltInMeasure;\nexports.isCustomMeasure = isCustomMeasure;\nexports.isMathType = isMathType;\nexports.isNameHaving = isNameHaving;\nexports.isTextHaving = isTextHaving;\nexports.isLaTeXHaving = isLaTeXHaving;\nexports.isArgumentHaving = isArgumentHaving;\nexports.isSubOrSuperSymbol = isSubOrSuperSymbol;\nexports.protectChar = protectChar;\nexports.isTypeHaving = isTypeHaving;\nexports.isLaTeXBlock = isLaTeXBlock;\nexports.isLaTeXNoRaw = isLaTeXNoRaw;\nexports.isLaTeXRaw = isLaTeXRaw;\nexports.isTeXRaw = isTeXRaw;\nexports.isTeXChar = isTeXChar;\nexports.isTeXComm = isTeXComm;\nexports.isTeXCommS = isTeXCommS;\nexports.isTeXEnv = isTeXEnv;\nexports.isTeXMath = isTeXMath;\nexports.isTeXLineBreak = isTeXLineBreak;\nexports.isSubOrSuperScript = isSubOrSuperScript;\nexports.isTeXBraces = isTeXBraces;\nexports.isFixArg = isFixArg;\nexports.isOptArg = isOptArg;\nexports.isTeXComment = isTeXComment;\nexports.isTeXEmpty = isTeXEmpty;\nexports.newFixArg = newFixArg;\nexports.newOptArg = newOptArg;\nexports.newSymArg = newSymArg;\nexports.newParArg = newParArg;\nexports.newMOptArg = newMOptArg;\nexports.newMSymArg = newMSymArg;\nexports.newMParArg = newMParArg;\nexports.newCommandS = newCommandS;\nexports.newTeXRaw = newTeXRaw;\nexports.newTeXMath = newTeXMath;\nexports.newTeXBraces = newTeXBraces;\nexports.newTeXComment = newTeXComment;\nexports.newTeXComm = newTeXComm;\nexports.newSubOrSuperScript = newSubOrSuperScript;\nexports.newTeXEnv = newTeXEnv;\nexports.stringifyLaTeX = stringifyLaTeX;\n\nvar _Utils = __webpack_require__(0);\n\nvar _CategoryCode = __webpack_require__(3);\n\nfunction isMeasure(x) {\n    return isBuiltInMeasure(x) || isCustomMeasure(x);\n}\nvar measureTypes = exports.measureTypes = {\n    \"pt\": true,\n    \"mm\": true,\n    \"cm\": true,\n    \"in\": true,\n    \"ex\": true,\n    \"em\": true\n};\nfunction isMeasureType(x) {\n    return measureTypes.hasOwnProperty(x);\n}\nfunction isBuiltInMeasure(x) {\n    return isMeasureType(x.type) && (0, _Utils.isNumber)(x.value);\n}\nfunction isCustomMeasure(x) {\n    return isLaTeXBlock(x.expression);\n}\nvar mathTypes = exports.mathTypes = {\n    Parentheses: \"Parentheses\",\n    Square: \"Square\",\n    Dollar: \"Dollar\"\n};\nfunction isMathType(x) {\n    if (x === undefined) return false;else switch (x) {\n        case \"Parentheses\":\n        case \"Square\":\n        case \"Dollar\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isNameHaving(x, name) {\n    return x !== undefined && (name === undefined ? typeof x.name === \"string\" : name === x.name);\n}\nfunction isTextHaving(x) {\n    return x !== undefined && typeof x.text === \"string\";\n}\nfunction isLaTeXHaving(x) {\n    return x !== undefined && (0, _Utils.isArray)(x.latex);\n}\nfunction isArgumentHaving(x) {\n    return x.arguments instanceof Array;\n}\nvar typeTeXSeq = exports.typeTeXSeq = \"TeXSeq\";\nvar typeTeXEnv = exports.typeTeXEnv = \"TeXEnv\";\nvar typeTeXBraces = exports.typeTeXBraces = \"TeXBraces\";\nvar typeTeXComment = exports.typeTeXComment = \"TeXComment\";\nvar typeTeXRaw = exports.typeTeXRaw = \"TeXRaw\";\nvar typeTeXComm = exports.typeTeXComm = \"TeXComm\";\nvar typeTeXCommS = exports.typeTeXCommS = \"TeXCommS\";\nvar SubOrSuperSymbol = exports.SubOrSuperSymbol = undefined;\n(function (SubOrSuperSymbol) {\n    SubOrSuperSymbol[SubOrSuperSymbol[\"SUP\"] = 0] = \"SUP\";\n    SubOrSuperSymbol[SubOrSuperSymbol[\"SUB\"] = 1] = \"SUB\";\n})(SubOrSuperSymbol || (exports.SubOrSuperSymbol = SubOrSuperSymbol = {}));\nfunction isSubOrSuperSymbol(x) {\n    return x === SubOrSuperSymbol.SUP || x === SubOrSuperSymbol.SUB;\n}\nvar fromStringLaTeX = exports.fromStringLaTeX = function fromStringLaTeX(x) {\n    return newTeXRaw(protectString(x));\n};\nvar protectString = exports.protectString = function protectString(s) {\n    var newString = [];\n    for (var i = 0; i < s.length; i++) {\n        newString.push(protectChar(s.charAt(i)));\n    }return newString.join();\n};\nfunction protectChar(c) {\n    switch (c) {\n        case \"#\":\n            return \"\\\\#\";\n        case \"$\":\n            return \"\\\\$\";\n        case \"%\":\n            return \"\\\\%\";\n        case \"^\":\n            return \"\\\\^{}\";\n        case \"&\":\n            return \"\\\\&\";\n        case \"{\":\n            return \"\\\\{\";\n        case \"}\":\n            return \"\\\\}\";\n        case \"~\":\n            return \"\\\\~{}\";\n        case \"\\\\\":\n            return \"\\\\textbackslash{}\";\n        case \"_\":\n            return \"\\\\_{}\";\n        default:\n            return c;\n    }\n}\nfunction isTypeHaving(x) {\n    for (var _len = arguments.length, anyOfTypes = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        anyOfTypes[_key - 1] = arguments[_key];\n    }\n\n    return anyOfTypes.length === 0 ? typeof x.type === \"string\" : anyOfTypes.some(function (type) {\n        return x.type === type;\n    });\n}\nfunction isLaTeXBlock(x) {\n    return isLaTeXRaw(x) || isLaTeXNoRaw(x);\n}\nfunction isLaTeXNoRaw(x) {\n    return isTeXEmpty(x) || isTeXChar(x) || isTeXComm(x) || isTeXEnv(x) || isTeXMath(x) || isTeXLineBreak(x) || isTeXBraces(x) || isTeXComment(x);\n}\nfunction isLaTeXRaw(x) {\n    return isTeXEmpty(x) || isTeXRaw(x) || isTeXComm(x) || isTeXEnv(x) || isTeXMath(x) || isTeXLineBreak(x) || isTeXBraces(x) || isTeXComment(x);\n}\nfunction isTeXRaw(x) {\n    return x !== undefined && x.type !== undefined && isTextHaving(x) && isTypeHaving(x, typeTeXRaw);\n}\nfunction isTeXChar(x) {\n    return x !== undefined && typeof x.string === \"string\" && typeof x.category === \"number\";\n}\nfunction isTeXComm(x) {\n    return isNameHaving(x) && isArgumentHaving(x) && isTypeHaving(x, typeTeXComm, typeTeXCommS);\n}\nfunction isTeXCommS(x) {\n    return isTeXComm(x) && x.arguments.length === 0;\n}\nfunction isTeXEnv(x, name) {\n    return isTypeHaving(x, typeTeXEnv);\n}\nfunction isTeXMath(x) {\n    return isLaTeXHaving(x) && isTypeHaving(x) && isMathType(x.type);\n}\nfunction isTeXLineBreak(x) {\n    return x !== undefined && typeof x.noNewPage === \"boolean\" && (x.measure === undefined || isMeasure(x.measure));\n}\nfunction isSubOrSuperScript(x) {\n    return isSubOrSuperSymbol(x.type);\n}\nfunction isTeXBraces(x) {\n    return isLaTeXHaving(x) && isTypeHaving(x, typeTeXBraces);\n}\nfunction isFixArg(x) {\n    return isTypeHaving(x, \"FixArg\");\n}\nfunction isOptArg(x) {\n    return isTypeHaving(x, \"OptArg\");\n}\nfunction isTeXComment(x) {\n    return isTextHaving(x) && isTypeHaving(x, typeTeXComment);\n}\nfunction isTeXEmpty(e) {\n    return e !== undefined && Object.keys(e).length === 0;\n}\nfunction newFixArg(l) {\n    return { type: \"FixArg\", latex: l };\n}\nfunction newOptArg(l) {\n    return l.length === 1 ? { type: \"OptArg\", latex: l } : { type: \"MOptArg\", latex: l };\n}\nfunction newSymArg(l) {\n    return { type: \"SymArg\", latex: [l] };\n}\nfunction newParArg(l) {\n    return { type: \"ParArg\", latex: [l] };\n}\nfunction newMOptArg(l) {\n    return { type: \"MOptArg\", latex: l };\n}\nfunction newMSymArg(l) {\n    return { type: \"MSymArg\", latex: l };\n}\nfunction newMParArg(l) {\n    return { type: \"MParArg\", latex: l };\n}\nfunction newCommandS(name) {\n    return {\n        name: name,\n        arguments: [],\n        type: typeTeXCommS\n    };\n}\nfunction newTeXRaw(text) {\n    return {\n        text: text,\n        type: typeTeXRaw,\n        characterCategories: (0, _CategoryCode.convertToTeXCharsDefault)(text)\n    };\n}\nfunction newTeXMath(type, startSymbol, endSymbol, latex) {\n    return {\n        latex: latex,\n        type: type,\n        startSymbol: startSymbol,\n        endSymbol: endSymbol\n    };\n}\nfunction newTeXBraces(latex) {\n    return {\n        latex: [latex],\n        type: typeTeXBraces\n    };\n}\nvar newTeXMathDol = exports.newTeXMathDol = function newTeXMathDol(latex) {\n    return newTeXMath(\"Dollar\", \"$\", \"$\", latex);\n};\nfunction newTeXComment(text) {\n    return {\n        text: text,\n        type: typeTeXComment\n    };\n}\nfunction newTeXComm(name) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n    }\n\n    return {\n        name: name,\n        arguments: args,\n        type: typeTeXComm\n    };\n}\nfunction newSubOrSuperScript(type, symbol, args) {\n    return {\n        type: type,\n        symbol: symbol,\n        arguments: args\n    };\n}\nfunction newTeXEnv(name, latex) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n    }\n\n    return {\n        name: name,\n        latex: latex,\n        arguments: args,\n        type: typeTeXEnv\n    };\n}\nfunction stringifyLaTeX(tex) {\n    var arr = [];\n    stringifyLaTeXInner(tex, arr);\n    return arr.join(\"\");\n}\nfunction stringifyLaTeXInner(tex, soFar) {\n    if (isTeXComm(tex)) {\n        soFar.push(\"\\\\\", tex.name);\n        tex.arguments.forEach(function (l) {\n            return stringifyLaTeXInner(l, soFar);\n        });\n    } else if (isTeXEnv(tex)) throw new Error(\"not supported yet\");else if (isTeXMath(tex)) {\n        soFar.push(tex.startSymbol);\n        tex.latex.forEach(function (t) {\n            return stringifyLaTeXInner(t, soFar);\n        });\n        soFar.push(tex.endSymbol);\n    } else if (isTeXLineBreak(tex)) soFar.push(\"\\n\");else if (isSubOrSuperScript(tex)) {\n        soFar.push(tex.symbol);\n        if (tex.arguments) tex.arguments.forEach(function (arg) {\n            return stringifyLaTeXInner(arg, soFar);\n        });\n    } else if (isTeXBraces(tex)) {\n        soFar.push(\"{\");\n        tex.latex.forEach(function (t) {\n            return stringifyLaTeXInner(t, soFar);\n        });\n        soFar.push(\"}\");\n    } else if (isTeXComment(tex)) {\n        soFar.push(\"%\" + tex.text + \"\\n\");\n    } else if (isTeXRaw(tex)) soFar.push(tex.text);else if (isTeXChar(tex)) throw new Error(\"not supported yet\");else if (isFixArg(tex)) {\n        soFar.push(\"{\");\n        tex.latex.forEach(function (t) {\n            return stringifyLaTeXInner(t, soFar);\n        });\n        soFar.push(\"}\");\n    } else if (isOptArg(tex)) {\n        soFar.push(\"[\");\n        tex.latex.forEach(function (t) {\n            return stringifyLaTeXInner(t, soFar);\n        });\n        soFar.push(\"]\");\n    } else throw new Error(\"Did not recognize \" + JSON.stringify(tex));\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(0);\n\nObject.keys(_Utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Utils[key];\n    }\n  });\n});\n\nvar _Syntax = __webpack_require__(1);\n\nObject.keys(_Syntax).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Syntax[key];\n    }\n  });\n});\n\nvar _Parser = __webpack_require__(4);\n\nObject.keys(_Parser).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Parser[key];\n    }\n  });\n});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.convertToTeXCharsDefault = convertToTeXCharsDefault;\nexports.convertToTeXChars = convertToTeXChars;\nvar defaultCategories = exports.defaultCategories = function defaultCategories(char) {\n    switch (char) {\n        case \"\\\\\":\n            return 0;\n        case \"{\":\n            return 1;\n        case \"}\":\n            return 2;\n        case \"$\":\n            return 3;\n        case \"&\":\n            return 4;\n        case \"\\r\":\n            return 5;\n        case \"#\":\n            return 6;\n        case \"^\":\n            return 7;\n        case \"_\":\n            return 8;\n        case \"\\0\":\n            return 9;\n        case \" \":\n            return 10;\n        case \"~\":\n            return 13;\n        case \"%\":\n            return 14;\n        case \"\\d\":\n            return 15;\n        default:\n            return 11;\n    }\n};\nfunction convertToTeXCharsDefault(str) {\n    return convertToTeXChars(defaultCategories, str);\n}\nfunction convertToTeXChars(categoryMap, str) {\n    var chars = [];\n    for (var i = 0; i < str.length; i++) {\n        var charAt = str.charAt(i);\n        chars.push({\n            string: charAt,\n            category: categoryMap(charAt)\n        });\n    }\n    return chars;\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.dolMath = exports.subOrSuperscriptSymbolParser = exports.endCmd = exports.specialChar = exports.environment = exports.env = exports.latexParser = exports.latexBlockParserMathMode = exports.latexBlockParserTextMode = exports.commandSymbol = exports.mathSymbol = exports.specialCharsDefault = exports.comment = exports.notTextDefaultAndNotClosingBracket = exports.notTextMathModeAndNotClosingBracket = exports.notTextMathMode = exports.notTextDefault = exports.takeTill = exports.defaultParserConf = undefined;\nexports.textParser = textParser;\nexports.isSpecialCharacter = isSpecialCharacter;\nexports.isNotText = isNotText;\nexports.latexBlockParser = latexBlockParser;\nexports.fixArg = fixArg;\nexports.optArg = optArg;\nexports.cmdArg = cmdArg;\nexports.cmdArgs = cmdArgs;\nexports.command = command;\nexports.shiftedScript = shiftedScript;\nexports.isOk = isOk;\nexports.isNotOk = isNotOk;\nexports.mustBeOk = mustBeOk;\n\nvar _parsimmon = __webpack_require__(5);\n\nvar _Syntax = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar defaultParserConf = exports.defaultParserConf = {\n    verbatimEnvironments: [\"verbatim\"]\n};\nvar takeTill = exports.takeTill = function takeTill(predicate) {\n    return (0, _parsimmon.takeWhile)(function (c) {\n        return !predicate(c);\n    });\n};\nvar takeTillNewline = (0, _parsimmon.regexp)(/[^\\n]*/);\nvar maybeNewline = (0, _parsimmon.regexp)(/\\n?/);\nvar whitespace = (0, _parsimmon.regexp)(/\\s*/m);\nvar commentSymbol = (0, _parsimmon.string)(\"%\");\nfunction unsafeUnion(xs, ys) {\n    var xn = xs.length;\n    var yn = ys.length;\n    if (xn === 0) {\n        return ys;\n    } else if (yn === 0) {\n        return xs;\n    }\n    var obj = {};\n    for (var i = 0; i < xn; i++) {\n        obj[xs[i]] = true;\n    }\n    for (var j = 0; j < yn; j++) {\n        obj[ys[j]] = true;\n    }\n    var keys = [];\n    for (var k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            keys.push(k);\n        }\n    }\n    keys.sort();\n    return keys;\n}\nfunction mergeReplies(result, last) {\n    if (!last) {\n        return result;\n    }\n    if (result.furthest > last.furthest) {\n        return result;\n    }\n    var expected = result.furthest === last.furthest ? unsafeUnion(result.expected, last.expected) : last.expected;\n    return {\n        status: result.status,\n        index: result.index,\n        value: result.value,\n        furthest: last.furthest,\n        expected: expected\n    };\n}\nfunction manyTillAndMap(manyOf, till, map, initial) {\n    return (0, _parsimmon.Parser)(function (input, i) {\n        var accum = initial;\n        var j = 0;\n        var result = undefined;\n        while (i < input.length) {\n            var endCodonFound = till._(input, i);\n            if (endCodonFound.status) {\n                i = (0, _Utils.mustBeNumber)(endCodonFound.index);\n                break;\n            }\n            var bigParse = manyOf._(input, i);\n            if (isNotOk(bigParse)) return bigParse;\n            result = (0, _Utils.mustNotBeUndefined)(mergeReplies(bigParse, result));\n            if (isNotOk(result)) {\n                return result;\n            }\n            j++;\n            var value = (0, _Utils.mustNotBeUndefined)(result.value);\n            accum = map(accum, value);\n            i = (0, _Utils.mustBeNumber)(result.index);\n        }\n        var result2 = (0, _parsimmon.makeSuccess)(i, accum);\n        return mustBeOk(mergeReplies(result2, result));\n    });\n}\nfunction manyTill(manyOf, till) {\n    return manyTillAndMap(manyOf, till, function (a, el) {\n        return a.concat([el]);\n    }, []);\n}\nfunction token(parser) {\n    return parser.skip(whitespace);\n}\nfunction word(str) {\n    return (0, _parsimmon.string)(str).thru(token);\n}\nvar lbrace = \"{\";\nvar rbrace = \"}\";\nvar lbracket = \"[\";\nvar rbracket = \"]\";\nvar comma = \",\";\nvar colon = \":\";\nvar openingBracket = (0, _parsimmon.string)(lbracket);\nvar closingBracket = (0, _parsimmon.string)(rbracket);\nvar isClosingbracket = function isClosingbracket(str) {\n    return str === rbracket;\n};\nvar notTextDefault = exports.notTextDefault = {\n    \"$\": true,\n    \"%\": true,\n    \"\\\\\": true,\n    \"{\": true,\n    \"]\": true,\n    \"}\": true\n};\nvar notTextMathMode = exports.notTextMathMode = {\n    \"^\": true,\n    \"_\": true,\n    \"$\": true,\n    \"%\": true,\n    \"\\\\\": true,\n    \"{\": true,\n    \"]\": true,\n    \"}\": true\n};\nvar notTextMathModeAndNotClosingBracket = exports.notTextMathModeAndNotClosingBracket = {\n    \"^\": true,\n    \"_\": true,\n    \"$\": true,\n    \"%\": true,\n    \"\\\\\": true,\n    \"{\": true,\n    \"}\": true\n};\nvar notTextDefaultAndNotClosingBracket = exports.notTextDefaultAndNotClosingBracket = {\n    \"$\": true,\n    \"%\": true,\n    \"\\\\\": true,\n    \"{\": true,\n    \"}\": true\n};\nfunction takeAtLeastOneTill(till) {\n    return (0, _parsimmon.Parser)(function (str, i) {\n        var firstChar = str.charAt(i);\n        if (i >= str.length || till(firstChar)) {\n            return (0, _parsimmon.makeFailure)(i, \"text character\");\n        } else {\n            var strz = [firstChar];\n            i++;\n            var char = str.charAt(i);\n            while (!till(char) && i < str.length) {\n                strz.push(char);\n                i++;\n                char = str.charAt(i);\n            }\n            return (0, _parsimmon.makeSuccess)(i, strz.join(\"\"));\n        }\n    });\n}\nfunction textParser(notText) {\n    return takeAtLeastOneTill(isNotText(notText)).map(function (match) {\n        return (0, _Syntax.newTeXRaw)(match);\n    });\n}\nvar text = textParser(notTextDefault);\nvar text2 = textParser(notTextDefaultAndNotClosingBracket);\nvar spaces = (0, _parsimmon.regexp)(/ */).map(_Syntax.newTeXRaw);\nvar comment = exports.comment = commentSymbol.then(takeTillNewline).skip(maybeNewline).map(_Syntax.newTeXComment);\nvar specialCharsDefault = exports.specialCharsDefault = {\n    \"'\": true,\n    \"(\": true,\n    \")\": true,\n    \",\": true,\n    \".\": true,\n    \"-\": true,\n    '\"': true,\n    \"!\": true,\n    \"^\": true,\n    \"$\": true,\n    \"&\": true,\n    \"#\": true,\n    \"{\": true,\n    \"}\": true,\n    \"%\": true,\n    \"~\": true,\n    \"|\": true,\n    \"/\": true,\n    \":\": true,\n    \";\": true,\n    \"=\": true,\n    \"[\": true,\n    \"]\": true,\n    \"\\\\\": true,\n    \"`\": true,\n    \" \": true\n};\nfunction isSpecialCharacter(char, specialChars) {\n    var chars = specialChars === undefined ? specialCharsDefault : specialChars;\n    return chars.hasOwnProperty(char);\n}\nfunction isNotText(notText) {\n    return function (char) {\n        return notText.hasOwnProperty(char);\n    };\n}\nvar mathSymbol = exports.mathSymbol = (0, _parsimmon.string)(\"$\");\nvar commandSymbol = exports.commandSymbol = (0, _parsimmon.string)(\"\\\\\");\nfunction latexBlockParser(mode) {\n    var sub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"_\";\n    var sup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"^\";\n\n    switch (mode) {\n        case \"Math\":\n            return latexBlockParserMathMode(sub, sup);\n        default:\n            return latexBlockParserTextMode;\n    }\n}\nvar latexBlockParserTextMode = exports.latexBlockParserTextMode = (0, _parsimmon.lazy)(function () {\n    return (0, _parsimmon.alt)((0, _parsimmon.alt)(textParser(notTextDefault), dolMath, comment, textParser(notTextDefaultAndNotClosingBracket), environment, command(\"Paragraph\")));\n});\nvar latexBlockParserMathMode = exports.latexBlockParserMathMode = function latexBlockParserMathMode(sub, sup) {\n    return (0, _parsimmon.lazy)(function () {\n        return (0, _parsimmon.alt)((0, _parsimmon.alt)(shiftedScript(\"Math\", sub, sup), textParser(notTextMathMode), dolMath, comment, textParser(notTextMathModeAndNotClosingBracket), environment, command(\"Math\")));\n    });\n};\nvar latexParser = exports.latexParser = latexBlockParserTextMode.many();\nvar anonym = (0, _parsimmon.string)(lbrace).then(latexBlockParserTextMode.many()).skip((0, _parsimmon.string)(rbrace));\nvar env = exports.env = (0, _parsimmon.Parser)(function (input, i) {\n    var beginFound = (0, _parsimmon.string)(\"\\\\begin\").then((0, _parsimmon.string)(lbrace)).then(spaces).then((0, _parsimmon.regexp)(/[a-zA-Z]+/)).skip(spaces).skip((0, _parsimmon.string)(rbrace))._(input, i);\n    if (isNotOk(beginFound)) return beginFound;\n    i = (0, _Utils.mustBeNumber)(beginFound.index);\n    var envName = beginFound.value;\n    return manyTill(latexBlockParserTextMode, (0, _parsimmon.string)(\"\\\\end\").then((0, _parsimmon.string)(lbrace)).then(spaces).then((0, _parsimmon.string)(envName)).then(spaces).then((0, _parsimmon.string)(rbrace))).map(function (latex) {\n        return (0, _Syntax.newTeXEnv)(envName, latex);\n    })._(input, i);\n});\nvar environment = exports.environment = (0, _parsimmon.alt)(anonym, env);\nvar specialChar = exports.specialChar = (0, _parsimmon.test)(isSpecialCharacter);\nfunction isUppercaseAlph(c) {\n    return c >= \"A\" && c <= \"Z\";\n}\nfunction isLowercaseAlph(c) {\n    return c >= \"a\" && c <= \"z\";\n}\nvar endCmd = exports.endCmd = function endCmd(c) {\n    return !isLowercaseAlph(c) && !isUppercaseAlph(c);\n};\nvar openingBrace = (0, _parsimmon.string)(\"{\");\nvar closingBrace = (0, _parsimmon.string)(\"}\");\nvar isClosingBrace = function isClosingBrace(str) {\n    return str === \"}\";\n};\nfunction fixArg(mode) {\n    return openingBrace.then(manyTill(latexBlockParser(mode, \"_\"), closingBrace)).map(_Syntax.newFixArg);\n}\nfunction optArg(mode) {\n    return openingBracket.then(manyTill(latexBlockParser(mode), closingBracket)).map(_Syntax.newOptArg);\n}\nfunction cmdArg(mode) {\n    return (0, _parsimmon.alt)(fixArg(mode), optArg(mode));\n}\nfunction cmdArgs(mode) {\n    return (0, _parsimmon.alt)((0, _parsimmon.string)(\"{}\").map(function () {\n        return [];\n    }), cmdArg(mode).map(function (s) {\n        return s;\n    }).atLeast(0)).map(function (e) {\n        return e;\n    });\n}\nfunction command(mode) {\n    return (0, _parsimmon.seqMap)(commandSymbol, (0, _parsimmon.alt)(specialChar, takeTill(endCmd)), cmdArgs(mode), function (ignored, name, argz) {\n        return argz !== undefined ? _Syntax.newTeXComm.apply(undefined, [name].concat(_toConsumableArray(argz))) : (0, _Syntax.newTeXComm)(name);\n    }).map(function (res) {\n        return res;\n    });\n}\nvar subOrSuperscriptSymbolParser = exports.subOrSuperscriptSymbolParser = function subOrSuperscriptSymbolParser(subscriptSymbol, superscriptSymbol) {\n    return (0, _parsimmon.alt)((0, _parsimmon.string)(subscriptSymbol), (0, _parsimmon.string)(superscriptSymbol)).map(function (parsedStr) {\n        return parsedStr === subscriptSymbol ? _Syntax.SubOrSuperSymbol.SUB : _Syntax.SubOrSuperSymbol.SUP;\n    });\n};\nfunction shiftedScript(mode, sub, sup) {\n    return (0, _parsimmon.seqMap)(subOrSuperscriptSymbolParser(sub, sup), cmdArgs(mode), function (symbol, argz) {\n        return (0, _Syntax.newSubOrSuperScript)(symbol, symbol === _Syntax.SubOrSuperSymbol.SUB ? sub : sup, argz);\n    }).map(function (res) {\n        return res;\n    });\n}\nvar dolMath = exports.dolMath = math();\nfunction math() {\n    var mathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Dollar\";\n    var sMath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"$\";\n    var eMath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"$\";\n\n    return (0, _parsimmon.string)(sMath).then(latexBlockParser(\"Math\", \"_\").many().map(function (str) {\n        return (0, _Syntax.newTeXMath)(mathType, sMath, eMath, str);\n    })).skip((0, _parsimmon.string)(eMath));\n}\nfunction isOk(parse) {\n    return parse !== undefined && parse.status === true;\n}\nfunction isNotOk(parse) {\n    return parse !== undefined && parse.status === false;\n}\nfunction mustBeOk(parse) {\n    if (!isOk(parse)) throw new Error(\"Expected parse to be success: \" + JSON.stringify(parse));\n    return parse;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n!function(n,t){ true?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.Parsimmon=t():n.Parsimmon=t()}(this,function(){return function(n){function t(e){if(r[e])return r[e].exports;var u=r[e]={i:e,l:!1,exports:{}};return n[e].call(u.exports,u,u.exports,t),u.l=!0,u.exports}var r={};return t.m=n,t.c=r,t.i=function(n){return n},t.d=function(n,r,e){t.o(n,r)||Object.defineProperty(n,r,{configurable:!1,enumerable:!0,get:e})},t.n=function(n){var r=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(r,\"a\",r),r},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p=\"\",t(t.s=0)}([function(n,t,r){\"use strict\";function e(n){if(!(this instanceof e))return new e(n);this._=n}function u(n){return n instanceof e}function i(n){return\"[object Array]\"==={}.toString.call(n)}function o(n,t){return{status:!0,index:n,value:t,furthest:-1,expected:[]}}function a(n,t){return{status:!1,index:-1,value:null,furthest:n,expected:[t]}}function f(n,t){if(!t)return n;if(n.furthest>t.furthest)return n;var r=n.furthest===t.furthest?s(n.expected,t.expected):t.expected;return{status:n.status,index:n.index,value:n.value,furthest:t.furthest,expected:r}}function c(n,t){var r=n.slice(0,t).split(\"\\n\");return{offset:t,line:r.length,column:r[r.length-1].length+1}}function s(n,t){var r=n.length,e=t.length;if(0===r)return t;if(0===e)return n;for(var u={},i=0;i<r;i++)u[n[i]]=!0;for(var o=0;o<e;o++)u[t[o]]=!0;var a=[];for(var f in u)u.hasOwnProperty(f)&&a.push(f);return a.sort(),a}function l(n){if(!u(n))throw new Error(\"not a parser: \"+n)}function h(n){if(!i(n))throw new Error(\"not an array: \"+n)}function p(n){if(\"number\"!=typeof n)throw new Error(\"not a number: \"+n)}function d(n){if(!(n instanceof RegExp))throw new Error(\"not a regexp: \"+n);for(var t=w(n),r=0;r<t.length;r++){var e=t.charAt(r);if(\"i\"!==e&&\"m\"!==e&&\"u\"!==e)throw new Error('unsupported regexp flag \"'+e+'\": '+n)}}function v(n){if(\"function\"!=typeof n)throw new Error(\"not a function: \"+n)}function g(n){if(\"string\"!=typeof n)throw new Error(\"not a string: \"+n)}function m(n){return 1===n.length?n[0]:\"one of \"+n.join(\", \")}function y(n,t){var r=t.index,e=r.offset;if(e===n.length)return\", got the end of the input\";var u=e>0?\"'...\":\"'\",i=n.length-e>12?\"...'\":\"'\";return\" at line \"+r.line+\" column \"+r.column+\", got \"+u+n.slice(e,e+12)+i}function x(n,t){return\"expected \"+m(t.expected)+y(n,t)}function w(n){var t=\"\"+n;return t.slice(t.lastIndexOf(\"/\")+1)}function E(n){return RegExp(\"^(?:\"+n.source+\")\",w(n))}function _(){for(var n=[].slice.call(arguments),t=n.length,r=0;r<t;r+=1)l(n[r]);return e(function(r,e){for(var u,i=new Array(t),a=0;a<t;a+=1){if(u=f(n[a]._(r,e),u),!u.status)return u;i[a]=u.value,e=u.index}return f(o(e,i),u)})}function b(){for(var n={},t=0,r=[].slice.call(arguments),a=r.length,c=0;c<a;c+=1){var s=r[c];if(!u(s)){if(i(s)){if(2===s.length&&\"string\"==typeof s[0]&&u(s[1])){var l=s[0];if(n[l])throw new Error(\"seqObj: duplicate key \"+l);n[l]=!0,t++;continue}}throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\")}}if(0===t)throw new Error(\"seqObj expects at least one named parser, found zero\");return e(function(n,t){for(var e,u={},c=0;c<a;c+=1){var s,l;if(i(r[c])?(s=r[c][0],l=r[c][1]):(s=null,l=r[c]),e=f(l._(n,t),e),!e.status)return e;s&&(u[s]=e.value),t=e.index}return f(o(t,u),e)})}function O(){var n=[].slice.call(arguments);if(0===n.length)throw new Error(\"seqMap needs at least one argument\");var t=n.pop();return v(t),_.apply(null,n).map(function(n){return t.apply(null,n)})}function k(n){var t={};for(var r in n)({}).hasOwnProperty.call(n,r)&&function(r){var e=function(){return n[r](t)};t[r]=G(e)}(r);return t}function j(){var n=[].slice.call(arguments),t=n.length;if(0===t)return F(\"zero alternates\");for(var r=0;r<t;r+=1)l(n[r]);return e(function(t,r){for(var e,u=0;u<n.length;u+=1)if(e=f(n[u]._(t,r),e),e.status)return e;return e})}function P(n,t){return q(n,t).or(z([]))}function q(n,t){l(n),l(t);var r=t.then(n).many();return n.chain(function(n){return r.map(function(t){return[n].concat(t)})})}function A(n){g(n);var t=\"'\"+n+\"'\";return e(function(r,e){var u=e+n.length,i=r.slice(e,u);return i===n?o(u,i):a(e,t)})}function B(n,t){d(n),arguments.length>=2?p(t):t=0;var r=E(n),u=\"\"+n;return e(function(n,e){var i=r.exec(n.slice(e));if(i){if(0<=t&&t<=i.length){var f=i[0],c=i[t];return o(e+f.length,c)}return a(e,\"valid match group (0 to \"+i.length+\") in \"+u)}return a(e,u)})}function z(n){return e(function(t,r){return o(r,n)})}function F(n){return e(function(t,r){return a(r,n)})}function M(n){if(u(n))return e(function(t,r){var e=n._(t,r);return e.index=r,e.value=\"\",e});if(\"string\"==typeof n)return M(A(n));if(n instanceof RegExp)return M(B(n));throw new Error(\"not a string, regexp, or parser: \"+n)}function R(n){return l(n),e(function(t,r){var e=n._(t,r),u=t.slice(r,e.index);return e.status?a(r,'not \"'+u+'\"'):o(r,null)})}function L(n){return v(n),e(function(t,r){var e=t.charAt(r);return r<t.length&&n(e)?o(r+1,e):a(r,\"a character matching \"+n)})}function S(n){return L(function(t){return n.indexOf(t)>=0})}function W(n){return L(function(t){return n.indexOf(t)<0})}function I(n){return e(n(o,a))}function C(n,t){return L(function(r){return n<=r&&r<=t}).desc(n+\"-\"+t)}function D(n){return v(n),e(function(t,r){for(var e=r;e<t.length&&n(t.charAt(e));)e++;return o(e,t.slice(r,e))})}function G(n,t){arguments.length<2&&(t=n,n=void 0);var r=e(function(n,e){return r._=t()._,r._(n,e)});return n?r.desc(n):r}function H(){return F(\"fantasy-land/empty\")}var J=e.prototype;J.parse=function(n){if(\"string\"!=typeof n)throw new Error(\".parse must be called with a string as its argument\");var t=this.skip(T)._(n,0);return t.status?{status:!0,value:t.value}:{status:!1,index:c(n,t.furthest),expected:t.expected}},J.tryParse=function(n){var t=this.parse(n);if(t.status)return t.value;var r=x(n,t),e=new Error(r);throw e.type=\"ParsimmonError\",e.result=t,e},J.or=function(n){return j(this,n)},J.trim=function(n){return this.wrap(n,n)},J.wrap=function(n,t){return O(n,this,t,function(n,t){return t})},J.thru=function(n){return n(this)},J.then=function(n){return l(n),_(this,n).map(function(n){return n[1]})},J.many=function(){var n=this;return e(function(t,r){for(var e=[],u=void 0;;){if(u=f(n._(t,r),u),!u.status)return f(o(r,e),u);r=u.index,e.push(u.value)}})},J.tie=function(){return this.map(function(n){h(n);for(var t=\"\",r=0;r<n.length;r++)g(n[r]),t+=n[r];return t})},J.times=function(n,t){var r=this;return arguments.length<2&&(t=n),p(n),p(t),e(function(e,u){for(var i=[],a=void 0,c=void 0,s=0;s<n;s+=1){if(a=r._(e,u),c=f(a,c),!a.status)return c;u=a.index,i.push(a.value)}for(;s<t&&(a=r._(e,u),c=f(a,c),a.status);s+=1)u=a.index,i.push(a.value);return f(o(u,i),c)})},J.result=function(n){return this.map(function(){return n})},J.atMost=function(n){return this.times(0,n)},J.atLeast=function(n){return O(this.times(n),this.many(),function(n,t){return n.concat(t)})},J.map=function(n){v(n);var t=this;return e(function(r,e){var u=t._(r,e);return u.status?f(o(u.index,n(u.value)),u):u})},J.skip=function(n){return _(this,n).map(function(n){return n[0]})},J.mark=function(){return O(K,this,K,function(n,t,r){return{start:n,value:t,end:r}})},J.node=function(n){return O(K,this,K,function(t,r,e){return{name:n,value:r,start:t,end:e}})},J.sepBy=function(n){return P(this,n)},J.sepBy1=function(n){return q(this,n)},J.lookahead=function(n){return this.skip(M(n))},J.notFollowedBy=function(n){return this.skip(R(n))},J.desc=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status||(u.expected=[n]),u})},J.fallback=function(n){return this.or(z(n))},J.ap=function(n){return O(n,this,function(n,t){return n(t)})},J.chain=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status?f(n(u.value)._(r,u.index),u):u})},J.concat=J.or,J.empty=H,J.of=z,J[\"fantasy-land/ap\"]=J.ap,J[\"fantasy-land/chain\"]=J.chain,J[\"fantasy-land/concat\"]=J.concat,J[\"fantasy-land/empty\"]=J.empty,J[\"fantasy-land/of\"]=J.of,J[\"fantasy-land/map\"]=J.map;var K=e(function(n,t){return o(t,c(n,t))}),N=e(function(n,t){return t>=n.length?a(t,\"any character\"):o(t+1,n.charAt(t))}),Q=e(function(n,t){return o(n.length,n.slice(t))}),T=e(function(n,t){return t<n.length?a(t,\"EOF\"):o(t,null)}),U=B(/[0-9]/).desc(\"a digit\"),V=B(/[0-9]*/).desc(\"optional digits\"),X=B(/[a-z]/i).desc(\"a letter\"),Y=B(/[a-z]*/i).desc(\"optional letters\"),Z=B(/\\s*/).desc(\"optional whitespace\"),$=B(/\\s+/).desc(\"whitespace\");e.all=Q,e.alt=j,e.any=N,e.createLanguage=k,e.custom=I,e.digit=U,e.digits=V,e.empty=H,e.eof=T,e.fail=F,e.formatError=x,e.index=K,e.isParser=u,e.lazy=G,e.letter=X,e.letters=Y,e.lookahead=M,e.makeFailure=a,e.makeSuccess=o,e.noneOf=W,e.notFollowedBy=R,e.of=z,e.oneOf=S,e.optWhitespace=Z,e.Parser=e,e.range=C,e.regex=B,e.regexp=B,e.sepBy=P,e.sepBy1=q,e.seq=_,e.seqMap=O,e.seqObj=b,e.string=A,e.succeed=z,e.takeWhile=D,e.test=L,e.whitespace=$,e[\"fantasy-land/empty\"]=H,e[\"fantasy-land/of\"]=z,n.exports=e}])});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// latex-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50496e019f194f1dd15e","/**\r\n * @fileoverview General JavaScript utils\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport type StringMap = { [s: string]: string };\r\n\r\nexport type TargetObject = any;\r\nexport type ValuesObject = any;\r\n\r\nexport type OptKeys = StringMap | string[];\r\n\r\nexport interface OptAttributes {\r\n    writable: boolean;\r\n    enumerable: boolean;\r\n    configurable: boolean;\r\n}\r\n/**\r\n * Update object properties by property values\r\n * @param {!Object} target the object to copy properties to\r\n * @param {!Object} values the object with property values (undefined values will be skipped)\r\n * @param {(!Object.<string,string>|!Array.<string>)=} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {{writable:boolean,enumerable:boolean,configurable:boolean}=} opt_attributes\r\n *        property attributes, { writable: true, enumerable: true, configurable: true } by default\r\n */\r\nexport function updateProperties(target: TargetObject,\r\n                                 values: ValuesObject,\r\n                                 opt_keys?: OptKeys,\r\n                                 opt_attributes: OptAttributes = {\r\n                                     writable: true,\r\n                                     enumerable: true,\r\n                                     configurable: true\r\n                                 }) {\r\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n    if (values === undefined) return; // do noting is the sources is undefined\r\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n    if (opt_attributes === undefined) {\r\n        opt_attributes = {writable: true, enumerable: true, configurable: true};\r\n    } else if (!(opt_attributes instanceof Object)) {\r\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\r\n    }\r\n    if (opt_keys === undefined) { // if the key map isn't defined\r\n        for (const key in values) { // for all the enumerable properties\r\n            //noinspection JSUnfilteredForInLoop\r\n            if (values[key] !== undefined) {\r\n                //noinspection JSUnfilteredForInLoop\r\n                Object.defineProperty(target, key, // update the property\r\n                    // using the defined value\r\n                    Object.create(opt_attributes, {value: {value: values[key]}})\r\n                );\r\n            }\r\n        }\r\n    } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n        opt_keys.forEach(key => {\r\n            if (values[key] !== undefined) {\r\n                Object.defineProperty(target, key, // update the property\r\n                    Object.create(opt_attributes, {value: {value: values[key]}}) // using the defined value\r\n                );\r\n            }\r\n        });\r\n    } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n        for (const targetKey in opt_keys) { // for all the target keys\r\n            //noinspection JSUnfilteredForInLoop\r\n            const key = opt_keys[targetKey]; // the sources key\r\n            if (values[key] !== undefined)\r\n            //noinspection JSUnfilteredForInLoop\r\n                Object.defineProperty(target, targetKey, // update the property\r\n                    // using the defined value\r\n                    Object.create(opt_attributes, {value: {value: values[key]}})\r\n                );\r\n        }\r\n    } else { // if \"keys\" has unsupported value\r\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Test object properties with property values (strict comparing is used)\r\n * @param {!Object} target the object with properties to test\r\n * @param {?Object} values the object with property values (undefined values will be skipped)\r\n * @param {?(Object.<string,string>|Array.<string>)} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {boolean=true} opt_skipUndefined true to skip keys with undefined values, false otherwise\r\n * @return {boolean} true if all the defined properties are the same false otherwise\r\n */\r\nexport function testProperties(target: TargetObject,\r\n                               values?: ValuesObject,\r\n                               opt_keys?: OptKeys,\r\n                               opt_skipUndefined = true) {\r\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n    if (values === undefined) return true; // do noting is the sources is undefined\r\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true; // skip undefined by default\r\n\r\n    if (opt_keys === undefined) { // if the key map isn't defined\r\n        for (const key in values) { // for all the enumerable properties\r\n            //noinspection JSUnfilteredForInLoop // TODO what to do?\r\n            if (\r\n                target[key] !== values[key]\r\n                && !(values[key] === undefined && opt_skipUndefined)\r\n            )\r\n                return false; // false if any value is different\r\n        }\r\n    } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n        return opt_keys.every(key => {\r\n            return target[key] === values[key] || (values[key] === undefined && opt_skipUndefined);\r\n        });\r\n    } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n        for (const targetKey in opt_keys) { // for all the target keys\r\n            const key = opt_keys[targetKey]; // the sources key\r\n            if (target[targetKey] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n                return false; // false if any value is different\r\n        }\r\n    } else { // if \"keys\" has unsupported value\r\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n    }\r\n    return true; // return true if all the defined properties are the same\r\n}\r\n\r\nexport const mustBeNumber = (a: any, msg?: string): number => {\r\n    if (!(isNumber(a)))\r\n        throw new TypeError(msg ? msg : \"Expected number\");\r\n    return a;\r\n};\r\n\r\nexport function isNumber(x: any): x is number {\r\n    return typeof x === \"number\";\r\n}\r\n\r\nexport function isString(x: any): x is string {\r\n    return typeof x === \"string\";\r\n}\r\n\r\nexport function mustNotBeUndefined<T>(x?: T, msg?: string): T {\r\n    if (!x) throw new Error(msg);\r\n    return x;\r\n}\r\n\r\n// @Deprecated\r\nexport function mustBeObject(o: any, msg?: string) {\r\n    if (!(o instanceof Object))\r\n        throw new TypeError(msg ? msg : \"Expected Object\");\r\n    return o;\r\n}\r\n\r\nexport function mustBeString(o: any, msg?: string): string {\r\n    if (typeof o !== \"string\")\r\n        throw new TypeError(msg ? msg : \"Expected string\");\r\n    return o;\r\n}\r\n\r\nexport function mustBeArray(a: any, msg?: string): any[] {\r\n    if (!(isArray(a)))\r\n        throw new TypeError(msg ? msg : \"Expected Array\");\r\n    return a;\r\n}\r\n\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function isArray(x: any): x is any[] {\r\n    return !!x && x.constructor === Array;\r\n}\r\n\r\nexport const mconcat = <T>(mappend: (x: T, y: T) => T, ...args: T[]) => args.reduceRight(mappend);\r\n\r\nexport const snd = <T, U>(pair: [T, U]) => pair[1];\r\n\r\n\r\nexport function concatMap<T, U>(arr: T[], f: (t: T) => U[]): U[] {\r\n    return [].concat.apply([], arr.map(f));\r\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/Utils.ts","import {isArray, isNumber} from \"../../../Utils\";\r\nimport {convertToTeXChars, convertToTeXCharsDefault, defaultCategories, TeXChar} from \"../../TeX/CategoryCode\";\r\n\r\n/** LaTeX syntax description in the definition of the 'LaTeX' datatype.\r\n If you want to add new commands or environments not defined in\r\n the library, import this module and use 'LaTeX' data constructors.\r\n module Text.LaTeX.Base.Syntax\r\n */\r\n\r\n/**\r\n ( -- * @LaTeX@ datatype\r\n Measure (..)\r\n , MathType (..)\r\n , LaTeX (..)\r\n , TeXArg (..)\r\n , (<>)\r\n\r\n -- * Escaping reserved characters\r\n , protectString\r\n , protectText\r\n\r\n -- * Syntax analysis\r\n , matchCommand\r\n , lookForCommand\r\n , matchEnv\r\n , lookForEnv\r\n , texmap\r\n , texmapM\r\n\r\n -- ** Utils\r\n , getBody\r\n , getPreamble\r\n ) where\r\n\r\n import Data.Text (Text,pack)\r\n import qualified Data.Text\r\n import Data.Monoid\r\n #if MIN_VERSION_base(4,9,0)\r\n import qualified Data.Semigroup as Semigroup\r\n #endif\r\n import Data.String\r\n import Control.Applicative\r\n import Control.Monad (replicateM)\r\n import Data.Functor.Identity (runIdentity)\r\n import Data.Data (Data)\r\n import Data.Typeable\r\n import GHC.Generics (Generic)\r\n import Test.QuickCheck\r\n */\r\n/**\r\n Measure units defined in LaTeX. Use 'CustomMeasure' to use commands like 'textwidth'.\r\n\r\n For instance:\r\n\r\n > rule Nothing (CustomMeasure linewidth) (Pt 2)\r\n\r\n This will create a blac box (see 'rule') as wide as the text and two points tall.\r\n */\r\nexport type Measure = BuiltInMeasure | CustomMeasure;\r\n// deriving (\r\n// Data\r\n// Eq\r\n// Generic,\r\n// Show,\r\n// Typeable\r\n\r\nexport function isMeasure(x: any): x is Measure {\r\n    return isBuiltInMeasure(x) || isCustomMeasure(x);\r\n}\r\n\r\nexport const measureTypes = {\r\n    \"pt\": true,                    // A point is 1/72.27 inch, that means about 0.0138 inch or 0.3515 mm.\r\n    \"mm\": true,                    // Millimeter.\r\n    \"cm\": true,                    // Centimeter.\r\n    \"in\": true,                    // Inch.\r\n    \"ex\": true,                    // The height of an \\\"x\\\" in the current font.\r\n    \"em\": true,                    // The width of an \\\"M\\\" in the current font.\r\n};\r\n\r\nexport type MeasureType = keyof typeof measureTypes;\r\n\r\nexport function isMeasureType(x: any): x is MeasureType {\r\n    return measureTypes.hasOwnProperty(x);\r\n}\r\n\r\nexport interface BuiltInMeasure {\r\n    type: MeasureType;\r\n    value: number;\r\n}\r\n\r\nexport function isBuiltInMeasure(x: any): x is BuiltInMeasure {\r\n    return isMeasureType(x.type) && isNumber(x.value);\r\n}\r\n\r\n/**\r\n * You can introduce a 'LaTeX' expression as a measure.\r\n */\r\nexport interface CustomMeasure {\r\n    expression: LaTeXRaw;\r\n}\r\n\r\nexport function isCustomMeasure(x: any): x is CustomMeasure {\r\n    return isLaTeXBlock(x.expression);\r\n}\r\n\r\n/** Different types of syntax for mathematical expressions.*/\r\nexport const mathTypes = {\r\n    Parentheses: \"Parentheses\",\r\n    Square: \"Square\",\r\n    Dollar: \"Dollar\"\r\n};\r\nexport type MathType = keyof typeof mathTypes;\r\n\r\n// deriving (Data, Eq, Generic, Show, Typeable)\r\nexport function isMathType(x: any): x is MathType {\r\n    if (x === undefined)\r\n        return false;\r\n    else switch (x) {\r\n        case \"Parentheses\":\r\n        case \"Square\":\r\n        case \"Dollar\":\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\nexport interface NameHaving {\r\n    name: string;\r\n}\r\n\r\nexport function isNameHaving(x: any, name?: string): x is NameHaving {\r\n    return x !== undefined && (name === undefined\r\n            ? typeof x.name === \"string\"\r\n            : name === x.name\r\n    );\r\n}\r\n\r\nexport interface CharCodeHaving {\r\n    charCode: number;\r\n}\r\n\r\nexport interface CharacterCatergiesHaving {\r\n    characterCategories: TeXChar[];\r\n}\r\n\r\nexport interface TextHaving {\r\n    text: string;\r\n}\r\n\r\nexport function isTextHaving(x: any): x is TextHaving {\r\n    return x !== undefined && typeof x.text === \"string\";\r\n}\r\n\r\n\r\nexport interface LaTeXHaving {\r\n    latex: LaTeXTxt[];\r\n}\r\n\r\nexport type MultipleLaTeXHaving = LaTeXHaving;\r\n\r\nexport function isLaTeXHaving(x: any): x is LaTeXHaving {\r\n    return x !== undefined && isArray(x.latex);\r\n}\r\n\r\nexport interface MathTypeHaving {\r\n    type: MathType;\r\n}\r\n\r\nexport interface ArgumentHaving {\r\n    arguments: TeXArg[];\r\n}\r\n\r\nexport function isArgumentHaving(x: any): x is ArgumentHaving {\r\n    return x.arguments instanceof Array;\r\n}\r\n\r\n\r\n/**\r\n * Types of @LaTeX@ blocks.\r\n */\r\nexport type LaTeX = LaTeXRaw | LaTeXNoRaw;\r\n\r\nexport type LaTeXRaw = TeXBuildingBlocks | TeXRaw;\r\n\r\n/**\r\n * Raw TeX string converted to @TeXChar@s.\r\n */\r\nexport type LaTeXNoRaw = TeXBuildingBlocks | TeXChar;\r\n\r\nexport type TeXBuildingBlocks =\r\n    TeXComm |\r\n    TeXEnv |\r\n    TeXMath |\r\n    TeXLineBreak |\r\n    SubOrSuperScript |\r\n    TeXBraces |\r\n    TeXComment;\r\n\r\n// type LaTeXExtended = LaTeXRawString |\r\n//     TeXEmpty;\r\n\r\n\r\n// deriving (Data, Eq, Generic, Show, Typeable)\r\n\r\nexport interface TypeHaving {\r\n    type: string;\r\n}\r\n\r\nexport type TypeTeXSeq = \"TeXSeq\";\r\nexport const typeTeXSeq: TypeTeXSeq = \"TeXSeq\"; //noinspection JSUnusedGlobalSymbols\r\nexport interface TypeHavingTeXSeq extends TypeHaving {\r\n    type: TypeTeXSeq;\r\n}\r\n\r\nexport type TypeTeXEnv = \"TeXEnv\";\r\nexport const typeTeXEnv: TypeTeXEnv = \"TeXEnv\";\r\n\r\nexport interface TypeHavingTeXEnv extends TypeHaving {\r\n    type: TypeTeXEnv;\r\n}\r\n\r\nexport type TypeTeXBraces = \"TeXBraces\";\r\nexport const typeTeXBraces: TypeTeXBraces = \"TeXBraces\";\r\n\r\nexport interface TypeHavingTeXBraces extends TypeHaving {\r\n    type: TypeTeXBraces;\r\n}\r\n\r\nexport type TypeTeXComment = \"TeXComment\";\r\nexport const typeTeXComment: TypeTeXComment = \"TeXComment\";\r\n\r\nexport interface TypeHavingTeXComment extends TypeHaving {\r\n    type: TypeTeXComment;\r\n}\r\n\r\nexport type TypeTeXRaw = \"TeXRaw\";\r\nexport const typeTeXRaw: TypeTeXRaw = \"TeXRaw\";\r\n\r\nexport interface TypeHavingTeXRaw extends TypeHaving {\r\n    type: TypeTeXRaw;\r\n}\r\n\r\n// export type TypeTeXChar = \"TeXChar\";\r\n// export const typeTeXChar: TypeTeXChar = \"TeXChar\";\r\n// export interface TypeHavingTeXChar extends TypeHaving {\r\n//     type: TypeTeXChar;\r\n// }\r\n\r\nexport type TypeTeXComm = \"TeXComm\" | TypeTeXCommS;\r\nexport const typeTeXComm: TypeTeXComm = \"TeXComm\";\r\n\r\nexport interface TypeHavingTeXComm extends TypeHaving {\r\n    type: TypeTeXComm;\r\n}\r\n\r\nexport type TypeTeXCommS = \"TeXCommS\";\r\nexport const typeTeXCommS: TypeTeXCommS = \"TeXCommS\"; //noinspection JSUnusedGlobalSymbols\r\nexport interface TypeHavingTeXCommS extends TypeHaving {\r\n    type: TypeTeXCommS;\r\n}\r\n\r\nexport type TeXRaw = TextHaving & TypeHavingTeXRaw & CharacterCatergiesHaving; // Raw text.\r\n\r\nexport type TeXComment = TextHaving & TypeHavingTeXComment; // Comments.\r\nexport type TeXComm = NameHaving & ArgumentHaving & TypeHavingTeXComm;\r\nexport type TeXEnv = MultipleLaTeXHaving & NameHaving & ArgumentHaving & TypeHavingTeXEnv;\r\n\r\n/**\r\n * Mathematical expression\r\n */\r\nexport interface TeXMath extends MultipleLaTeXHaving, MathTypeHaving {\r\n    startSymbol: string;\r\n    endSymbol: string;\r\n}\r\n\r\nexport type TeXBraces = LaTeXHaving & TypeHavingTeXBraces;\r\n\r\nexport enum SubOrSuperSymbol {SUP, SUB}\r\n\r\nexport function isSubOrSuperSymbol(x: any): x is SubOrSuperSymbol {\r\n    return x === SubOrSuperSymbol.SUP || x === SubOrSuperSymbol.SUB;\r\n}\r\n\r\nexport interface SubOrSuperScript {\r\n    type: SubOrSuperSymbol;\r\n    symbol: string;\r\n    arguments?: TeXArg[];\r\n}\r\n\r\n/**\r\n An expression between braces.\r\n Line break command.\r\n */\r\nexport interface TeXLineBreak {\r\n    measure?: Measure;\r\n    noNewPage: boolean;\r\n}\r\n\r\n/** Sequencing of 'LaTeX' expressions.*/\r\n// export interface TeXSeq {\r\n//     head: LaTeX;\r\n//     tail: LaTeX;\r\n//     type: TypeTeXSeq;\r\n// }\r\n\r\n// /**\r\n//  An empty block.\r\n//  /Neutral element/ of '<>'.\r\n//  */\r\n// export interface TeXEmpty {\r\n// }\r\n\r\n/**\r\n * When rendering, no space or @{}@ will be added at\r\n * the end.\r\n */\r\nexport interface TeXCommS extends TeXComm {\r\n    // Must be empty, but can't express it in the type :(\r\n    // arguments: [];\r\n    type: TypeTeXCommS;\r\n}\r\n\r\n\r\n// An argument for a 'LaTeX' command or environment.\r\nexport type TeXArg = FixArg |\r\n    OptArg |\r\n    MOptArg |\r\n    SymArg |\r\n    MSymArg |\r\n    ParArg |\r\n    MParArg;\r\n\r\n\r\n// deriving (Data, Eq, Generic, Show, Typeable)\r\n\r\n\r\nexport type FixArg = MultipleLaTeXHaving & TypeHavingFixArg; // Fixed argument.\r\n\r\nexport type OptArg = LaTeXHaving & TypeHavingOptArg; // Optional argument.\r\nexport type SymArg = LaTeXHaving & TypeHavingSymArg; // An argument enclosed between @\\<@ and @\\>@.\r\nexport type ParArg = LaTeXHaving & TypeHavingParArg; // An argument enclosed between @(@ and @)@.\r\nexport type MOptArg = MultipleLaTeXHaving & TypeHavingMOptArg; // Multiple optional argument.\r\nexport type MSymArg = MultipleLaTeXHaving & TypeHavingMSymArg; // Version of 'SymArg' with multiple options.\r\nexport type MParArg = MultipleLaTeXHaving & TypeHavingMParArg; // Version of 'ParArg' with multiple options.\r\n\r\nexport interface TypeHavingFixArg extends TypeHaving {\r\n    type: \"FixArg\";\r\n}\r\n\r\nexport interface TypeHavingOptArg extends TypeHaving {\r\n    type: \"OptArg\";\r\n}\r\n\r\nexport interface TypeHavingMOptArg extends TypeHaving {\r\n    type: \"MOptArg\";\r\n}\r\n\r\nexport interface TypeHavingSymArg extends TypeHaving {\r\n    type: \"SymArg\";\r\n}\r\n\r\nexport interface TypeHavingMSymArg extends TypeHaving {\r\n    type: \"MSymArg\";\r\n}\r\n\r\nexport interface TypeHavingParArg extends TypeHaving {\r\n    type: \"ParArg\";\r\n}\r\n\r\nexport interface TypeHavingMParArg extends TypeHaving {\r\n    type: \"MParArg\";\r\n}\r\n\r\n//\r\n// Monoid instance for 'LaTeX'.\r\n//\r\n//\r\n// export const mempty: TeXEmpty = {};\r\n//\r\n// /** Method 'mappend' is strict in both arguments (except in the case when the first argument is 'TeXEmpty').*/\r\n// export function mappend(x: LaTeX, y: LaTeX): typeTeXSeq {\r\n//     if (isTeXEmpty(y))\r\n//         return x;\r\n//     else if (isTeXEmpty(x))\r\n//         return y;\r\n//     // else if (isTeXSeq(x))\r\n//     //     return {\r\n//     //         head: x.head,\r\n//     //         tail: mappend(x.tail, y)\r\n//     //     };\r\n//     else\r\n//         return {\r\n//             head: x,\r\n//             tail: y\r\n//         };\r\n// }\r\n\r\n/** Method 'fromString' escapes LaTeX reserved characters using 'protectString'.*/\r\nexport const fromStringLaTeX = (x: string) => newTeXRaw(protectString(x));\r\n\r\n/** Escape LaTeX reserved characters in a 'String'.*/\r\nexport const protectString = (s: string) => {\r\n    const newString = [];\r\n    for (let i = 0; i < s.length; i++)\r\n        newString.push(protectChar(s.charAt(i)));\r\n    return newString.join();\r\n};\r\n\r\n// -- | Escape LaTeX reserved characters in a 'Text'.\r\n//     protectText :: Text -> Text\r\n// protectText = Data.Text.concatMap (fromString . protectChar)\r\n\r\nexport function protectChar(c: string): string {\r\n    switch (c) {\r\n        case \"#\":\r\n            return \"\\\\#\";\r\n        case \"$\":\r\n            return \"\\\\$\";\r\n        case \"%\":\r\n            return \"\\\\%\";\r\n        case \"^\":\r\n            return \"\\\\^{}\";\r\n        case \"&\":\r\n            return \"\\\\&\";\r\n        case \"{\":\r\n            return \"\\\\{\";\r\n        case \"}\":\r\n            return \"\\\\}\";\r\n        case \"~\":\r\n            return \"\\\\~{}\";\r\n        case \"\\\\\":\r\n            return \"\\\\textbackslash{}\";\r\n        case \"_\":\r\n            return \"\\\\_{}\";\r\n        default:\r\n            return c;\r\n    }\r\n}\r\n\r\n\r\n//\r\n// Syntax analysis\r\n//\r\n\r\n\r\n// /** Look into a 'LaTeX' syntax tree to find any call to the command with\r\n//  the given name. It returns a list of arguments with which this command\r\n//  is called.\r\n//\r\n//  > lookForCommand = (fmap snd .) . matchCommand . (==)\r\n//\r\n//  If the returned list is empty, the command was not found. However,\r\n//  if the list contains empty lists, those are callings to the command\r\n//  with no arguments.\r\n//\r\n//  For example\r\n//\r\n//  > lookForCommand \"author\" l\r\n//\r\n//  would look for the argument passed to the @\\\\author@ command in @l@.\r\n//  */\r\n// export const lookForCommand = (commandName: string, latex: LaTeX): TeXArg[][] =>\r\n//     matchCommand(s => s === commandName, latex).map(snd);\r\n//\r\n// /** Traverse a 'LaTeX' syntax tree and returns the commands (see 'TeXComm' and\r\n//  'TeXCommS') that matches the condition and their arguments in each call.*/\r\n// export const matchCommand = (f: ((s: string) => boolean), l: LaTeX): [string, TeXArg[]][] => {\r\n//     // if (isTeXSeq(l))\r\n//     //     return (matchCommand(f, l.head)).concat(matchCommand(f, l.tail));\r\n//\r\n//     if (isTeXCommS(l))\r\n//         return f(l.name) ? [[l.name, []]] : [];\r\n//\r\n//     if (isTeXComm(l)) {\r\n//         const xs: [string, TeXArg[]][] = concatMap(l.arguments, arg => matchCommandArg(f, arg));\r\n//         if (f(l.name)) {\r\n//             const a: [string, TeXArg[]][] = [[l.name, l.arguments]];\r\n//             return a.concat(xs);\r\n//         } else {\r\n//             return xs;\r\n//         }\r\n//     }\r\n//\r\n//     if (isTeXMath(l) || isTeXBraces(l))\r\n//         return matchCommand(f, l.latex);\r\n//\r\n//     return [];\r\n// };\r\n//\r\n// export const matchCommandArg = (f: ((string: string) => boolean), l: TeXArg): [string, TeXArg[]][] => {\r\n//     if (isMultipleLaTeXHaving(l)) {\r\n//         const res: [string, TeXArg[]][] = [].concat.apply([], mustBeArray(l.latex).map(latex => matchCommand(f, latex)));\r\n//         return res;\r\n//     }\r\n//     else {\r\n//         return matchCommand(f, l.latex);\r\n//     }\r\n// };\r\n\r\n\r\n// /** Similar to 'lookForCommand', but applied to environments.\r\n//  It returns a list with arguments passed and content of the\r\n//  environment in each call.\r\n//\r\n//  > lookForEnv = (fmap (\\(_,as,l) -> (as,l)) .) . matchEnv . (==)\r\n//  */\r\n// const compressEnv = (([ignored, as, l]: [any, TeXArg[], LaTeX]): [TeXArg[], LaTeX] => [as, l]);\r\n// export const lookForEnv = (s: string, l: LaTeX): [TeXArg[], LaTeX][] => {\r\n//     return matchEnv(str => str === s, l).map(compressEnv);\r\n// };\r\n\r\n// /** Traverse a 'LaTeX' syntax tree and returns the environments (see\r\n//  'TeXEnv') that matches the condition, their arguments and their content\r\n//  in each call.*/\r\n// export const matchEnv = (f: ((s: string) => boolean), l: LaTeX): [string, TeXArg[], LaTeX][] => {\r\n//     if (isTeXComm(l)) {\r\n//         return concatMap(\r\n//             l.arguments,\r\n//             (a: TeXArg): [string, TeXArg[], LaTeX][] => matchEnvArg(f, a)\r\n//         );\r\n//     }\r\n//     // else if (isTeXSeq(l))\r\n//     //     return matchEnv(f, l.head).concat(matchEnv(f, l.tail));\r\n//     else if (isTeXEnv(l)) {\r\n//         const tail: [string, TeXArg[], LaTeX][] = concatMap(l.arguments, (a: TeXArg) => matchEnvArg(f, a))\r\n//             .concat(matchEnv(f, l.latex));\r\n//         if (f(l.name)) {\r\n//             const head: [string, TeXArg[], LaTeX][] = [[l.name, l.arguments, l.latex]];\r\n//             const concat: [string, TeXArg[], LaTeX][] = head.concat(tail);\r\n//             return concat;\r\n//         } else {\r\n//             return tail;\r\n//         }\r\n//     }\r\n//     else if (isTeXMath(l) || isTeXBraces(l))\r\n//         return matchEnv(f, l.latex);\r\n//     else {\r\n//         return [];\r\n//     }\r\n// };\r\n//\r\n// export const matchEnvArg = (f: ((s: string) => boolean), l: TeXArg): [string, TeXArg[], LaTeX][] => {\r\n//     if (isMultipleLaTeXHaving(l)) {\r\n//         return concatMap(l.latex, (latex: LaTeX): [string, TeXArg[], LaTeX][] => matchEnv(f, latex));\r\n//     } else {\r\n//         return matchEnv(f, l.latex);\r\n//     }\r\n// };\r\n\r\n\r\n//  /** The function 'texmap' looks for subexpressions that match a given\r\n//     condition and applies a function to them.\r\n//\r\n//   > texmap c f = runIdentity . texmapM c (pure . f)\r\n//   */\r\n// export const texmap = (condition: (l: LaTeX) => boolean,\r\n//      f: ((l: LaTeX) => LaTeX), // Function to apply when the condition matches.\r\n//      l: LaTeX\r\n//  ): LaTeX => {\r\n//  runIdentity(texmapM condition (pure . f))\r\n//\r\n//  /** Version of 'texmap' where the function returns values in a 'Monad'.\r\n//  texmapM :: (Applicative m, Monad m)\r\n//  => (LaTeX -> Bool) // Condition.\r\n//  -> (LaTeX -> m LaTeX) // Function to apply when the condition matches.\r\n//  ->  LaTeX -> m LaTeX\r\n//  texmapM c f = go\r\n//  where\r\n//  go l@(TeXComm str as)  = if c l then f l else TeXComm str <$> mapM go' as\r\n//  go l@(TeXEnv str as b) = if c l then f l else TeXEnv str <$> mapM go' as <*> go b\r\n//  go l@(TeXMath t b)     = if c l then f l else TeXMath t <$> go b\r\n//  go l@(TeXBraces b)     = if c l then f l else TeXBraces <$> go b\r\n//  go l@(TeXSeq l1 l2)    = if c l then f l else liftA2 TeXSeq (go l1) (go l2)\r\n//  go l = if c l then f l else pure l\r\n//  --\r\n//  go' (FixArg  l ) = FixArg  <$> go l\r\n//  go' (OptArg  l ) = OptArg  <$> go l\r\n//  go' (MOptArg ls) = MOptArg <$> mapM go ls\r\n//  go' (SymArg  l ) = SymArg  <$> go l\r\n//  go' (MSymArg ls) = MSymArg <$> mapM go ls\r\n//  go' (ParArg  l ) = ParArg  <$> go l\r\n//  go' (MParArg ls) = MParArg <$> mapM go ls\r\n\r\n// /**\r\n//  * Extract the content of the 'document' environment, if present.\r\n//  */\r\n// export const getBody = (l: LaTeX): LaTeX | undefined => {\r\n//     const env = lookForEnv(\"document\", l);\r\n//     return env.length > 0 ? env[0] : undefined;\r\n// };\r\n\r\n// /** Extract the preamble of a 'LaTeX' document (everything before the 'document'\r\n//  environment). It could be empty.*/\r\n// export const getPreamble = (l: LaTeX): LaTeX => {\r\n//     if (isTeXEnv(l, \"document\"))\r\n//         return mempty;\r\n//\r\n//     // else if (isTeXSeq(l))\r\n//     //     return mappend(\r\n//     //         getPreamble(l.head),\r\n//     //         getPreamble(l.tail)\r\n//     //     );\r\n//\r\n//     else\r\n//         return l;\r\n// };\r\n\r\n\r\n// ---------------------------------------\r\n//    -- LaTeX Arbitrary instance\r\n// TODO? with generators?\r\n\r\n// arbitraryChar :: Gen Char\r\n// arbitraryChar = elements $\r\n//     ['A'..'Z']\r\n// ++ ['a'..'z']\r\n// ++ \"\\n-+*/!\\\"$%&(){}^_.,:;'#@<>?\\\\ \"\r\n\r\n/** Utility for the instance of 'LaTeX' to 'Arbitrary'.\r\n --   We generate a short sequence of characters and\r\n --   escape reserved characters with 'protectText'.\r\n arbitraryRaw :: Gen Text\r\n arbitraryRaw = do\r\n n <- choose (1,20)\r\n protectText . pack <$> replicateM n arbitraryChar\r\n\r\n /** Generator for names of command and environments.\r\n --   We use only alphabetical characters.\r\n arbitraryName :: Gen String\r\n arbitraryName = do\r\n n <- choose (1,10)\r\n replicateM n $ elements $ ['a' .. 'z'] ++ ['A' .. 'Z']\r\n\r\n instance Arbitrary Measure where\r\n arbitrary = do\r\n n <- choose (0,5)\r\n let f = [Pt,Mm,Cm,In,Ex,Em] !! n\r\n f <$> arbitrary\r\n\r\n instance Arbitrary LaTeX where\r\n arbitrary = do\r\n -- We give more chances to 'TeXRaw'.\r\n -- This results in arbitrary 'LaTeX' values\r\n -- not getting too large.\r\n n <- choose (0,16 :: Int)\r\n case n of\r\n 0 -> pure TeXEmpty\r\n 1 -> do m <- choose (0,5)\r\n TeXComm <$> arbitraryName <*> vectorOf m arbitrary\r\n 2 -> TeXCommS <$> arbitraryName\r\n 3 -> do m <- choose (0,5)\r\n TeXEnv <$> arbitraryName <*> vectorOf m arbitrary <*> arbitrary\r\n 4 -> do m <- choose (0,2)\r\n let t = [Parentheses,Square,Dollar] !! m\r\n TeXMath <$> pure t <*> arbitrary\r\n 5 -> TeXLineBreak <$> arbitrary <*> arbitrary\r\n 6 -> TeXBraces <$> arbitrary\r\n 7 -> TeXComment <$> arbitraryRaw\r\n 8 -> TeXSeq <$> arbitrary <*> arbitrary\r\n _ -> TeXRaw <$> arbitraryRaw\r\n\r\n instance Arbitrary TeXArg where\r\n arbitrary = do\r\n n <- choose (0,6 :: Int)\r\n case n of\r\n 0 -> OptArg <$> arbitrary\r\n 1 -> do m <- choose (1,5)\r\n MOptArg <$> vectorOf m arbitrary\r\n 2 -> SymArg <$> arbitrary\r\n 3 -> do m <- choose (1,5)\r\n MSymArg <$> vectorOf m arbitrary\r\n 4 -> ParArg <$> arbitrary\r\n 5 -> do m <- choose (1,5)\r\n MParArg <$> vectorOf m arbitrary\r\n _ -> FixArg <$> arbitrary\r\n */\r\n\r\n\r\n//\r\n// type guards\r\n//\r\n\r\n\r\nexport function isTypeHaving(x: any, ...anyOfTypes: string[]): x is TypeHaving {\r\n    return anyOfTypes.length === 0 ? typeof x.type === \"string\" : anyOfTypes.some(type => x.type === type);\r\n}\r\n\r\nexport function isLaTeXBlock(x: any): x is (LaTeXRaw | LaTeXNoRaw) {\r\n    return isLaTeXRaw(x) || isLaTeXNoRaw(x); // || isTeXSeq(x);\r\n}\r\n\r\nexport function isLaTeXNoRaw(x: any): x is LaTeXNoRaw {\r\n    return isTeXEmpty(x)\r\n        || isTeXChar(x)\r\n        || isTeXComm(x)\r\n        || isTeXEnv(x)\r\n        || isTeXMath(x)\r\n        || isTeXLineBreak(x)\r\n        || isTeXBraces(x)\r\n        || isTeXComment(x);\r\n}\r\n\r\nexport function isLaTeXRaw(x: any): x is LaTeXRaw {\r\n    return isTeXEmpty(x)\r\n        || isTeXRaw(x)\r\n        || isTeXComm(x)\r\n        || isTeXEnv(x)\r\n        || isTeXMath(x)\r\n        || isTeXLineBreak(x)\r\n        || isTeXBraces(x)\r\n        || isTeXComment(x);\r\n}\r\n\r\nexport function isTeXRaw(x: any): x is TeXRaw {\r\n    return x !== undefined\r\n        && x.type !== undefined\r\n        && isTextHaving(x) && isTypeHaving(x, typeTeXRaw);\r\n}\r\n\r\nexport function isTeXChar(x: any): x is TeXChar {\r\n    return x !== undefined\r\n        && typeof x.string === \"string\"\r\n        && typeof x.category === \"number\";\r\n}\r\n\r\nexport function isTeXComm(x: any): x is TeXComm {\r\n    return isNameHaving(x)\r\n        && isArgumentHaving(x)\r\n        && isTypeHaving(x, typeTeXComm, typeTeXCommS)\r\n        ;\r\n}\r\n\r\nexport function isTeXCommS(x: any): x is TeXCommS {\r\n    return isTeXComm(x) && x.arguments.length === 0;\r\n}\r\n\r\n//noinspection JSUnusedLocalSymbols\r\nexport function isTeXEnv(x: any, name?: string): x is TeXEnv {\r\n    return isTypeHaving(x, typeTeXEnv)\r\n        ;\r\n}\r\n\r\nexport function isTeXMath(x: any): x is TeXMath {\r\n    return isLaTeXHaving(x) && isTypeHaving(x) && isMathType(x.type);\r\n}\r\n\r\nexport function isTeXLineBreak(x: any): x is TeXLineBreak {\r\n    return x !== undefined && typeof x.noNewPage === \"boolean\" && (x.measure === undefined || isMeasure(x.measure));\r\n}\r\n\r\nexport function isSubOrSuperScript(x: any): x is SubOrSuperScript {\r\n    return isSubOrSuperSymbol(x.type);\r\n}\r\n\r\nexport function isTeXBraces(x: any): x is TeXBraces {\r\n    return isLaTeXHaving(x) && isTypeHaving(x, typeTeXBraces);\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function isFixArg(x: any): x is FixArg {\r\n    return isTypeHaving(x, \"FixArg\");\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function isOptArg(x: any): x is OptArg {\r\n    return isTypeHaving(x, \"OptArg\");\r\n}\r\n\r\nexport function isTeXComment(x: any): x is TeXComment {\r\n    return isTextHaving(x) && isTypeHaving(x, typeTeXComment);\r\n}\r\n\r\n\r\n// export function isTeXSeq(x: any): x is TeXSeq {\r\n//     return x !== undefined && x.head && x.tail\r\n//         && isTypeHaving(x, typeTeXSeq)\r\n//         ;\r\n// }\r\n\r\nexport function isTeXEmpty(e: any) {\r\n    return e !== undefined && Object.keys(e).length === 0;\r\n}\r\n\r\n//\r\n// constructors\r\n//\r\nexport type LaTeXTxt = LaTeXRaw | TeXChar;\r\n\r\nexport function newFixArg(l: LaTeXTxt[]): FixArg {\r\n    return {type: \"FixArg\", latex: l};\r\n}\r\n\r\nexport function newOptArg(l: LaTeXTxt[]): MOptArg | OptArg {\r\n    return l.length === 1 ? {type: \"OptArg\", latex: l} : {type: \"MOptArg\", latex: l};\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function newSymArg(l: LaTeXRaw): SymArg {\r\n    return {type: \"SymArg\", latex: [l]};\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function newParArg(l: LaTeXRaw): ParArg {\r\n    return {type: \"ParArg\", latex: [l]};\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function newMOptArg(l: LaTeXRaw[]): MOptArg {\r\n    return {type: \"MOptArg\", latex: l};\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function newMSymArg(l: LaTeXRaw[]): MSymArg {\r\n    return {type: \"MSymArg\", latex: l};\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function newMParArg(l: LaTeXRaw[]): MParArg {\r\n    return {type: \"MParArg\", latex: l};\r\n}\r\n\r\n/**\r\n Constructor for commands with no arguments.\r\n */ //noinspection JSUnusedGlobalSymbols\r\nexport function newCommandS(name: string): TeXCommS {\r\n    return {\r\n        name,\r\n        arguments: [],\r\n        type: typeTeXCommS\r\n    };\r\n}\r\n\r\n\r\nexport function newTeXRaw(text: string): TeXRaw {\r\n    return {\r\n        text,\r\n        type: typeTeXRaw,\r\n        characterCategories: convertToTeXCharsDefault(text)\r\n    };\r\n}\r\n\r\nexport function newTeXMath(type: MathType, startSymbol: string, endSymbol: string, latex: LaTeXRaw[]): TeXMath {\r\n    return {\r\n        latex,\r\n        type,\r\n        startSymbol,\r\n        endSymbol\r\n    };\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function newTeXBraces(latex: LaTeXRaw): TeXBraces {\r\n    return {\r\n        latex: [latex],\r\n        type: typeTeXBraces\r\n    };\r\n}\r\n\r\nexport const newTeXMathDol: (l: LaTeXRaw[]) => TeXMath = function (latex: LaTeXRaw[]) {\r\n    return newTeXMath(\"Dollar\", \"$\", \"$\", latex);\r\n};\r\n\r\nexport function newTeXComment(text: string): TeXComment {\r\n    return {\r\n        text,\r\n        type: typeTeXComment\r\n    };\r\n}\r\n\r\n\r\n/** Constructor for commands.\r\n * First argument is the name of the command.\r\n * Second, its arguments.*/\r\nexport function newTeXComm(name: string, ...args: TeXArg[]): TeXComm {\r\n    return {\r\n        name,\r\n        arguments: args,\r\n        type: typeTeXComm\r\n    };\r\n}\r\n\r\nexport function newSubOrSuperScript(type: SubOrSuperSymbol,\r\n                                    symbol: string,\r\n                                    args?: TeXArg[]): SubOrSuperScript {\r\n    return {\r\n        type,\r\n        symbol,\r\n        arguments: args\r\n    };\r\n}\r\n\r\n/**\r\n * Constructor for environments.\r\n * First argument is the name of the environment.\r\n * Second, its content.\r\n * Third, its arguments.\r\n */\r\nexport function newTeXEnv(name: string, latex: LaTeXRaw[], ...args: TeXArg[]): TeXEnv {\r\n    return {\r\n        name,\r\n        latex,\r\n        arguments: args,\r\n        type: typeTeXEnv\r\n    };\r\n}\r\n\r\n// export function cleanTexRaw(tex: LaTeX[]): LaTeXNoRaw[] {\r\n//     let newArray: LaTeXNoRaw[] = [];\r\n//     tex.forEach(tex => {\r\n//         if (isTeXRaw(tex))\r\n//             newArray = newArray.concat(convertToTeXChars(\r\n//                 uni => defaultCategories(uni),\r\n//                 tex.text\r\n//             ));\r\n//         else if (isTeXComm(tex)) {\r\n//             const newArgs: LaTeXNoRaw[] = cleanTexRaw(tex.arguments);\r\n//             newArray.push(newTeXComm(tex.name, newArgs));\r\n//         }\r\n//         else if (isTeXEnv(tex)) newArray.push(newTeXEnv());\r\n//         else if (isTeXMath(tex)) newArray.push(newTeXMath());\r\n//         else if (isTeXBraces(tex)) newArray.push(newTeXBraces());\r\n//         else if (isTeXComment(tex)) newArray.push(newTeXComment());\r\n//         else newArray.push(tex);\r\n//     });\r\n//     return newArray;\r\n// }\r\n\r\nexport function stringifyLaTeX(tex: LaTeX | TeXArg): string {\r\n    const arr: string[] = [];\r\n    (stringifyLaTeXInner(tex, arr));\r\n    return arr.join(\"\");\r\n}\r\n\r\nfunction stringifyLaTeXInner(tex: LaTeX | TeXArg, soFar: string[]): void {\r\n    if (isTeXComm(tex)) {\r\n        soFar.push(\"\\\\\", tex.name);\r\n        tex.arguments.forEach(l => stringifyLaTeXInner(l, soFar));\r\n    }\r\n    else if (isTeXEnv(tex))\r\n        throw new Error(\"not supported yet\");\r\n    else if (isTeXMath(tex)) {\r\n        soFar.push(tex.startSymbol);\r\n        tex.latex.forEach(t => stringifyLaTeXInner(t, soFar));\r\n        soFar.push(tex.endSymbol);\r\n    }\r\n    else if (isTeXLineBreak(tex))\r\n        soFar.push(\"\\n\");\r\n    else if (isSubOrSuperScript(tex)) {\r\n        soFar.push(tex.symbol);\r\n        if (tex.arguments)\r\n            tex.arguments.forEach(arg => (stringifyLaTeXInner(arg, soFar)));\r\n    } else if (isTeXBraces(tex)) {\r\n        soFar.push(\"{\");\r\n        tex.latex.forEach(t => stringifyLaTeXInner(t, soFar));\r\n        soFar.push(\"}\");\r\n    } else if (isTeXComment(tex)) {\r\n        soFar.push(\"%\" + tex.text + \"\\n\");\r\n    } else if (isTeXRaw(tex))\r\n        soFar.push(tex.text);\r\n    else if (isTeXChar(tex))\r\n        throw new Error(\"not supported yet\");\r\n    else if (isFixArg(tex)) {\r\n        soFar.push(\"{\");\r\n        tex.latex.forEach(t => stringifyLaTeXInner(t, soFar));\r\n        soFar.push(\"}\");\r\n    }\r\n    else if (isOptArg(tex)) {\r\n        soFar.push(\"[\");\r\n        tex.latex.forEach(t => stringifyLaTeXInner(t, soFar));\r\n        soFar.push(\"]\");\r\n    } else throw new Error(\"Did not recognize \" + JSON.stringify(tex));\r\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/Text/LaTeX/Base/Syntax.ts","// general JavaScript utils\r\nexport * from \"./Utils\";\r\n\r\n// LaTeX\r\nexport * from \"./Text/LaTeX/Base/Syntax\";\r\nexport * from \"./Text/LaTeX/Base/Parser\";\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/main.ts","/**\r\n * TeXBook, Chapter 7: How TEX Reads What You Type, p. 37:\r\n *\r\n * > In the first place, it’s wise to have a precise idea of what your keyboard\r\n *   sends to the machine. There are 256 characters that TEX might encounter at\r\n *   each step, in a file or in a line of text typed directly on your terminal. These\r\n *   256 characters are classified into 16 categories numbered 0 to 15:\r\n */\r\nexport type CharacterCategory =\r\n    0 | // \"Escape character\", // \\\r\n    1 | // \"Beginning of group\", // {\r\n    2 | // \"End of group\", // }\r\n    3 | // \"Math shift\", // $\r\n    4 | // \"Alignment tab\", // &\r\n    5 | // \"End of line\", // [RETURN]\r\n    6 | // \"Parameter\", // #\r\n    7 | // \"Superscript\", // ^\r\n    8 | // \"Subscript\", // _\r\n    9 | // \"Ignored character\", // [NULL]\r\n    10 | // \"Space\", // \" \"\r\n    11 | // \"Letter\", // A, . . . , Z and a, . . . , z)\r\n    12 | // \"Other character\", // none of the above or below\r\n    13 | // \"Active character\", // ~\r\n    14 | // \"Comment character\", // %\r\n    15  // \"Invalid character\", // [DEL]\r\n    ;\r\n\r\n// TODO character code can be changed at any time. A full parser must deal with that.\r\n\r\nexport const defaultCategories = (char: string,\r\n                                  // strictAboutLetters: boolean = false // TODO\r\n): CharacterCategory => {\r\n    switch (char) {\r\n        case \"\\\\\" :\r\n            return 0;\r\n        case \"{\":\r\n            return 1;\r\n        case \"}\":\r\n            return 2;\r\n        case \"$\":\r\n            return 3;\r\n        case \"&\":\r\n            return 4;\r\n        case \"\\r\":\r\n            return 5;\r\n        case \"#\":\r\n            return 6;\r\n        case \"^\":\r\n            return 7;\r\n        case \"_\":\r\n            return 8;\r\n        case \"\\0\":\r\n            return 9;\r\n        case \" \":\r\n            return 10;\r\n        case \"~\":\r\n            return 13;\r\n        case \"%\":\r\n            return 14;\r\n        case \"\\d\":\r\n            return 15;\r\n        default:\r\n            return 11; // Assume letter\r\n        // if (\r\n        //     (unicodePointer >= 97 && unicodePointer <= 122) // a-z\r\n        //     ||\r\n        //     (unicodePointer >= 65 && unicodePointer <= 90) // A-Z\r\n        // ) {\r\n        //     return 11; // strictly [a-zA-Z]\r\n        // } else if() {\r\n        // }\r\n        // return 12; // Other character\r\n    }\r\n};\r\n\r\nexport interface TeXChar {\r\n    string: string;\r\n    category: CharacterCategory;\r\n}\r\n\r\nexport function convertToTeXCharsDefault(str: string): TeXChar[] {\r\n    return convertToTeXChars(defaultCategories, str);\r\n}\r\n\r\nexport function convertToTeXChars(categoryMap: (unicode: string) => CharacterCategory,\r\n                                  str: string): TeXChar[] {\r\n    const chars: TeXChar[] = [];\r\n    for (let i = 0; i < str.length; i++) {\r\n        const charAt = str.charAt(i);\r\n        chars.push({\r\n            string: charAt,\r\n            category: categoryMap(charAt)\r\n        });\r\n    }\r\n    return chars;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/Text/TeX/CategoryCode.ts","// <reference types=\"../../../../../../types/parsimmon.d.ts\" />\r\n\r\nimport {\r\n    alt,\r\n    regexp,\r\n    string,\r\n    Parser,\r\n    lazy,\r\n    takeWhile,\r\n    Success,\r\n    Result,\r\n    seqMap,\r\n    ResultInterface,\r\n    makeSuccess,\r\n    Failure,\r\n    test\r\n} from \"parsimmon\";\r\n\r\nimport {\r\n    FixArg,\r\n    LaTeXRaw,\r\n    MathType, MOptArg,\r\n    newFixArg,\r\n    newOptArg,\r\n    newSubOrSuperScript,\r\n    newTeXComm,\r\n    newTeXComment,\r\n    newTeXEnv,\r\n    newTeXMath,\r\n    OptArg, SubOrSuperScript, SubOrSuperSymbol,\r\n    TeXArg,\r\n    TeXComm,\r\n    TeXComment,\r\n    TeXEnv,\r\n    TeXMath\r\n} from \"./Syntax\";\r\nimport {TeXRaw} from \"./Syntax\";\r\nimport {newTeXRaw} from \"./Syntax\";\r\nimport {\r\n    mustBeNumber,\r\n    mustNotBeUndefined\r\n} from \"../../../Utils\";\r\nimport {makeFailure} from \"parsimmon\";\r\nimport {LatexMode} from \"../../../../deprecated/lib/Latex/Mode\";\r\n\r\n/** The /LaTeX/ parser.\r\n\r\n Use 'parseLaTeX' to parse a 'Text' containing /LaTeX/ code.\r\n If the 'Text' is in a file, you may want to use 'parseLaTeXFile'.\r\n Use this module together with \"Text.LaTeX.Base.Syntax\" to perform\r\n analysis and transformations of /LaTeX/ code. The parser ('parseLaTeX')\r\n is related with the renderer ('render') by the following property:\r\n\r\n /If @t :: Text@ is a syntactically valid LaTeX block, then:/\r\n\r\n > fmap render (parseLaTeX t) == Right t\r\n\r\n This property says two things:\r\n\r\n * Given a valid LaTeX input, 'parseLaTeX' returns a 'LaTeX' value.\r\n * If the parsed value is again rendered, you get the initial input.\r\n\r\n In other words, 'parseLaTeX' is a partial function defined over the\r\n set of valid LaTeX files, and 'render' is its /left/ inverse.\r\n */\r\n\r\n//     -- * The parser\r\n//     parseLaTeX\r\n//   , parseLaTeXFile\r\n//     -- * Parsing errors\r\n//   , ParseError\r\n//   , errorPos\r\n//   , errorMessages\r\n//     -- ** Error messages\r\n//   , Message (..)\r\n//   , messageString\r\n//     -- ** Source positions\r\n//   , SourcePos\r\n//   , sourceLineKeep in mind that automatic inclusion is only important if you’re using files with global declarations (as opposed to files declared as modules). If you use an import \"foo\" statement, for instance, TypeScript may still look through node_modules & node_modules/types folders to find the foo package.\r\n\r\n\r\n//   , sourceColumn\r\n//   , sourceName\r\n//     -- * Configuring your parser\r\n//   , ParserConf (..)\r\n//   , defaultParserConf\r\n//   , parseLaTeXWith\r\n//   , parseLaTeXFileWith\r\n//     -- * Parser combinators\r\n//   , Parser\r\n//   , latexParser\r\n//   , latexBlockParser\r\n//     ) where\r\n//\r\n// import           Text.Parsec hiding ((<|>),many)\r\n// import           Text.Parsec.Error\r\n// import           Data.Char (toLower,digitToInt)\r\n// import           Data.Monoid\r\n// import           Data.Maybe (fromMaybe)\r\n// import qualified Data.Text as T\r\n//\r\n// import           Control.Applicative\r\n// import           Control.Monad (unless)\r\n//\r\n// import           Text.LaTeX.Base.Syntax\r\n// import           Text.LaTeX.Base.Render\r\n\r\n//\r\n// Parser configuration\r\n//\r\n\r\n/** Configuration for the LaTeX parser.*/\r\nexport interface ParserConf {\r\n    /**  This is the list of names of the environments such that\r\n     their content will be parsed verbatim.*/\r\n    verbatimEnvironments: String[];\r\n}\r\n\r\n/** Default parser configuration, used by 'parseLaTeX' and 'parseLaTeXFile'.\r\n\r\n Defaults:\r\n\r\n > verbatimEnvironments = [\"verbatim\"]\r\n */\r\nexport const defaultParserConf: ParserConf = {\r\n    verbatimEnvironments: [\"verbatim\"]\r\n};\r\n\r\n/**\r\n * Parser with 'Text' input and 'ParserConf' environment.\r\n */\r\n// type Parser<T> = Parsec Text ParserConf;\r\n\r\n//\r\n// Parser\r\n//\r\n\r\n// /** Parse a 'Text' sequence as a 'LaTeX' block. If it fails, it returns\r\n//  an error string.*/\r\n// export const parseLaTeX = (s: string): (ParseError | LaTeX) => {\r\n//     return parseLaTeXWith(defaultParserConf, s);\r\n// };\r\n//\r\n\r\n//\r\n// export const parseLaTeX = (conf: ParserConf, t: string): (ParseError | LaTeX) => {\r\n//     return t === \"\" ? {} : runParser(latexParser,conf,\"parseLaTeX input\",t);\r\n// };\r\n\r\n// /** Read a file and parse it as 'LaTeX'.*/\r\n// // TODO\r\n//\r\n// // export const parseLaTeXFile = (FilePath): IO (ParseError | LaTeX) => {\r\n// // }\r\n// // parseLaTeXFile = parseLaTeXFileWith defaultParserConf\r\n// // parseLaTeXFileWith :: ParserConf -> FilePath -> IO (Either ParseError LaTeX)\r\n// // parseLaTeXFileWith conf fp = runParser latexParser conf fp <$> readFileTex fp\r\n//\r\n// /** The 'LaTeX' parser.*/\r\n// // latexParser :: Parser LaTeX\r\n// // latexParser = mconcat <$> latexBlockParser `manyTill` eof\r\n//\r\n\r\nexport const takeTill = (predicate: ((c: string) => boolean)) => takeWhile((c) => !predicate(c));\r\n\r\nconst takeTillNewline = regexp(/[^\\n]*/);\r\nconst maybeNewline = regexp(/\\n?/);\r\nconst whitespace = regexp(/\\s*/m);\r\nconst commentSymbol = string(\"%\");\r\n\r\n/**\r\n Returns the sorted set union of two arrays of strings. Note that if both\r\n arrays are empty, it simply returns the first array, and if exactly one\r\n array is empty, it returns the other one unsorted. This is safe because\r\n expectation arrays always start as [] or [x], so as long as we merge with\r\n this function, we know they stay in sorted order.\r\n */\r\nfunction unsafeUnion(xs: any[], ys: any[]) {\r\n    // Exit early if either array is empty (common case)\r\n    const xn = xs.length;\r\n    const yn = ys.length;\r\n    if (xn === 0) {\r\n        return ys;\r\n    } else if (yn === 0) {\r\n        return xs;\r\n    }\r\n    // Two non-empty arrays: do the full algorithm\r\n    const obj: any = {};\r\n    for (let i = 0; i < xn; i++) {\r\n        obj[xs[i]] = true;\r\n    }\r\n    for (let j = 0; j < yn; j++) {\r\n        obj[ys[j]] = true;\r\n    }\r\n    const keys = [];\r\n    for (const k in obj) {\r\n        if (obj.hasOwnProperty(k)) {\r\n            keys.push(k);\r\n        }\r\n    }\r\n    keys.sort();\r\n    return keys;\r\n}\r\n\r\nfunction mergeReplies<T, U>(result: ResultInterface<T>, last?: ResultInterface<U>): ResultInterface<T> {\r\n    if (!last) {\r\n        return result;\r\n    }\r\n    if (result.furthest > last.furthest) {\r\n        return result;\r\n    }\r\n    const expected = (result.furthest === last.furthest)\r\n        ? unsafeUnion(result.expected, last.expected)\r\n        : last.expected;\r\n    return {\r\n        status: result.status,\r\n        index: result.index,\r\n        value: result.value,\r\n        furthest: last.furthest,\r\n        expected: expected\r\n    };\r\n}\r\n\r\nfunction manyTillAndMap<T, U, V>(manyOf: Parser<T>, till: Parser<U>, map: (acc: V, res: (T)) => V, initial: V) {\r\n    return Parser(function (input: string, i: number): Result<V> {\r\n        let accum: V = initial;\r\n\r\n        let j = 0;\r\n        let result: ResultInterface<T> | undefined = undefined;\r\n\r\n        // let lengthUntilEnd = -1;\r\n        //\r\n        // for (let o = i; o < input.length; o++) {\r\n        //     const endCodonFound = till._(input, o);\r\n        //     if (endCodonFound.status) {\r\n        //         input = input.substring(0, o);\r\n        //         lengthUntilEnd = mustBeNumber(endCodonFound.index);\r\n        //         break;\r\n        //     }\r\n        // }\r\n        // if (lengthUntilEnd < 0) return Parsimmon.makeFailure(i, \"No end codon found: \" + till);\r\n\r\n        while (i < input.length) {\r\n            const endCodonFound = till._(input, i);\r\n            if (endCodonFound.status) {\r\n                i = mustBeNumber(endCodonFound.index);\r\n                break;\r\n            }\r\n\r\n            const bigParse = manyOf._(input, i);\r\n            if (isNotOk(bigParse))\r\n                return bigParse;\r\n\r\n            result = mustNotBeUndefined(mergeReplies(bigParse, result));\r\n            if (isNotOk(result)) {\r\n                return result;\r\n                // TODO fail? test\r\n            }\r\n            j++;\r\n            const value: T = mustNotBeUndefined(result.value);\r\n\r\n            accum = map(accum, value);\r\n\r\n            i = mustBeNumber(result.index);\r\n        }\r\n        // i = lengthUntilEnd;\r\n        const result2: Success<V> = makeSuccess(i, accum);\r\n        return mustBeOk(mergeReplies(result2, result));\r\n    });\r\n}\r\n\r\n// todo the functions that use this should retain start and stop indices from the input string!\r\nfunction manyTill<T, U>(manyOf: Parser<T>, till: Parser<U>) {\r\n    return manyTillAndMap(manyOf, till, (a: T[], el: T) => a.concat([el]), <T[]>[]);\r\n\r\n    // return Parsimmon(function (input: string, i: number): Result<T[]> {\r\n    //     const accum: T[] = [];\r\n    //\r\n    //     let j = 0;\r\n    //     let result: ResultInterface<T> | undefined = undefined;\r\n    //\r\n    //     let endCodonFound = till._(input, i);\r\n    //     if (endCodonFound.status) {\r\n    //         i = mustBeNumba(endCodonFound.index);\r\n    //     }\r\n    //     while (!endCodonFound.status) {\r\n    //         const bigParse = manyOf._(input, i);\r\n    //         result = mustNotBeUndefined(mergeReplies(bigParse, result));\r\n    //         if (isNotOk(result)) {\r\n    //             return result;\r\n    //         }\r\n    //         j++;\r\n    //         const value: T = mustNotBeUndefined(result.value);\r\n    //         accum.push(value);\r\n    //         i = mustBeNumba(result.index);\r\n    //         endCodonFound = till._(input, i);\r\n    //         if (endCodonFound.status) {\r\n    //             i = mustBeNumba(endCodonFound.index);\r\n    //             break;\r\n    //         }\r\n    //     }\r\n    //\r\n    //     const result2: Success<T[]> = makeSuccess(i, accum);\r\n    //     return mustBeOk(mergeReplies(result2, result));\r\n    // });\r\n}\r\n\r\nfunction token(parser: Parser<string>): Parser<string> {\r\n    return parser.skip(whitespace);\r\n}\r\n\r\n// Several parsers are just strings with optional whitespace.\r\nfunction word(str: string): Parser<string> {\r\n    return string(str).thru(token);\r\n}\r\n\r\n\r\nconst lbrace = \"{\";\r\nconst rbrace = \"}\";\r\nconst lbracket = \"[\";\r\nconst rbracket = \"]\";\r\n//noinspection JSUnusedLocalSymbols\r\nconst comma = \",\";\r\n//noinspection JSUnusedLocalSymbols\r\nconst colon = \":\";\r\n\r\nconst openingBracket = string(lbracket);\r\nconst closingBracket = string(rbracket);\r\n//noinspection JSUnusedLocalSymbols\r\nconst isClosingbracket = (str: string) => str === (rbracket);\r\n\r\nexport const notTextDefault = {\r\n    \"$\": true,\r\n    \"%\": true,\r\n    \"\\\\\": true,\r\n    \"{\": true,\r\n    \"]\": true,\r\n    \"}\": true\r\n};\r\n\r\nexport const notTextMathMode = {\r\n    \"^\": true,\r\n    \"_\": true,\r\n\r\n    \"$\": true,\r\n    \"%\": true,\r\n    \"\\\\\": true,\r\n    \"{\": true,\r\n    \"]\": true,\r\n    \"}\": true\r\n};\r\n\r\nexport const notTextMathModeAndNotClosingBracket = {\r\n    \"^\": true,\r\n    \"_\": true,\r\n\r\n    \"$\": true,\r\n    \"%\": true,\r\n    \"\\\\\": true,\r\n    \"{\": true,\r\n    \"}\": true\r\n};\r\n\r\nexport const notTextDefaultAndNotClosingBracket = {\r\n    \"$\": true,\r\n    \"%\": true,\r\n    \"\\\\\": true,\r\n    \"{\": true,\r\n    \"}\": true\r\n};\r\n\r\nfunction takeAtLeastOneTill(till: (s: string) => boolean): Parser<string> {\r\n    return Parser((str, i): Result<string> => {\r\n        const firstChar = str.charAt(i);\r\n        if (i >= str.length || till(firstChar)) {\r\n            return makeFailure(i, \"text character\");\r\n        } else {\r\n            const strz = [firstChar];\r\n            i++;\r\n            let char = str.charAt(i);\r\n            while (!till(char) && i < str.length) {\r\n                strz.push(char);\r\n                i++;\r\n                char = str.charAt(i);\r\n            }\r\n            return makeSuccess(i, strz.join(\"\"));\r\n        }\r\n    });\r\n}\r\n\r\nexport function textParser(notText: { [k: string]: boolean }) {\r\n    return takeAtLeastOneTill(isNotText(notText))\r\n        .map(match => newTeXRaw(match))\r\n        ;\r\n}\r\n\r\n/** Text is a sequence on characters that are not non-text*/\r\n// TODO use character codes\r\nconst text = textParser(notTextDefault);\r\n\r\n/**\r\n * Text without stopping on ']'\r\n */\r\nconst text2 = textParser(notTextDefaultAndNotClosingBracket);\r\n\r\nconst spaces: Parser<TeXRaw> = regexp(/ */)\r\n    .map(newTeXRaw);\r\n\r\n\r\n/** Comment\r\n *\r\n *  > % this is a comment`\r\n *\r\n * NOTE:\r\n *\r\n *  Q: When a line ends with a comment character like %,\r\n *     are spaces ignored at the beginning of the next line?\r\n *\r\n *  A: Yes; characters of category 10 are ignored at the\r\n *     beginning of every line, since every line starts in state N.\r\n *\r\n * We get this for free with ignoring the spaces\r\n */\r\nexport const comment: Parser<TeXComment> =\r\n    commentSymbol\r\n        .then(takeTillNewline)\r\n        .skip(maybeNewline)\r\n        .map(newTeXComment)\r\n;\r\n\r\n// Helpers\r\nexport const specialCharsDefault = {\r\n    \"'\": true,\r\n    \"(\": true,\r\n    \")\": true,\r\n    \",\": true,\r\n    \".\": true,\r\n    \"-\": true,\r\n    '\"': true,\r\n    \"!\": true,\r\n    \"^\": true,\r\n    \"$\": true,\r\n    \"&\": true,\r\n    \"#\": true,\r\n    \"{\": true,\r\n    \"}\": true,\r\n    \"%\": true,\r\n    \"~\": true,\r\n    \"|\": true,\r\n    \"/\": true,\r\n    \":\": true,\r\n    \";\": true,\r\n    \"=\": true,\r\n    \"[\": true,\r\n    \"]\": true,\r\n    \"\\\\\": true,\r\n    \"`\": true,\r\n    \" \": true\r\n};\r\n\r\nexport function isSpecialCharacter(char: string, specialChars?: { [k: string]: boolean }) {\r\n    const chars = specialChars === undefined ? specialCharsDefault : specialChars;\r\n    return chars.hasOwnProperty(char);\r\n}\r\n\r\n\r\nexport function isNotText(notText: { [k: string]: boolean }) {\r\n    return (char: string) => notText.hasOwnProperty(char);\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport const mathSymbol = string(\"$\");\r\n\r\nexport const commandSymbol = string(\"\\\\\");\r\n\r\nexport function latexBlockParser(mode: LatexMode, sub = \"_\", sup = \"^\"): Parser<LaTeXRaw> {\r\n    switch (mode) {\r\n        case \"Math\":\r\n            return latexBlockParserMathMode(sub, sup);\r\n        default:\r\n            return latexBlockParserTextMode;\r\n    }\r\n}\r\n\r\n/**\r\n * Parser of a single 'LaTeX' block. Note: text stops on ']'; if the other parsers fail on the rest,\r\n * text2 handles it, starting with ']'\r\n */\r\nexport const latexBlockParserTextMode: Parser<LaTeXRaw> = lazy(() => alt(\r\n    alt(\r\n        textParser(notTextDefault) // <?> \"text\"\r\n        , dolMath         // <?> \"inline math ($)\"\r\n        , comment         // <?> \"comment\"\r\n        , textParser(notTextDefaultAndNotClosingBracket)           // <?> \"text2\"\r\n        , environment     // <?> \"environment\"\r\n        , command(\"Paragraph\")         // <?> \"command\"\r\n    )\r\n    )\r\n);\r\n\r\nexport const latexBlockParserMathMode = (sub: string, sup: string): Parser<LaTeXRaw> => {\r\n    return lazy(() => alt(\r\n        alt(\r\n            shiftedScript(\"Math\", sub, sup)\r\n            , textParser(notTextMathMode)                               // <?> \"text\"\r\n            , dolMath                                                   // <?> \"inline math ($)\"\r\n            , comment                                                   // <?> \"comment\"\r\n            , textParser(notTextMathModeAndNotClosingBracket)           // <?> \"text2\"\r\n            , environment                                               // <?> \"environment\"\r\n            , command(\"Math\")                                                   // <?> \"command\"\r\n        )\r\n        )\r\n    );\r\n};\r\n\r\nexport const latexParser: Parser<LaTeXRaw[]> = latexBlockParserTextMode.many();\r\n\r\nconst anonym = string(lbrace)\r\n    .then(\r\n        latexBlockParserTextMode.many()\r\n    )\r\n    .skip(string(rbrace));\r\n\r\nexport const env = Parser(function (input: string, i: number): Result<TeXEnv> {\r\n    const beginFound = string(\"\\\\begin\")\r\n        .then(string(lbrace))\r\n        .then(spaces)\r\n        .then(regexp(/[a-zA-Z]+/))  // envName\r\n        .skip(spaces)\r\n        .skip(string(rbrace))\r\n        ._(input, i);\r\n    if (isNotOk(beginFound))\r\n        return beginFound;\r\n\r\n    i = mustBeNumber(beginFound.index);\r\n    const envName: string = beginFound.value;\r\n\r\n    // TODO args\r\n\r\n    return manyTill(latexBlockParserTextMode, string(\"\\\\end\")\r\n        .then(string(lbrace))\r\n        .then(spaces)\r\n        .then(string(envName))\r\n        .then(spaces)\r\n        .then(string(rbrace))\r\n    ).map(latex => newTeXEnv(envName, latex))._(input, i);\r\n});\r\n\r\nexport const environment = alt(anonym, env);\r\n\r\n/**\r\n * Special commands (consisting of one char)\r\n */\r\nexport const specialChar = test(isSpecialCharacter);\r\n\r\nfunction isUppercaseAlph(c: string) {\r\n    return c >= \"A\" && c <= \"Z\";\r\n}\r\n\r\nfunction isLowercaseAlph(c: string) {\r\n    return c >= \"a\" && c <= \"z\";\r\n}\r\n\r\nexport const endCmd = (c: string) => !isLowercaseAlph(c) && !isUppercaseAlph(c);\r\n\r\nconst openingBrace = string(\"{\");\r\nconst closingBrace = string(\"}\");\r\n\r\nconst isClosingBrace = (str: string) => str === (\"}\");\r\n\r\nexport function fixArg(mode: LatexMode): Parser<FixArg> {\r\n    return openingBrace\r\n        .then(\r\n            manyTill(latexBlockParser(mode, \"_\"), closingBrace)\r\n        ).map(newFixArg);\r\n}\r\n\r\nexport function optArg(mode: LatexMode): Parser<MOptArg | OptArg> {\r\n    return openingBracket\r\n        .then(\r\n            manyTill(latexBlockParser(mode), closingBracket)\r\n        )\r\n        .map(newOptArg);\r\n}\r\n\r\nexport function cmdArg(mode: LatexMode): Parser<TeXArg> {\r\n    return alt(\r\n        fixArg(mode),\r\n        optArg(mode)\r\n        // => newTeXArg(str)\r\n    );\r\n}\r\n\r\n/**\r\n * Command Arguments\r\n */\r\nexport function cmdArgs(mode: LatexMode): Parser<TeXArg[] | undefined> {\r\n    return alt(\r\n        string(\"{}\").map(() => []),\r\n\r\n        cmdArg(mode).map(s => s).atLeast(0)\r\n    ).map(e => e);\r\n}\r\n\r\n// cmdArgs = try (string \"{}\" >> return (Just []))\r\n// <|> fmap Just (try $ many1 cmdArg)\r\n// <|> return Nothing\r\n\r\n// cmdArg :: Parser TeXArg\r\n// cmdArg = do\r\n// c <- char '[' <|> char '{'\r\n// let e = case c of\r\n// '[' -> \"]\"\r\n// '{' -> \"}\"\r\n// _   -> error \"this cannot happen!\"\r\n// b <- mconcat <$> manyTill latexBlockParser (string e)\r\n// case c of\r\n// '[' -> return $ OptArg b\r\n// '{' -> return $ FixArg b\r\n// _   -> error \"this cannot happen!\"\r\n\r\n/**\r\n * Command\r\n */\r\nexport function command(mode: LatexMode): Parser<TeXComm> { // alt(\r\n    // commandSymbol.then(eof).map(() => {\r\n    //     return {};\r\n    // }),\r\n    return seqMap(\r\n        commandSymbol,\r\n        alt(specialChar, takeTill(endCmd)),\r\n        cmdArgs(mode),\r\n\r\n        function (ignored, name, argz) {\r\n            return argz !== undefined ? newTeXComm(name, ...argz) : newTeXComm(name);\r\n        }\r\n    ).map(res => {\r\n        return res;\r\n    });\r\n}\r\n\r\nexport const subOrSuperscriptSymbolParser: (a: string, b: string) => Parser<SubOrSuperSymbol> = function (subscriptSymbol, superscriptSymbol) {\r\n    return alt(\r\n        string(subscriptSymbol),\r\n        string(superscriptSymbol)\r\n    ).map(parsedStr => (parsedStr === subscriptSymbol ? SubOrSuperSymbol.SUB : SubOrSuperSymbol.SUP));\r\n};\r\n\r\n/**\r\n * (sub/super)-script\r\n */\r\nexport function shiftedScript(mode: LatexMode, sub: string, sup: string): Parser<SubOrSuperScript> { // alt(\r\n        return seqMap(\r\n            subOrSuperscriptSymbolParser(sub, sup),\r\n            cmdArgs(mode),\r\n\r\n            function (symbol, argz) {\r\n                return newSubOrSuperScript(\r\n                    symbol,\r\n                    symbol === SubOrSuperSymbol.SUB ? sub : sup,\r\n                    argz\r\n                );\r\n            }\r\n        ).map(res => {\r\n            return res;\r\n        });\r\n}\r\n\r\n/**\r\n * Math\r\n */\r\nexport const dolMath = math();\r\n\r\nfunction math(mathType: MathType = \"Dollar\",\r\n              sMath = \"$\",\r\n              eMath = \"$\"): Parser<TeXMath> {\r\n    return string(sMath)\r\n        .then(\r\n            latexBlockParser(\"Math\", \"_\")\r\n                .many()\r\n                .map(str => newTeXMath(mathType, sMath, eMath, str))\r\n        )\r\n        .skip(string(eMath))\r\n        ;\r\n}\r\n\r\nexport function isOk<T>(parse?: ResultInterface<T>): parse is Success<T> {\r\n    return parse !== undefined && parse.status === true;\r\n}\r\n\r\nexport function isNotOk<T>(parse?: any): parse is Failure {\r\n    return parse !== undefined && parse.status === false;\r\n}\r\n\r\nexport function mustBeOk<T>(parse?: ResultInterface<T>): Success<T> {\r\n    if (!isOk(parse))\r\n        throw new Error(\"Expected parse to be success: \" + JSON.stringify(parse));\r\n    return parse;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader!./src/Text/LaTeX/Base/Parser.ts","!function(n,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.Parsimmon=t():n.Parsimmon=t()}(this,function(){return function(n){function t(e){if(r[e])return r[e].exports;var u=r[e]={i:e,l:!1,exports:{}};return n[e].call(u.exports,u,u.exports,t),u.l=!0,u.exports}var r={};return t.m=n,t.c=r,t.i=function(n){return n},t.d=function(n,r,e){t.o(n,r)||Object.defineProperty(n,r,{configurable:!1,enumerable:!0,get:e})},t.n=function(n){var r=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(r,\"a\",r),r},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p=\"\",t(t.s=0)}([function(n,t,r){\"use strict\";function e(n){if(!(this instanceof e))return new e(n);this._=n}function u(n){return n instanceof e}function i(n){return\"[object Array]\"==={}.toString.call(n)}function o(n,t){return{status:!0,index:n,value:t,furthest:-1,expected:[]}}function a(n,t){return{status:!1,index:-1,value:null,furthest:n,expected:[t]}}function f(n,t){if(!t)return n;if(n.furthest>t.furthest)return n;var r=n.furthest===t.furthest?s(n.expected,t.expected):t.expected;return{status:n.status,index:n.index,value:n.value,furthest:t.furthest,expected:r}}function c(n,t){var r=n.slice(0,t).split(\"\\n\");return{offset:t,line:r.length,column:r[r.length-1].length+1}}function s(n,t){var r=n.length,e=t.length;if(0===r)return t;if(0===e)return n;for(var u={},i=0;i<r;i++)u[n[i]]=!0;for(var o=0;o<e;o++)u[t[o]]=!0;var a=[];for(var f in u)u.hasOwnProperty(f)&&a.push(f);return a.sort(),a}function l(n){if(!u(n))throw new Error(\"not a parser: \"+n)}function h(n){if(!i(n))throw new Error(\"not an array: \"+n)}function p(n){if(\"number\"!=typeof n)throw new Error(\"not a number: \"+n)}function d(n){if(!(n instanceof RegExp))throw new Error(\"not a regexp: \"+n);for(var t=w(n),r=0;r<t.length;r++){var e=t.charAt(r);if(\"i\"!==e&&\"m\"!==e&&\"u\"!==e)throw new Error('unsupported regexp flag \"'+e+'\": '+n)}}function v(n){if(\"function\"!=typeof n)throw new Error(\"not a function: \"+n)}function g(n){if(\"string\"!=typeof n)throw new Error(\"not a string: \"+n)}function m(n){return 1===n.length?n[0]:\"one of \"+n.join(\", \")}function y(n,t){var r=t.index,e=r.offset;if(e===n.length)return\", got the end of the input\";var u=e>0?\"'...\":\"'\",i=n.length-e>12?\"...'\":\"'\";return\" at line \"+r.line+\" column \"+r.column+\", got \"+u+n.slice(e,e+12)+i}function x(n,t){return\"expected \"+m(t.expected)+y(n,t)}function w(n){var t=\"\"+n;return t.slice(t.lastIndexOf(\"/\")+1)}function E(n){return RegExp(\"^(?:\"+n.source+\")\",w(n))}function _(){for(var n=[].slice.call(arguments),t=n.length,r=0;r<t;r+=1)l(n[r]);return e(function(r,e){for(var u,i=new Array(t),a=0;a<t;a+=1){if(u=f(n[a]._(r,e),u),!u.status)return u;i[a]=u.value,e=u.index}return f(o(e,i),u)})}function b(){for(var n={},t=0,r=[].slice.call(arguments),a=r.length,c=0;c<a;c+=1){var s=r[c];if(!u(s)){if(i(s)){if(2===s.length&&\"string\"==typeof s[0]&&u(s[1])){var l=s[0];if(n[l])throw new Error(\"seqObj: duplicate key \"+l);n[l]=!0,t++;continue}}throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\")}}if(0===t)throw new Error(\"seqObj expects at least one named parser, found zero\");return e(function(n,t){for(var e,u={},c=0;c<a;c+=1){var s,l;if(i(r[c])?(s=r[c][0],l=r[c][1]):(s=null,l=r[c]),e=f(l._(n,t),e),!e.status)return e;s&&(u[s]=e.value),t=e.index}return f(o(t,u),e)})}function O(){var n=[].slice.call(arguments);if(0===n.length)throw new Error(\"seqMap needs at least one argument\");var t=n.pop();return v(t),_.apply(null,n).map(function(n){return t.apply(null,n)})}function k(n){var t={};for(var r in n)({}).hasOwnProperty.call(n,r)&&function(r){var e=function(){return n[r](t)};t[r]=G(e)}(r);return t}function j(){var n=[].slice.call(arguments),t=n.length;if(0===t)return F(\"zero alternates\");for(var r=0;r<t;r+=1)l(n[r]);return e(function(t,r){for(var e,u=0;u<n.length;u+=1)if(e=f(n[u]._(t,r),e),e.status)return e;return e})}function P(n,t){return q(n,t).or(z([]))}function q(n,t){l(n),l(t);var r=t.then(n).many();return n.chain(function(n){return r.map(function(t){return[n].concat(t)})})}function A(n){g(n);var t=\"'\"+n+\"'\";return e(function(r,e){var u=e+n.length,i=r.slice(e,u);return i===n?o(u,i):a(e,t)})}function B(n,t){d(n),arguments.length>=2?p(t):t=0;var r=E(n),u=\"\"+n;return e(function(n,e){var i=r.exec(n.slice(e));if(i){if(0<=t&&t<=i.length){var f=i[0],c=i[t];return o(e+f.length,c)}return a(e,\"valid match group (0 to \"+i.length+\") in \"+u)}return a(e,u)})}function z(n){return e(function(t,r){return o(r,n)})}function F(n){return e(function(t,r){return a(r,n)})}function M(n){if(u(n))return e(function(t,r){var e=n._(t,r);return e.index=r,e.value=\"\",e});if(\"string\"==typeof n)return M(A(n));if(n instanceof RegExp)return M(B(n));throw new Error(\"not a string, regexp, or parser: \"+n)}function R(n){return l(n),e(function(t,r){var e=n._(t,r),u=t.slice(r,e.index);return e.status?a(r,'not \"'+u+'\"'):o(r,null)})}function L(n){return v(n),e(function(t,r){var e=t.charAt(r);return r<t.length&&n(e)?o(r+1,e):a(r,\"a character matching \"+n)})}function S(n){return L(function(t){return n.indexOf(t)>=0})}function W(n){return L(function(t){return n.indexOf(t)<0})}function I(n){return e(n(o,a))}function C(n,t){return L(function(r){return n<=r&&r<=t}).desc(n+\"-\"+t)}function D(n){return v(n),e(function(t,r){for(var e=r;e<t.length&&n(t.charAt(e));)e++;return o(e,t.slice(r,e))})}function G(n,t){arguments.length<2&&(t=n,n=void 0);var r=e(function(n,e){return r._=t()._,r._(n,e)});return n?r.desc(n):r}function H(){return F(\"fantasy-land/empty\")}var J=e.prototype;J.parse=function(n){if(\"string\"!=typeof n)throw new Error(\".parse must be called with a string as its argument\");var t=this.skip(T)._(n,0);return t.status?{status:!0,value:t.value}:{status:!1,index:c(n,t.furthest),expected:t.expected}},J.tryParse=function(n){var t=this.parse(n);if(t.status)return t.value;var r=x(n,t),e=new Error(r);throw e.type=\"ParsimmonError\",e.result=t,e},J.or=function(n){return j(this,n)},J.trim=function(n){return this.wrap(n,n)},J.wrap=function(n,t){return O(n,this,t,function(n,t){return t})},J.thru=function(n){return n(this)},J.then=function(n){return l(n),_(this,n).map(function(n){return n[1]})},J.many=function(){var n=this;return e(function(t,r){for(var e=[],u=void 0;;){if(u=f(n._(t,r),u),!u.status)return f(o(r,e),u);r=u.index,e.push(u.value)}})},J.tie=function(){return this.map(function(n){h(n);for(var t=\"\",r=0;r<n.length;r++)g(n[r]),t+=n[r];return t})},J.times=function(n,t){var r=this;return arguments.length<2&&(t=n),p(n),p(t),e(function(e,u){for(var i=[],a=void 0,c=void 0,s=0;s<n;s+=1){if(a=r._(e,u),c=f(a,c),!a.status)return c;u=a.index,i.push(a.value)}for(;s<t&&(a=r._(e,u),c=f(a,c),a.status);s+=1)u=a.index,i.push(a.value);return f(o(u,i),c)})},J.result=function(n){return this.map(function(){return n})},J.atMost=function(n){return this.times(0,n)},J.atLeast=function(n){return O(this.times(n),this.many(),function(n,t){return n.concat(t)})},J.map=function(n){v(n);var t=this;return e(function(r,e){var u=t._(r,e);return u.status?f(o(u.index,n(u.value)),u):u})},J.skip=function(n){return _(this,n).map(function(n){return n[0]})},J.mark=function(){return O(K,this,K,function(n,t,r){return{start:n,value:t,end:r}})},J.node=function(n){return O(K,this,K,function(t,r,e){return{name:n,value:r,start:t,end:e}})},J.sepBy=function(n){return P(this,n)},J.sepBy1=function(n){return q(this,n)},J.lookahead=function(n){return this.skip(M(n))},J.notFollowedBy=function(n){return this.skip(R(n))},J.desc=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status||(u.expected=[n]),u})},J.fallback=function(n){return this.or(z(n))},J.ap=function(n){return O(n,this,function(n,t){return n(t)})},J.chain=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status?f(n(u.value)._(r,u.index),u):u})},J.concat=J.or,J.empty=H,J.of=z,J[\"fantasy-land/ap\"]=J.ap,J[\"fantasy-land/chain\"]=J.chain,J[\"fantasy-land/concat\"]=J.concat,J[\"fantasy-land/empty\"]=J.empty,J[\"fantasy-land/of\"]=J.of,J[\"fantasy-land/map\"]=J.map;var K=e(function(n,t){return o(t,c(n,t))}),N=e(function(n,t){return t>=n.length?a(t,\"any character\"):o(t+1,n.charAt(t))}),Q=e(function(n,t){return o(n.length,n.slice(t))}),T=e(function(n,t){return t<n.length?a(t,\"EOF\"):o(t,null)}),U=B(/[0-9]/).desc(\"a digit\"),V=B(/[0-9]*/).desc(\"optional digits\"),X=B(/[a-z]/i).desc(\"a letter\"),Y=B(/[a-z]*/i).desc(\"optional letters\"),Z=B(/\\s*/).desc(\"optional whitespace\"),$=B(/\\s+/).desc(\"whitespace\");e.all=Q,e.alt=j,e.any=N,e.createLanguage=k,e.custom=I,e.digit=U,e.digits=V,e.empty=H,e.eof=T,e.fail=F,e.formatError=x,e.index=K,e.isParser=u,e.lazy=G,e.letter=X,e.letters=Y,e.lookahead=M,e.makeFailure=a,e.makeSuccess=o,e.noneOf=W,e.notFollowedBy=R,e.of=z,e.oneOf=S,e.optWhitespace=Z,e.Parser=e,e.range=C,e.regex=B,e.regexp=B,e.sepBy=P,e.sepBy1=q,e.seq=_,e.seqMap=O,e.seqObj=b,e.string=A,e.succeed=z,e.takeWhile=D,e.test=L,e.whitespace=$,e[\"fantasy-land/empty\"]=H,e[\"fantasy-land/of\"]=z,n.exports=e}])});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/parsimmon/build/parsimmon.umd.min.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}