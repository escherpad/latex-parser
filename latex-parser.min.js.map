{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///latex-parser.min.js","webpack:///webpack/bootstrap c12892f994523ba5031c","webpack:///./sources/lib/Utils.ts","webpack:///./sources/lib/Latex.ts","webpack:///./sources/lib/LatexStyle.ts","webpack:///./sources/lib/LatexTree.ts","webpack:///./sources/lib/SyntaxTree.ts","webpack:///./sources/lib/LatexParser.ts","webpack:///./sources/main.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","updateProperties","target","values","opt_keys","opt_attributes","arguments","length","undefined","writable","TypeError","key","create","Array","forEach","targetKey","_key","testProperties","opt_skipUndefined","every","_key2","isNumber","x","isString","mustNotBeUndefined","Error","_classCallCheck","instance","Constructor","isMode","modes","mustBeMode","isOperationProperties","mustBeOperationProperties","_createClass","defineProperties","props","descriptor","protoProps","staticProps","Lexeme","BINARY_OPERATOR","BRACKETS","CELL_SEPARATOR","CHAR","DIGIT","DIRECTIVE","DISPLAY_EQUATION","FILE_PATH","FLOATING_BOX","HORIZONTAL_SKIP","INLINE_EQUATION","LABEL","LENGTH","LETTER","LINE_BREAK","LIST_ITEM","LIST","NUMBER","PARAGRAPH_SEPARATOR","PICTURE","POST_OPERATOR","PRE_OPERATOR","RAW","SPACE","SUBSCRIPT","SUPERSCRIPT","TABLE","TABULAR_PARAMETERS","TAG","UNKNOWN","VERTICAL_SKIP","WORD","WRAPPER","MATH","TEXT","VERTICAL","Directive","State","opt_initialModeStates","modeStates_","update","modeStates","modeKey","mode","BEGIN","END","GROUP","Operation","opt_initialProperties","directive","operand","other","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","setPrototypeOf","__proto__","isArray","mustBeArray","isParameterProperties","ignored","mustBeParameterProperties","isCommand","Command","mustBeCommand","isEnvironment","Environment","Symbol","Parameter","Item","LatexStyle","_typeof","iterator","obj","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_Utils","_Latex","symbols_","commands_","environments_","packageName","stylePackage","symbols","iSymbol","symbol","_Symbol","pattern","symbolPatternFirstChar","push","commands","iCommand","command","environments","iEnvironment","environment","envName","storedEnv","filteredSymbols","filter","styleItem","commandName","filteredCommands","environmentName","filteredEnvironments","state","patternFirstChar","SyntaxError","test","env","lexeme","_Item","_this","operations","map","operation","operations_","iOperation","equals","slice","_Item2","_this2","parameters","parameters_","parameter","patternComponents","match","patternComponents_","patternPart","parameterIndex","Number","substring","html","iParameter","patternComponent","join","_Symbol2","_this3","_Item3","_this4","isCommandToken","CommandToken","mustBeEnvironmentToken","isEnvironmentToken","EnvironmentToken","getBeginCommandToken","beginCommandToken","getEndCommandToken","endCommandToken","getEnvironment","_LatexStyle","SourceToken","SpaceToken","EnvironmentBodyToken","ParameterToken","SymbolToken","Token","LatexTree","_SyntaxTree2","_SyntaxTree","rootToken","source","SyntaxTree","_Node","superInitialProperties","parentNode","parentToken","childNodes","childTokens","Node","parentNodeClass_","_Token","initialProperties","skipNodeClass","nPatternChars","iPatternChar","patternChar","parameterToken","childNode","toString","_Token2","hasBrackets","hasSpacePrefix","symbolToken","childIndex","_SymbolToken","_this5","_Token3","_this6","bodyToken","beginToken","endToken","_Token4","apply","_Token5","_this8","lineBreakCount","isFinite","_Token6","_this9","default","_toConsumableArray","arr","arr2","from","rootNode","tree","insertChildSubtree","optParentNode","node","childNodes_","indexOf","childNodesToCover","nodeChildNodes","splice","subtreeSize","nodeChildNode","nodeSubtreeSize","nodeOrNodeIndex","_childNodes_","nodeChildIndex","concat","parseCommentLine_","context","commentMatch","position","comments","lineNumber","charNumber","processParsedToken_","token","currentToken","parseSpaceToken_","isSpace","nLineBreaks","_LatexTree","Context","LatexParser","latexStyle","opt_context","parsedTokens","parsedToken","parseToken_","contextBackup","copy","parseEnvironmentToken_","parseCommandToken_","parseSymbolsToken_","opt_endLabel","currentTokenBackup","updateState","spacePrefixState","parseUntilLabel_","nameMatch","currentState","environmentToken","parsePatterns_","environmentBodyToken","endFound","cmdMatch","sourceCharacter","some","parsePattern_","nPatternComponents","iPatternComponent","parameterEndLabel","parseParameterToken_","endLabel","opt_lexeme","opt_source","stateStack","opt_target","newModeStates","pop","keys","_LatexParser"],"mappings":"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","file":"latex-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.updateProperties = updateProperties;\nexports.testProperties = testProperties;\nexports.isNumber = isNumber;\nexports.isString = isString;\nexports.mustNotBeUndefined = mustNotBeUndefined;\nfunction updateProperties(target, values, opt_keys) {\n    var opt_attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { writable: true, enumerable: true, configurable: true };\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = { writable: true, enumerable: true, configurable: true };\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        }\n    } else if (opt_keys instanceof Array) {\n        opt_keys.forEach(function (key) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key = opt_keys[targetKey];\n            if (values[_key] !== undefined) Object.defineProperty(target, targetKey, Object.create(opt_attributes, { value: { value: values[_key] } }));\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\n;\nfunction testProperties(target, values, opt_keys) {\n    var opt_skipUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true;\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined)) return false;\n        }\n    } else if (opt_keys instanceof Array) {\n        return opt_keys.every(function (key) {\n            return target[key] === values[key] || values[key] === undefined && opt_skipUndefined;\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key2 = opt_keys[targetKey];\n            if (target[targetKey] !== values[_key2] && !(values[_key2] === undefined && opt_skipUndefined)) return false;\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true;\n}\n;\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction mustNotBeUndefined(x) {\n    if (!x) throw new Error();\n    return x;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isMode = isMode;\nexports.mustBeMode = mustBeMode;\nexports.isOperationProperties = isOperationProperties;\nexports.mustBeOperationProperties = mustBeOperationProperties;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Lexeme = exports.Lexeme = {\n    BINARY_OPERATOR: 'BINARY_OPERATOR',\n    BRACKETS: 'BRACKETS',\n    CELL_SEPARATOR: 'CELL_SEPARATOR',\n    CHAR: 'CHAR',\n    DIGIT: 'DIGIT',\n    DIRECTIVE: 'DIRECTIVE',\n    DISPLAY_EQUATION: 'DISPLAY_EQUATION',\n    FILE_PATH: 'FILE_PATH',\n    FLOATING_BOX: 'FLOATING_BOX',\n    HORIZONTAL_SKIP: 'HORIZONTAL_SKIP',\n    INLINE_EQUATION: 'INLINE_EQUATION',\n    LABEL: 'LABEL',\n    LENGTH: 'LENGTH',\n    LETTER: 'LETTER',\n    LINE_BREAK: 'LINE_BREAK',\n    LIST_ITEM: 'LIST_ITEM',\n    LIST: 'LIST',\n    NUMBER: 'NUMBER',\n    PARAGRAPH_SEPARATOR: 'PARAGRAPH_SEPARATOR',\n    PICTURE: 'PICTURE',\n    POST_OPERATOR: 'POST_OPERATOR',\n    PRE_OPERATOR: 'PRE_OPERATOR',\n    RAW: 'RAW',\n    SPACE: 'SPACE',\n    SUBSCRIPT: 'SUBSCRIPT',\n    SUPERSCRIPT: 'SUPERSCRIPT',\n    TABLE: 'TABLE',\n    TABULAR_PARAMETERS: 'TABULAR_PARAMETERS',\n    TAG: 'TAG',\n    UNKNOWN: 'UNKNOWN',\n    VERTICAL_SKIP: 'VERTICAL_SKIP',\n    WORD: 'WORD',\n    WRAPPER: 'WRAPPER'\n};\nvar modes = exports.modes = {\n    LIST: 'LIST',\n    MATH: 'MATH',\n    PICTURE: 'PICTURE',\n    TABLE: 'TABLE',\n    TEXT: 'TEXT',\n    VERTICAL: 'VERTICAL'\n};\nfunction isMode(x) {\n    return modes.hasOwnProperty(x);\n}\nfunction mustBeMode(x) {\n    if (!isMode(x)) throw new Error();\n    return x;\n}\n\nvar State = exports.State = function () {\n    function State() {\n        var opt_initialModeStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, State);\n\n        Object.defineProperty(this, 'modeStates_', { value: {}, enumerable: false });\n        this.modeStates_[modes.LIST] = false;\n        this.modeStates_[modes.MATH] = false;\n        this.modeStates_[modes.PICTURE] = false;\n        this.modeStates_[modes.TABLE] = false;\n        this.modeStates_[modes.TEXT] = true;\n        this.modeStates_[modes.VERTICAL] = false;\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n    _createClass(State, [{\n        key: 'copy',\n        value: function copy() {\n            return new State(this.modeStates_);\n        }\n    }, {\n        key: 'update',\n        value: function update(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                this.modeStates_[mode] = modeStates[modeKey];\n            }\n        }\n    }, {\n        key: 'test',\n        value: function test(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n            }\n            return true;\n        }\n    }]);\n\n    return State;\n}();\n\n;\nvar Directive = exports.Directive = {\n    BEGIN: 'BEGIN',\n    END: 'END'\n};\nvar GROUP = exports.GROUP = 'GROUP';\nfunction isOperationProperties(x) {\n    return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\n}\nfunction mustBeOperationProperties(x) {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\n\nvar Operation = exports.Operation = function () {\n    function Operation(opt_initialProperties) {\n        _classCallCheck(this, Operation);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var directive = Directive[opt_initialProperties.directive];\n        if (!directive) throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, 'directive', { value: directive, enumerable: true });\n        switch (opt_initialProperties.operand) {\n            case GROUP:\n                Object.defineProperty(this, 'operand', { value: GROUP, enumerable: true });\n                break;\n            default:\n                var mode = modes[opt_initialProperties.operand];\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\n                Object.defineProperty(this, 'operand', { value: mode, enumerable: true });\n        }\n    }\n\n    _createClass(Operation, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Operation)) return false;\n            return this.directive === other.directive && this.operand === other.operand;\n        }\n    }]);\n\n    return Operation;\n}();\n\n;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Environment = exports.Command = exports.Symbol = exports.Parameter = exports.Item = exports.LatexStyle = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isParameterProperties = isParameterProperties;\nexports.mustBeParameterProperties = mustBeParameterProperties;\nexports.isCommand = isCommand;\nexports.mustBeCommand = mustBeCommand;\nexports.isEnvironment = isEnvironment;\n\nvar _Utils = __webpack_require__(0);\n\nvar _Latex = __webpack_require__(1);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction isArray(x) {\n    return x.constructor === Array;\n}\nfunction mustBeArray(x) {\n    if (!isArray(x)) throw new Error();\n    return x;\n}\n\nvar LatexStyle = exports.LatexStyle = function () {\n    function LatexStyle() {\n        _classCallCheck(this, LatexStyle);\n\n        this.symbols_ = {};\n        this.commands_ = {};\n        this.environments_ = {};\n    }\n\n    _createClass(LatexStyle, [{\n        key: 'loadPackage',\n        value: function loadPackage(packageName, stylePackage) {\n            if (stylePackage.symbols !== undefined) {\n                if (!(stylePackage.symbols instanceof Array)) throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n                for (var iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                    var symbol = new _Symbol(stylePackage.symbols[iSymbol]);\n                    if (symbol.pattern) {\n                        var symbolPatternFirstChar = symbol.pattern[0];\n                        if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar)) this.symbols_[symbolPatternFirstChar] = [];\n                        var symbols = this.symbols_[symbolPatternFirstChar];\n                        symbols.push({ symbol: symbol, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.commands !== undefined) {\n                if (!(stylePackage.commands instanceof Array)) throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n                for (var iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                    var command = new Command(stylePackage.commands[iCommand]);\n                    if (command.name) {\n                        (this.commands_[command.name] || (this.commands_[command.name] = [])).push({ command: command, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.environments !== undefined) {\n                if (!(stylePackage.environments instanceof Array)) throw new TypeError('\"stylePackage.environments\" isn\\'t an Array');\n                for (var iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0; --iEnvironment) {\n                    var environment = new Environment(stylePackage.environments[iEnvironment]);\n                    var envName = environment.name;\n                    if (envName) {\n                        var storedEnv = this.environments_[envName];\n                        if (storedEnv === undefined) {\n                            storedEnv = [];\n                            this.environments_[envName] = storedEnv;\n                        }\n                        storedEnv.push({ environment: environment, packageName: packageName });\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'unloadPackage',\n        value: function unloadPackage(packageName) {\n            for (var symbolPatternFirstChar in this.symbols_) {\n                if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                    var filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredSymbols.length) {\n                        this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                    } else {\n                        delete this.symbols_[symbolPatternFirstChar];\n                    }\n                }\n            }for (var commandName in this.commands_) {\n                if (this.commands_.hasOwnProperty(commandName)) {\n                    var filteredCommands = mustBeArray(this.commands_[commandName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredCommands.length) {\n                        this.commands_[commandName] = filteredCommands;\n                    } else {\n                        delete this.commands_[commandName];\n                    }\n                }\n            }for (var environmentName in this.environments_) {\n                if (this.environments_.hasOwnProperty(environmentName)) {\n                    var filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredEnvironments.length) {\n                        this.environments_[environmentName] = filteredEnvironments;\n                    } else {\n                        delete this.environments_[environmentName];\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'symbols',\n        value: function symbols(state, patternFirstChar) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var symbols = this.symbols_[patternFirstChar];\n            if (symbols === undefined) return [];\n            var filteredSymbols = [];\n            for (var iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) {\n                var symbol = symbols[iSymbol].symbol;\n                if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n            }\n            return filteredSymbols;\n        }\n    }, {\n        key: 'commands',\n        value: function commands(state, name) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var commands = this.commands_[name];\n            if (!commands) return [];\n            var filteredCommands = [];\n            for (var iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) {\n                var command = commands[iCommand].command;\n                if (state.test(command.modes)) filteredCommands.push(command);\n            }\n            return filteredCommands;\n        }\n    }, {\n        key: 'environments',\n        value: function environments(state, name) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('state isn\\'t State instance');\n            var environments = this.environments_[name];\n            if (!environments) return [];\n            return mustBeArray(environments).filter(function (env) {\n                return state.test(env.modes);\n            });\n        }\n    }]);\n\n    return LatexStyle;\n}();\n\n;\n\nvar Item = exports.Item = function () {\n    function Item() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Item);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break;\n            case null:\n                break;\n            default:\n                var lexeme = _Latex.Lexeme[opt_initialProperties.lexeme];\n                if (lexeme === undefined) throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, 'lexeme', { value: lexeme });\n        }\n        if (opt_initialProperties.modes !== undefined) {\n            if (!(opt_initialProperties.modes instanceof Object)) throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, 'modes', { value: {} });\n            for (var modeKey in opt_initialProperties.modes) {\n                var mode = (0, _Latex.mustBeMode)(modeKey);\n                if (mode === undefined) throw new TypeError('\"initialProperties.modes[' + modeKey + ']\" isn\\'t a Mode option');\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n    _createClass(Item, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Item)) return false;\n            return this.lexeme === other.lexeme && (0, _Utils.testProperties)(this.modes, other.modes, _Latex.modes, false);\n        }\n    }]);\n\n    return Item;\n}();\n\n;\nObject.defineProperties(Item.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    modes: { value: {}, enumerable: true }\n});\nfunction isParameterProperties(ignored) {\n    return true;\n}\nfunction mustBeParameterProperties(x) {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\n\nvar Parameter = exports.Parameter = function (_Item) {\n    _inherits(Parameter, _Item);\n\n    function Parameter() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Parameter);\n\n        var _this = _possibleConstructorReturn(this, (Parameter.__proto__ || Object.getPrototypeOf(Parameter)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this, 'operations_', {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Latex.Operation(operation);\n                })\n            });\n        }\n        return _this;\n    }\n\n    _createClass(Parameter, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Parameter)) return false;\n            if (!_get(Parameter.prototype.__proto__ || Object.getPrototypeOf(Parameter.prototype), 'equals', this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            return this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            });\n        }\n    }, {\n        key: 'operations',\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }]);\n\n    return Parameter;\n}(Item);\n\n;\nObject.defineProperties(Parameter.prototype, {\n    operations: { enumerable: true }\n});\nObject.defineProperties(Parameter.prototype, {\n    operations_: { value: [], enumerable: false }\n});\n\nvar _Symbol = function (_Item2) {\n    _inherits(_Symbol, _Item2);\n\n    function _Symbol() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, _Symbol);\n\n        var _this2 = _possibleConstructorReturn(this, (_Symbol.__proto__ || Object.getPrototypeOf(_Symbol)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this2);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this2, 'operations_', {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Latex.Operation((0, _Latex.mustBeOperationProperties)(operation));\n                })\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) {\n            if (!(opt_initialProperties.parameters instanceof Array)) throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            _this2.parameters_ = opt_initialProperties.parameters.map(function (parameter) {\n                return new Parameter(mustBeParameterProperties(parameter));\n            });\n        }\n        if (opt_initialProperties.pattern !== undefined) {\n            if (typeof opt_initialProperties.pattern !== 'string') throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            var patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) {\n                _this2.patternComponents_ = patternComponents.map(function (patternPart) {\n                    switch (patternPart[0]) {\n                        case ' ':\n                        case '\\t':\n                            return undefined;\n                        case '#':\n                            var parameterIndex = Number(patternPart.substring(1)) - 1;\n                            if (!_this2.parameters_[parameterIndex]) throw new TypeError('\"initialProperties.pattern\" contains the incorrect parameter number ' + patternPart.substring(1));\n                            return parameterIndex;\n                        default:\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) {\n            if (typeof opt_initialProperties.html !== 'string') throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            Object.defineProperty(_this2, 'html', { value: opt_initialProperties.html, enumerable: true });\n        }\n        return _this2;\n    }\n\n    _createClass(_Symbol, [{\n        key: 'parameter',\n        value: function parameter(parameterIndex) {\n            return this.parameters_[parameterIndex] || undefined;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof _Symbol)) return false;\n            if (!_get(_Symbol.prototype.__proto__ || Object.getPrototypeOf(_Symbol.prototype), 'equals', this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            if (!this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            })) return false;\n            if (this.parameters_.length !== other.parameters_.length) return false;\n            if (!this.parameters_.every(function (parameter, iParameter) {\n                return parameter.equals(other.parameters_[iParameter]);\n            })) return false;\n            return this.html === other.html;\n        }\n    }, {\n        key: 'operations',\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }, {\n        key: 'parameters',\n        get: function get() {\n            return this.parameters_.slice();\n        }\n    }, {\n        key: 'patternComponents',\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.patternComponents_.slice());\n        }\n    }, {\n        key: 'pattern',\n        get: function get() {\n            return this.patternComponents_.map(function (patternComponent) {\n                if ((0, _Utils.isNumber)(patternComponent)) {\n                    return '#' + (patternComponent + 1);\n                }\n                switch (typeof patternComponent === 'undefined' ? 'undefined' : _typeof(patternComponent)) {\n                    case 'string':\n                        return patternComponent;\n                    default:\n                        return ' ';\n                }\n            }).join('');\n        }\n    }]);\n\n    return _Symbol;\n}(Item);\n\nexports.Symbol = _Symbol;\n\n;\nObject.defineProperties(_Symbol.prototype, {\n    operations: { enumerable: true },\n    parameters: { enumerable: true },\n    patternComponents: { enumerable: true },\n    pattern: { enumerable: true }\n});\nObject.defineProperties(_Symbol.prototype, {\n    operations_: { value: [], enumerable: false, writable: true },\n    parameters_: { value: [], enumerable: false, writable: true },\n    patternComponents_: { value: [], enumerable: false, writable: true },\n    html: { value: '', enumerable: true, writable: true }\n});\n\nvar Command = exports.Command = function (_Symbol2) {\n    _inherits(Command, _Symbol2);\n\n    function Command() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Command);\n\n        var _this3 = _possibleConstructorReturn(this, (Command.__proto__ || Object.getPrototypeOf(Command)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this3);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this3, 'name', { value: opt_initialProperties.name });\n        }\n        return _this3;\n    }\n\n    _createClass(Command, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Command)) return false;\n            if (!_get(Command.prototype.__proto__ || Object.getPrototypeOf(Command.prototype), 'equals', this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Command;\n}(_Symbol);\n\n;\nObject.defineProperties(Command.prototype, {\n    name: { value: '', enumerable: true }\n});\nfunction isCommand(c) {\n    return c instanceof Command;\n}\nfunction mustBeCommand(c) {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\n\nvar Environment = exports.Environment = function (_Item3) {\n    _inherits(Environment, _Item3);\n\n    function Environment() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Environment);\n\n        var _this4 = _possibleConstructorReturn(this, (Environment.__proto__ || Object.getPrototypeOf(Environment)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this4);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this4, 'name', { value: opt_initialProperties.name });\n        }\n        return _this4;\n    }\n\n    _createClass(Environment, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Environment)) return false;\n            if (!_get(Environment.prototype.__proto__ || Object.getPrototypeOf(Environment.prototype), 'equals', this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Environment;\n}(Item);\n\nObject.defineProperties(Environment.prototype, {\n    name: { value: \"\", enumerable: true }\n});\nfunction isEnvironment(x) {\n    return x instanceof Environment;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SourceToken = exports.SpaceToken = exports.EnvironmentBodyToken = exports.EnvironmentToken = exports.CommandToken = exports.ParameterToken = exports.SymbolToken = exports.Token = exports.LatexTree = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isCommandToken = isCommandToken;\nexports.mustBeEnvironmentToken = mustBeEnvironmentToken;\nexports.isEnvironmentToken = isEnvironmentToken;\n\nvar _LatexStyle = __webpack_require__(2);\n\nvar _SyntaxTree2 = __webpack_require__(4);\n\nvar _Latex = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar LatexTree = exports.LatexTree = function (_SyntaxTree) {\n    _inherits(LatexTree, _SyntaxTree);\n\n    function LatexTree(rootToken, source) {\n        _classCallCheck(this, LatexTree);\n\n        if (!(rootToken instanceof Token)) throw new TypeError('\"rootToken\" isn\\'t a Token instance');\n        return _possibleConstructorReturn(this, (LatexTree.__proto__ || Object.getPrototypeOf(LatexTree)).call(this, rootToken, source));\n    }\n\n    return LatexTree;\n}(_SyntaxTree2.SyntaxTree);\n\n;\n\nvar Token = exports.Token = function (_Node) {\n    _inherits(Token, _Node);\n\n    function Token() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Token);\n\n        if (opt_initialProperties === undefined) {\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this));\n        } else if (opt_initialProperties instanceof Object) {\n            var superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this, superInitialProperties));\n        } else {\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n        return _possibleConstructorReturn(_this2);\n    }\n\n    _createClass(Token, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), 'toString', this).call(this, true) : 'Token{' + _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), 'toString', this).call(this, true) + '}';\n        }\n    }]);\n\n    return Token;\n}(_SyntaxTree2.Node);\n\n;\nObject.defineProperties(Token.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    parentNodeClass_: { value: Token }\n});\n\nvar SymbolToken = exports.SymbolToken = function (_Token) {\n    _inherits(SymbolToken, _Token);\n\n    function SymbolToken(initialProperties) {\n        _classCallCheck(this, SymbolToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this3 = _possibleConstructorReturn(this, (SymbolToken.__proto__ || Object.getPrototypeOf(SymbolToken)).call(this, initialProperties));\n\n        if (initialProperties.symbol) {\n            if (!(initialProperties.symbol instanceof _LatexStyle.Symbol)) throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            Object.defineProperty(_this3, 'symbol', { value: initialProperties.symbol, enumerable: true });\n        } else {\n            if (typeof initialProperties.pattern !== 'string') throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            Object.defineProperty(_this3, 'pattern', { value: initialProperties.pattern });\n        }\n        return _this3;\n    }\n\n    _createClass(SymbolToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '';\n            var iParameter = 0;\n            var pattern = this.pattern;\n            for (var nPatternChars = pattern.length, iPatternChar = 0; iPatternChar < nPatternChars; ++iPatternChar) {\n                var patternChar = pattern[iPatternChar];\n                if (patternChar === '#') {\n                    ++iPatternChar;\n                    var parameterToken = this.childNode(iParameter++);\n                    source += parameterToken ? parameterToken.toString(true) : '??';\n                } else {\n                    source += patternChar;\n                }\n            }\n            return skipNodeClass ? source : 'SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            return this.symbol ? this.symbol.lexeme : undefined;\n        }\n    }, {\n        key: 'pattern',\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.symbol).pattern;\n        }\n    }]);\n\n    return SymbolToken;\n}(Token);\n\n;\nObject.defineProperties(SymbolToken.prototype, {\n    symbol: { value: undefined, enumerable: true }\n});\nObject.defineProperties(SymbolToken.prototype, {\n    pattern: { enumerable: true }\n});\n\nvar ParameterToken = exports.ParameterToken = function (_Token2) {\n    _inherits(ParameterToken, _Token2);\n\n    function ParameterToken(initialProperties) {\n        _classCallCheck(this, ParameterToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this4 = _possibleConstructorReturn(this, (ParameterToken.__proto__ || Object.getPrototypeOf(ParameterToken)).call(this, initialProperties));\n\n        if (!initialProperties.hasBrackets) Object.defineProperty(_this4, 'hasBrackets', { value: false, enumerable: true });\n        if (initialProperties.hasSpacePrefix) Object.defineProperty(_this4, 'hasSpacePrefix', { value: true, enumerable: true });\n        return _this4;\n    }\n\n    _createClass(ParameterToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = this.hasSpacePrefix ? ' ' : '';\n            source += this.hasBrackets ? '{' + _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), 'toString', this).call(this, true) + '}' : _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), 'toString', this).call(this, true);\n            return skipNodeClass ? source : 'ParameterToken{' + source + '}';\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n        }\n    }, {\n        key: 'parameter',\n        get: function get() {\n            var symbolToken = this.parentNode;\n            var symbol = (0, _Utils.mustNotBeUndefined)(symbolToken.symbol);\n            var parameterIndex = symbolToken.childIndex(this);\n            if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0) return symbol.parameter(parameterIndex);\n        }\n    }]);\n\n    return ParameterToken;\n}(Token);\n\n;\nObject.defineProperties(ParameterToken.prototype, {\n    hasBrackets: { value: true, enumerable: true },\n    hasSpacePrefix: { value: false, enumerable: true },\n    parentNodeClass_: { value: SymbolToken }\n});\nObject.defineProperties(ParameterToken.prototype, {\n    parameter: { enumerable: true }\n});\n\nvar CommandToken = exports.CommandToken = function (_SymbolToken) {\n    _inherits(CommandToken, _SymbolToken);\n\n    function CommandToken(initialProperties) {\n        _classCallCheck(this, CommandToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var superInitialProperties = Object.create(initialProperties);\n        if (initialProperties.command) {\n            if (!(initialProperties.command instanceof _LatexStyle.Command)) throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            superInitialProperties.symbol = initialProperties.command;\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n        } else {\n            if (typeof initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = '';\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n\n            Object.defineProperty(_this5, 'name', { value: initialProperties.name });\n        }\n        return _possibleConstructorReturn(_this5);\n    }\n\n    _createClass(CommandToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '\\\\' + this.name + _get(CommandToken.prototype.__proto__ || Object.getPrototypeOf(CommandToken.prototype), 'toString', this).call(this, true);\n            return skipNodeClass ? source : 'CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\n        }\n    }, {\n        key: 'command',\n        get: function get() {\n            return (0, _LatexStyle.mustBeCommand)(this.symbol);\n        }\n    }, {\n        key: 'name',\n        get: function get() {\n            return this.command.name;\n        }\n    }]);\n\n    return CommandToken;\n}(SymbolToken);\n\n;\nObject.defineProperties(CommandToken.prototype, {\n    command: { enumerable: true },\n    name: { enumerable: true }\n});\nfunction isCommandToken(x) {\n    return x && x instanceof CommandToken;\n}\n\nvar EnvironmentToken = exports.EnvironmentToken = function (_Token3) {\n    _inherits(EnvironmentToken, _Token3);\n\n    function EnvironmentToken(initialProperties) {\n        _classCallCheck(this, EnvironmentToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this6 = _possibleConstructorReturn(this, (EnvironmentToken.__proto__ || Object.getPrototypeOf(EnvironmentToken)).call(this, initialProperties));\n\n        if (!(initialProperties.environment instanceof _LatexStyle.Environment)) throw new TypeError('\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        Object.defineProperty(_this6, 'environment', {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n        return _this6;\n    }\n\n    _createClass(EnvironmentToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var beginCommandToken = this.beginCommandToken;\n            var endCommandToken = this.endCommandToken;\n            var bodyToken = this.bodyToken;\n            var source = '\\\\begin{' + this.environment.name + '}';\n            source += beginCommandToken ? SymbolToken.prototype.toString.call(beginCommandToken, true) : '??';\n            source += bodyToken ? bodyToken.toString(true) : '??';\n            source += '\\\\end{' + this.environment.name + '}';\n            source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\n            return skipNodeClass ? source : 'EnvironmentToken{' + source + '}';\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            return this.environment.lexeme;\n        }\n    }, {\n        key: 'beginCommandToken',\n        get: function get() {\n            var beginCommandToken = this.childNode(0);\n            return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\n        }\n    }, {\n        key: 'endCommandToken',\n        get: function get() {\n            var endCommandToken = this.childNode(2);\n            return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\n        }\n    }, {\n        key: 'bodyToken',\n        get: function get() {\n            var bodyToken = this.childNode(1);\n            return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\n        }\n    }]);\n\n    return EnvironmentToken;\n}(Token);\n\n;\nObject.defineProperties(EnvironmentToken.prototype, {\n    beginToken: { enumerable: true },\n    endToken: { enumerable: true }\n});\nfunction mustBeEnvironmentToken(x) {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\nfunction isEnvironmentToken(x) {\n    return x instanceof EnvironmentToken;\n}\nfunction getBeginCommandToken(x) {\n    if (isCommandToken(x.beginCommandToken)) return x.beginCommandToken;\n}\nfunction getEndCommandToken(x) {\n    if (isCommandToken(x.endCommandToken)) return x.endCommandToken;\n}\nfunction getEnvironment(x) {\n    if (x.environment && (0, _LatexStyle.isEnvironment)(x.environment)) return x.environment;\n}\n\nvar EnvironmentBodyToken = exports.EnvironmentBodyToken = function (_Token4) {\n    _inherits(EnvironmentBodyToken, _Token4);\n\n    function EnvironmentBodyToken() {\n        _classCallCheck(this, EnvironmentBodyToken);\n\n        return _possibleConstructorReturn(this, (EnvironmentBodyToken.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken)).apply(this, arguments));\n    }\n\n    _createClass(EnvironmentBodyToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), 'toString', this).call(this, true) : 'EnvironmentBodyToken{' + _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), 'toString', this).call(this, true) + '}';\n        }\n    }, {\n        key: 'environment',\n        get: function get() {\n            return this.parentNode && getEnvironment(this.parentNode);\n        }\n    }, {\n        key: 'environmentToken',\n        get: function get() {\n            return this.parentNode && mustBeEnvironmentToken(this.parentNode);\n        }\n    }, {\n        key: 'beginCommandToken',\n        get: function get() {\n            return this.parentNode && getBeginCommandToken(this.parentNode);\n        }\n    }, {\n        key: 'endCommandToken',\n        get: function get() {\n            return this.parentNode && getEndCommandToken(this.parentNode);\n        }\n    }]);\n\n    return EnvironmentBodyToken;\n}(Token);\n\n;\nObject.defineProperties(EnvironmentBodyToken.prototype, {\n    parentNodeClass_: { value: EnvironmentToken }\n});\n\nvar SpaceToken = exports.SpaceToken = function (_Token5) {\n    _inherits(SpaceToken, _Token5);\n\n    function SpaceToken(initialProperties) {\n        _classCallCheck(this, SpaceToken);\n\n        if (initialProperties === undefined) {\n            var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this));\n\n            return _possibleConstructorReturn(_this8);\n        } else if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this, initialProperties));\n\n        if (initialProperties.lineBreakCount) {\n            if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0) throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\n            Object.defineProperty(_this8, 'lineBreakCount', {\n                value: initialProperties.lineBreakCount,\n                enumerable: true\n            });\n        }\n        return _possibleConstructorReturn(_this8);\n    }\n\n    _createClass(SpaceToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (skipNodeClass) {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return ' ';\n                    case 1:\n                        return '\\n';\n                    default:\n                        return '\\n\\n';\n                }\n            } else {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return 'SpaceToken{ }';\n                    case 1:\n                        return 'SpaceToken{\\n}';\n                    default:\n                        return 'SpaceToken{\\n\\n}';\n                }\n            }\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n        }\n    }]);\n\n    return SpaceToken;\n}(Token);\n\n;\nObject.defineProperties(SpaceToken.prototype, {\n    lineBreakCount: { value: 0, enumerable: true }\n});\n\nvar SourceToken = exports.SourceToken = function (_Token6) {\n    _inherits(SourceToken, _Token6);\n\n    function SourceToken(initialProperties) {\n        _classCallCheck(this, SourceToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this9 = _possibleConstructorReturn(this, (SourceToken.__proto__ || Object.getPrototypeOf(SourceToken)).call(this, initialProperties));\n\n        if (!_Latex.Lexeme[initialProperties.lexeme]) throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\n        Object.defineProperty(_this9, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\n        if (typeof initialProperties.source !== 'string') throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\n        Object.defineProperty(_this9, 'source', { value: initialProperties.source, enumerable: true });\n        return _this9;\n    }\n\n    _createClass(SourceToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? this.source : 'SourceToken[' + this.lexeme + ']{' + this.source + '}';\n        }\n    }]);\n\n    return SourceToken;\n}(Token);\n\n;\nexports.default = _SyntaxTree2.SyntaxTree;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Node = exports.SyntaxTree = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n'use strict';\n\nvar SyntaxTree = exports.SyntaxTree = function SyntaxTree(rootNode, source) {\n    _classCallCheck(this, SyntaxTree);\n\n    if (!(rootNode instanceof Node)) throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n    Object.defineProperty(this, 'rootNode', { value: rootNode, enumerable: true });\n    Object.defineProperty(this, 'source', { value: source, enumerable: true });\n    Object.defineProperty(rootNode, 'tree', { value: this, enumerable: true });\n};\n\n;\n\nvar Node = exports.Node = function () {\n    function Node(opt_initialProperties) {\n        _classCallCheck(this, Node);\n\n        if (opt_initialProperties !== undefined) {\n            if (!(opt_initialProperties instanceof Object)) throw new TypeError('initialProperties isn\\'t an Object instance');\n            if (opt_initialProperties.childNodes !== undefined) {\n                if (!(opt_initialProperties.childNodes instanceof Array)) throw new TypeError('initialProperties.childNodes isn\\'t an Array instance');\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n            }\n            var optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) {\n                if (!!optParentNode) {\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError('initialProperties.parentNode isn\\'t a SyntaxTree.Node instance');\n                }\n            }\n        }\n    }\n\n    _createClass(Node, [{\n        key: 'childNode',\n        value: function childNode(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] || undefined;\n            if (node instanceof Node) return node.parentNode === this ? node : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: 'childIndex',\n        value: function childIndex(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] ? node : undefined;\n            if (node instanceof Node) return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: 'insertChildNode',\n        value: function insertChildNode(node, childIndex, childNodesToCover) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n            if (!this.hasOwnProperty('childNodes_')) Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            if (childNodesToCover === undefined) childNodesToCover = 0;\n            var nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n            Object.defineProperty(this, 'subtreeSize', {\n                value: this.subtreeSize + 1,\n                enumerable: true,\n                configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize + 1 });\n            }\n            Object.defineProperty(node, 'parentNode', {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n            if (nodeChildNodes.length) {\n                Object.defineProperty(node, 'childNodes_', { value: nodeChildNodes, configurable: true });\n                var subtreeSize = 1;\n                nodeChildNodes.forEach(function (nodeChildNode) {\n                    subtreeSize += nodeChildNode.subtreeSize;\n                });\n                Object.defineProperty(node, 'subtreeSize', {\n                    value: subtreeSize,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n            return node;\n        }\n    }, {\n        key: 'insertChildSubtree',\n        value: function insertChildSubtree(node, childIndex) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (!this.hasOwnProperty('childNodes_')) Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            this.childNodes_.splice(childIndex, 0, node);\n            var nodeSubtreeSize = node.subtreeSize;\n            Object.defineProperty(this, 'subtreeSize', {\n                value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', {\n                    value: parentNode.subtreeSize + nodeSubtreeSize\n                });\n            }\n            Object.defineProperty(node, 'parentNode', {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }, {\n        key: 'removeChildNode',\n        value: function removeChildNode(nodeOrNodeIndex) {\n            var _childNodes_;\n\n            var nodeChildIndex = this.childIndex(nodeOrNodeIndex);\n            if (nodeChildIndex === undefined) return undefined;\n            var node = this.childNodes_[nodeChildIndex];\n            (_childNodes_ = this.childNodes_).splice.apply(_childNodes_, [nodeChildIndex, 1].concat(_toConsumableArray(node.childNodes_)));\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - 1 });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize - 1 });\n            }\n            delete node.parentNode;\n            delete node.childNodes_;\n            delete node.subtreeSize;\n            return node;\n        }\n    }, {\n        key: 'removeChildSubtree',\n        value: function removeChildSubtree(node) {\n            var nodeChildIndex = this.childIndex(node);\n            if (nodeChildIndex === undefined) return undefined;\n            node = this.childNodes_.splice(nodeChildIndex, 1)[0];\n            var nodeSubtreeSize = node.subtreeSize;\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - nodeSubtreeSize });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', {\n                    value: parentNode.subtreeSize - nodeSubtreeSize\n                });\n            }\n            delete node.parentNode;\n            return node;\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '';\n            this.childNodes_.forEach(function (childNode) {\n                source += childNode.toString(true);\n            });\n            return skipNodeClass ? source : 'SourceTree.Node{' + source + '}';\n        }\n    }, {\n        key: 'childNodes',\n        get: function get() {\n            return this.childNodes_.slice();\n        }\n    }]);\n\n    return Node;\n}();\n\n;\nObject.defineProperties(Node.prototype, {\n    childNodes: { enumerable: true }\n});\nObject.defineProperties(Node.prototype, {\n    tree: { value: undefined, enumerable: true },\n    parentNode: { value: undefined, enumerable: true },\n    subtreeSize: { value: 1, enumerable: true },\n    childNodes_: { value: [], enumerable: false },\n    parentNodeClass_: { value: Node, enumerable: false }\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Context = exports.LatexParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _LatexStyle = __webpack_require__(2);\n\nvar _LatexTree = __webpack_require__(3);\n\nvar _Latex = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction parseCommentLine_(context) {\n    var commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false;\n    context.comments.push(commentMatch[1]);\n    context.position += commentMatch[0].length;\n    if (!commentMatch[2]) {\n        context.charNumber += commentMatch[0].length;\n    } else {\n        ++context.lineNumber;\n        context.charNumber = commentMatch[2].length - 1;\n    }\n    return true;\n}\nfunction processParsedToken_(context, token) {\n    if (context.currentToken) {\n        context.currentToken.insertChildSubtree(token);\n    }\n}\nfunction parseSpaceToken_(context) {\n    var isSpace = false;\n    var nLineBreaks = 0;\n    while (context.position < context.source.length) {\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) {\n            case ' ':\n            case '\\t':\n                isSpace = true;\n                ++context.position;\n                ++context.charNumber;\n                continue;\n            case '\\n':\n                isSpace = true;\n                ++nLineBreaks;\n                ++context.position;\n                ++context.lineNumber;\n                context.charNumber = 0;\n                continue;\n        }\n        break;\n    }\n    return isSpace ? new _LatexTree.SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\n}\n\nvar LatexParser = exports.LatexParser = function () {\n    function LatexParser(latexStyle) {\n        _classCallCheck(this, LatexParser);\n\n        if (!(latexStyle instanceof _LatexStyle.LatexStyle)) throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\n        Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\n    }\n\n    _createClass(LatexParser, [{\n        key: \"parse\",\n        value: function parse(source, opt_context) {\n            if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n            var context = void 0;\n            if (opt_context === undefined) {\n                context = new Context(source);\n            } else if (opt_context instanceof Context) {\n                context = opt_context;\n                context.source += source;\n            } else {\n                throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\n            }\n            var parsedTokens = [];\n            while (true) {\n                var parsedToken = this.parseToken_(context);\n                if (parsedToken === undefined) break;\n                parsedTokens.push(parsedToken);\n            }\n            return parsedTokens;\n        }\n    }, {\n        key: \"parseToken_\",\n        value: function parseToken_(context) {\n            var token = parseSpaceToken_(context);\n            if (!token) {\n                if (context.position >= context.source.length) return undefined;\n                var contextBackup = context.copy();\n                if (!(token = this.parseEnvironmentToken_(context))) {\n                    contextBackup.copy(context);\n                    if (!(token = this.parseCommandToken_(context))) {\n                        contextBackup.copy(context);\n                        if (!(token = this.parseSymbolsToken_(context))) {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            processParsedToken_(context, token);\n            return token;\n        }\n    }, {\n        key: \"parseParameterToken_\",\n        value: function parseParameterToken_(context, parameter, opt_endLabel) {\n            var currentTokenBackup = context.currentToken;\n            context.updateState(parameter.operations);\n            if (opt_endLabel === undefined) {\n                var spacePrefixState = parseSpaceToken_(context) !== undefined;\n                if (context.source[context.position] === '{') {\n                    context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState });\n                    ++context.position;\n                    ++context.charNumber;\n                    if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return undefined;\n                    ++context.position;\n                    ++context.charNumber;\n                } else {\n                    context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState });\n                    if (this.parseToken_(context) === undefined) return undefined;\n                }\n            } else {\n                context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: false });\n                if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return undefined;\n            }\n            var parameterToken = context.currentToken;\n            context.currentToken = currentTokenBackup;\n            processParsedToken_(context, parameterToken);\n            return parameterToken;\n        }\n    }, {\n        key: \"parseEnvironmentToken_\",\n        value: function parseEnvironmentToken_(context) {\n            if (context.source.substring(context.position).indexOf('\\\\begin') !== 0) return undefined;\n            context.position += 6;\n            parseSpaceToken_(context);\n            var nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n            if (!nameMatch) return undefined;\n            var name = nameMatch[1];\n            context.position += nameMatch[0].length;\n            context.charNumber += nameMatch[0].length;\n            var currentTokenBackup = context.currentToken;\n            var environment = this.latexStyle.environments(context.currentState, name)[0];\n            var environmentToken = context.currentToken = environment ? new _LatexTree.EnvironmentToken({ environment: environment.environment }) : new _LatexTree.EnvironmentToken({ name: name });\n            var symbols = this.latexStyle.commands(context.currentState, name);\n            var beginCommandToken = this.parsePatterns_(context, symbols);\n            if (beginCommandToken === undefined) {\n                beginCommandToken = new _LatexTree.CommandToken({ name: name });\n            }\n            processParsedToken_(context, beginCommandToken);\n            var environmentBodyToken = context.currentToken = new _LatexTree.EnvironmentBodyToken();\n            var endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}');\n            context.currentToken = environmentToken;\n            processParsedToken_(context, environmentBodyToken);\n            var endCommandToken = undefined;\n            if (endFound) {\n                context.position += name.length + 6;\n                context.charNumber += name.length + 6;\n                endCommandToken = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\n            } else {}\n            if (endCommandToken === undefined) {\n                endCommandToken = new _LatexTree.CommandToken({ name: 'end' + name });\n            }\n            processParsedToken_(context, endCommandToken);\n            context.currentToken = currentTokenBackup;\n            return environmentToken;\n        }\n    }, {\n        key: \"parseCommandToken_\",\n        value: function parseCommandToken_(context) {\n            var cmdMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\n            if (!cmdMatch) return undefined;\n            context.position += cmdMatch[0].length;\n            context.charNumber += cmdMatch[0].length;\n            var token = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, cmdMatch[1]));\n            if (token === undefined) {\n                token = new _LatexTree.CommandToken({ name: cmdMatch[1] });\n            }\n            return token;\n        }\n    }, {\n        key: \"parseSymbolsToken_\",\n        value: function parseSymbolsToken_(context) {\n            var sourceCharacter = context.source[context.position];\n            var token = this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\n            if (token === undefined) {\n                ++context.position;\n                ++context.charNumber;\n                token = new _LatexTree.SymbolToken({ pattern: sourceCharacter });\n            } else {}\n            return token;\n        }\n    }, {\n        key: \"parsePatterns_\",\n        value: function parsePatterns_(context, symbols) {\n            var _this = this;\n\n            var contextBackup = context.copy();\n            var token = undefined;\n            symbols.some(function (symbol) {\n                if (token = _this.parsePattern_(context, symbol)) {\n                    return true;\n                } else {\n                    contextBackup.copy(context);\n                    return false;\n                }\n            });\n            return token;\n        }\n    }, {\n        key: \"parsePattern_\",\n        value: function parsePattern_(context, symbol) {\n            var currentTokenBackup = context.currentToken;\n            context.currentToken = symbol instanceof _LatexStyle.Command ? new _LatexTree.CommandToken({ command: symbol }) : new _LatexTree.SymbolToken({ symbol: symbol });\n            var patternComponents = symbol.patternComponents;\n            var nPatternComponents = patternComponents.length;\n            var iPatternComponent = 0;\n            for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n                var patternComponent = patternComponents[iPatternComponent];\n                if ((0, _Utils.isNumber)(patternComponent)) {\n                    var parameter = symbol.parameter(patternComponent);\n                    var parameterEndLabel = patternComponents[iPatternComponent + 1];\n                    if (typeof parameterEndLabel === 'string') {\n                        if (this.parseParameterToken_(context, (0, _Utils.mustNotBeUndefined)(parameter), parameterEndLabel)) {\n                            if (context.source.substring(context.position).indexOf(parameterEndLabel) !== 0) return undefined;\n                            context.position += parameterEndLabel.length;\n                            context.charNumber += parameterEndLabel.length;\n                            ++iPatternComponent;\n                            continue;\n                        }\n                    } else {\n                        if (this.parseParameterToken_(context, (0, _Utils.mustNotBeUndefined)(parameter))) continue;\n                    }\n                } else if ((0, _Utils.isString)(patternComponent)) {\n                    while (parseCommentLine_(context)) {}\n                    if (context.source.substring(context.position).indexOf(patternComponent) === 0) {\n                        context.position += patternComponent.length;\n                        context.charNumber += patternComponent.length;\n                        continue;\n                    }\n                } else if (parseSpaceToken_(context)) continue;\n                break;\n            }\n            if (iPatternComponent < nPatternComponents) return undefined;\n            var parsedToken = context.currentToken;\n            context.currentToken = currentTokenBackup;\n            context.updateState(symbol.operations);\n            return parsedToken;\n        }\n    }, {\n        key: \"parseUntilLabel_\",\n        value: function parseUntilLabel_(context, endLabel, opt_lexeme) {\n            switch (opt_lexeme) {\n                default:\n                    {\n                        while (context.source.substring(context.position).indexOf(endLabel) !== 0) {\n                            if (context.position >= context.source.length) {\n                                return false;\n                            }\n                            this.parseToken_(context);\n                        }\n                        return true;\n                    }\n            }\n        }\n    }]);\n\n    return LatexParser;\n}();\n\n;\n\nvar Context = exports.Context = function () {\n    function Context() {\n        var opt_source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n        _classCallCheck(this, Context);\n\n        this.source = opt_source || '';\n        this.position = 0;\n        this.lineNumber = 0;\n        this.charNumber = 0;\n        this.currentToken = undefined;\n        this.currentState = new _Latex.State();\n        this.stateStack = [];\n        this.comments = [];\n    }\n\n    _createClass(Context, [{\n        key: \"copy\",\n        value: function copy(opt_target) {\n            var target = opt_target || new Context();\n            target.source = this.source;\n            target.position = this.position;\n            target.lineNumber = this.lineNumber;\n            target.charNumber = this.charNumber;\n            target.currentToken = this.currentToken;\n            target.currentState = this.currentState.copy();\n            target.stateStack = this.stateStack.slice();\n            target.comments = this.comments.slice();\n            return target;\n        }\n    }, {\n        key: \"updateState\",\n        value: function updateState(operations) {\n            var _this2 = this;\n\n            if (!(operations instanceof Array)) throw new TypeError('\"operations\" isn\\'t an Array instance');\n            var newModeStates = {};\n            operations.forEach(function (operation) {\n                switch (operation.directive) {\n                    case _Latex.Directive.BEGIN:\n                        switch (operation.operand) {\n                            case _Latex.GROUP:\n                                _this2.currentState.update(newModeStates);\n                                newModeStates = {};\n                                _this2.stateStack.push(_this2.currentState.copy());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = true;\n                        }\n                        break;\n                    case _Latex.Directive.END:\n                        switch (operation.operand) {\n                            case _Latex.GROUP:\n                                newModeStates = {};\n                                if (_this2.stateStack.length < 1) throw new Error('state stack is empty');\n                                _this2.currentState = (0, _Utils.mustNotBeUndefined)(_this2.stateStack.pop());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = false;\n                        }\n                        break;\n                }\n            });\n            this.currentState.update(newModeStates);\n        }\n    }]);\n\n    return Context;\n}();\n\n;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(0);\n\nObject.keys(_Utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Utils[key];\n    }\n  });\n});\n\nvar _Latex = __webpack_require__(1);\n\nObject.keys(_Latex).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Latex[key];\n    }\n  });\n});\n\nvar _LatexStyle = __webpack_require__(2);\n\nObject.keys(_LatexStyle).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexStyle[key];\n    }\n  });\n});\n\nvar _SyntaxTree = __webpack_require__(4);\n\nObject.keys(_SyntaxTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _SyntaxTree[key];\n    }\n  });\n});\n\nvar _LatexTree = __webpack_require__(3);\n\nObject.keys(_LatexTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexTree[key];\n    }\n  });\n});\n\nvar _LatexParser = __webpack_require__(5);\n\nObject.keys(_LatexParser).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexParser[key];\n    }\n  });\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// latex-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c12892f994523ba5031c","/**\r\n * @fileoverview General JavaScript utils\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport type StringMap = {[s:string]:string};\r\n\r\nexport type TargetObject = any;\r\nexport type ValuesObject = any;\r\n\r\nexport type OptKeys = StringMap | string[];\r\n\r\nexport interface OptAttributes {\r\n  writable: boolean;\r\n  enumerable: boolean;\r\n  configurable: boolean;\r\n}\r\n/**\r\n * Update object properties by property values\r\n * @param {!Object} target the object to copy properties to\r\n * @param {!Object} values the object with property values (undefined values will be skipped)\r\n * @param {(!Object.<string,string>|!Array.<string>)=} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {{writable:boolean,enumerable:boolean,configurable:boolean}=} opt_attributes\r\n *        property attributes, { writable: true, enumerable: true, configurable: true } by default\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport function updateProperties(target: TargetObject,\r\n                                 values: ValuesObject,\r\n                                 opt_keys?: OptKeys,\r\n                                 opt_attributes: OptAttributes = { writable: true, enumerable: true, configurable: true }) {\r\n  if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n  if (values === undefined) return; // do noting is the sources is undefined\r\n  if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n  if (opt_attributes === undefined) {\r\n    opt_attributes = { writable: true, enumerable: true, configurable: true };\r\n  } else if (!(opt_attributes instanceof Object)) {\r\n    throw new TypeError('\"attributes\" isn\\'t an Object instance')\r\n  }\r\n  if (opt_keys === undefined) { // if the key map isn't defined\r\n    for (let key in values) { // for all the enumerable properties\r\n      //noinspection JSUnfilteredForInLoop\r\n      if (values[key] !== undefined) {\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(target, key, // update the property\r\n          // using the defined value\r\n          Object.create(opt_attributes, { value: { value: values[key] } })\r\n        );\r\n      }\r\n    }\r\n  } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n    opt_keys.forEach(key => { if (values[key] !== undefined) {\r\n      Object.defineProperty(target, key, // update the property\r\n        Object.create(opt_attributes, {value: {value: values[key]}}) // using the defined value\r\n      );\r\n    }});\r\n  } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n    for (let targetKey in opt_keys) { // for all the target keys\r\n      //noinspection JSUnfilteredForInLoop\r\n      let key = opt_keys[targetKey]; // the sources key\r\n      if (values[key] !== undefined)\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(target, targetKey, // update the property\r\n          // using the defined value\r\n          Object.create(opt_attributes, { value: { value: values[key] } })\r\n        );\r\n    }\r\n  } else { // if \"keys\" has unsupported value\r\n    throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Test object properties with property values (strict comparing is used)\r\n * @param {!Object} target the object with properties to test\r\n * @param {?Object} values the object with property values (undefined values will be skipped)\r\n * @param {?(Object.<string,string>|Array.<string>)} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {boolean=true} opt_skipUndefined true to skip keys with undefined values, false otherwise\r\n * @return {boolean} true if all the defined properties are the same false otherwise\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport function testProperties(target: TargetObject,\r\n                               values?: ValuesObject,\r\n                               opt_keys?: OptKeys,\r\n                               opt_skipUndefined: boolean = true) {\r\n  if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n  if (values === undefined) return true; // do noting is the sources is undefined\r\n  if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n  if (opt_skipUndefined === undefined) opt_skipUndefined = true; // skip undefined by default\r\n\r\n  if (opt_keys === undefined) { // if the key map isn't defined\r\n    for (let key in values) { // for all the enumerable properties\r\n      if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n        return false; // false if any value is different\r\n    }\r\n  } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n    return opt_keys.every(key => {\r\n      return target[key] === values[key] || (values[key] === undefined && opt_skipUndefined);\r\n    });\r\n  } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n    for (let targetKey in opt_keys) { // for all the target keys\r\n      let key = opt_keys[targetKey]; // the sources key\r\n      if (target[targetKey] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n        return false; // false if any value is different\r\n    }\r\n  } else { // if \"keys\" has unsupported value\r\n    throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n  }\r\n  return true; // return true if all the defined properties are the same\r\n};\r\n\r\n\r\nexport function isNumber(x: any): x is number {\r\n  return typeof x === \"number\"\r\n}\r\n\r\nexport function isString(x: any): x is string {\r\n  return typeof x === \"string\"\r\n}\r\n\r\nexport function mustNotBeUndefined<T>(x?: T): T {\r\n  if(!x) throw new Error();\r\n  return x;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Utils.ts","/**\r\n * @fileoverview General LaTeX definitions\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n'use strict';\r\n\r\n/**@module */\r\n\r\n\r\n\r\n/**\r\n * LaTeX lexeme\r\n * @enum {string}\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport const Lexeme = {\r\n  BINARY_OPERATOR:     'BINARY_OPERATOR',     // mathematical binary operator\r\n  BRACKETS:            'BRACKETS',            // logical brackets\r\n  CELL_SEPARATOR:      'CELL_SEPARATOR',      // table cell separator\r\n  CHAR:                'CHAR',                // character\r\n  DIGIT:               'DIGIT',               // digit\r\n  DIRECTIVE:           'DIRECTIVE',           // LaTeX directive\r\n  DISPLAY_EQUATION:    'DISPLAY_EQUATION',    // mathematical equation for display mode\r\n  FILE_PATH:           'FILE_PATH',           // file system path\r\n  FLOATING_BOX:        'FLOATING_BOX',        // floating box\r\n  HORIZONTAL_SKIP:     'HORIZONTAL_SKIP',     // any type of horizontal skip but not space\r\n  INLINE_EQUATION:     'INLINE_EQUATION',     // mathematical equation for inline mode\r\n  LABEL:               'LABEL',               // label identifier\r\n  LENGTH:              'LENGTH',              // linear dimension\r\n  LETTER:              'LETTER',              // word letter\r\n  LINE_BREAK:          'LINE_BREAK',          // text line break\r\n  LIST_ITEM:           'LIST_ITEM',           // list item\r\n  LIST:                'LIST',                // list of items\r\n  NUMBER:              'NUMBER',              // sequence of digits\r\n  PARAGRAPH_SEPARATOR: 'PARAGRAPH_SEPARATOR', // paragraph separator\r\n  PICTURE:             'PICTURE',             // picture\r\n  POST_OPERATOR:       'POST_OPERATOR',       // mathematical post-operator\r\n  PRE_OPERATOR:        'PRE_OPERATOR',        // mathematical pre-operator\r\n  RAW:                 'RAW',                 // unprocessable or raw sources\r\n  SPACE:               'SPACE',               // any type of space equivalent\r\n  SUBSCRIPT:           'SUBSCRIPT',           // subscript text\r\n  SUPERSCRIPT:         'SUPERSCRIPT',         // subscript text\r\n  TABLE:               'TABLE',               // table\r\n  TABULAR_PARAMETERS:  'TABULAR_PARAMETERS',  // LaTeX tabular parameters\r\n  TAG:                 'TAG',                 // formatting tag\r\n  UNKNOWN:             'UNKNOWN',             // unrecognized element\r\n  VERTICAL_SKIP:       'VERTICAL_SKIP',       // any type of vertical skip\r\n  WORD:                'WORD',                // sequence of letters\r\n  WRAPPER:             'WRAPPER'              // wrapper for something\r\n};\r\nexport type Lexeme = keyof typeof Lexeme;\r\n\r\n/**\r\n * LaTeX modes\r\n * @enum {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const modes = {\r\n  LIST:     'LIST',    // list of items\r\n  MATH:     'MATH',    // mathematical expressionLatex\r\n  PICTURE:  'PICTURE', // picture\r\n  TABLE:    'TABLE',   // LaTeX tabular\r\n  TEXT:     'TEXT',    // general text\r\n  VERTICAL: 'VERTICAL' // vertical spacing\r\n};\r\n\r\nexport type Mode = keyof typeof modes;\r\n\r\nexport function isMode(x: any): x is Mode {\r\n  return modes.hasOwnProperty(x);\r\n}\r\n\r\nexport function mustBeMode(x: any): Mode {\r\n  if(!isMode(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\nexport type ModeStates = {[mode: string]: boolean};\r\n/**\r\n * LaTeX state encapsulation\r\n * @class\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class State {\r\n  private modeStates_: ModeStates;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Object.<Mode,boolean>=} opt_initialModeStates the initial mode states\r\n   * @constructor\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  constructor(opt_initialModeStates: ModeStates = {}) {\r\n    Object.defineProperty(this, 'modeStates_', { value: { }, enumerable: false });\r\n\r\n    this.modeStates_[modes.LIST]     = false;\r\n\r\n    this.modeStates_[modes.MATH]     = false;\r\n\r\n    this.modeStates_[modes.PICTURE]  = false;\r\n\r\n    this.modeStates_[modes.TABLE]    = false;\r\n\r\n    this.modeStates_[modes.TEXT]     = true;\r\n    //noinspection JSUnresolvedVariable\r\n    this.modeStates_[modes.VERTICAL] = false;\r\n    // update the mode states\r\n    if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Create a copy of this state.\r\n   * @return {!State} the created copy\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  copy() {\r\n    //noinspection JSValidateTypes,JSUnresolvedVariable\r\n    return new State(this.modeStates_);\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the state with states for modes\r\n   * @param {!Object.<Mode,boolean>} modeStates the states for modes\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  update(modeStates: ModeStates) {\r\n    for (let modeKey in modeStates) { // for all the given modes\r\n      //noinspection JSUnfilteredForInLoop\r\n      let mode = modes[mustBeMode(modeKey)]; // verify the mode key\r\n      if (mode === undefined) // if the mode is unknown\r\n        throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\r\n      //noinspection JSUnfilteredForInLoop,JSUnresolvedVariable\r\n      this.modeStates_[mode] = modeStates[modeKey]; // store the mode state\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Test the state with mode states\r\n   * @param {!Object.<Mode,boolean>} modeStates the states for modes\r\n   * @return {boolean} true if the state fits the modes, false otherwise\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  test(modeStates: ModeStates) {\r\n    for (let modeKey in modeStates) { // for all the given modes\r\n      let mode = modes[mustBeMode(modeKey)]; // verify the mode key\r\n      if (mode === undefined) // if the mode is unknown\r\n        throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\r\n      // exit if the mode has different states\r\n      if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\r\n    }\r\n    return true;\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * LaTeX directive\r\n * @enum {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const Directive = {\r\n  BEGIN: 'BEGIN', // begin something\r\n  END:   'END'    // end something\r\n};\r\nexport type Directive = keyof typeof Directive;\r\n\r\n\r\n/**\r\n * Group operand for directives\r\n * @const {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const GROUP = 'GROUP';\r\nexport type GROUP = 'GROUP';\r\n\r\n\r\n\r\n/**\r\n * LaTeX operation properties\r\n * @interface OperationProperties\r\n * @property {Directive} directive - The directive or undefined if there is no a directive\r\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport interface OperationProperties {\r\n  directive: Directive;\r\n  operand: Mode|GROUP;\r\n}\r\nexport function isOperationProperties(x: any): x is OperationProperties {\r\n  return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\r\n}\r\n\r\nexport function mustBeOperationProperties(x: any): OperationProperties {\r\n  if(!isOperationProperties(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX operation encapsulation\r\n * @class\r\n * @property {Directive} directive - The directive or undefined if there is no a directive\r\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class Operation {\r\n  directive: Directive;\r\n  operand: Mode | GROUP;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!OperationProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  constructor(opt_initialProperties?: OperationProperties) {\r\n    // do nothing if the initial properties aren't defined\r\n    if (opt_initialProperties === undefined) return;\r\n    if (!(opt_initialProperties instanceof Object))\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    let directive = Directive[opt_initialProperties.directive]; // validate the directive\r\n    if (!directive)\r\n      throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\r\n    Object.defineProperty(this, 'directive', { value: directive, enumerable: true });\r\n    switch (opt_initialProperties.operand) {\r\n    case GROUP: // if operand is a group\r\n      // store the operand\r\n      Object.defineProperty(this, 'operand', { value: GROUP, enumerable: true });\r\n      break;\r\n    default:\r\n      let mode = modes[opt_initialProperties.operand]; // validate the operand as a mode\r\n      if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\r\n      // store the operand\r\n      Object.defineProperty(this, 'operand', { value: mode, enumerable: true });\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this operation with the other\r\n   * @param {!Operation} other the operation to compare with\r\n   * @return {boolean} True if the operations are equal false otherwise\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Operation)) return false; // type test\r\n    return this.directive === other.directive && this.operand === other.operand;\r\n  };\r\n};\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex.ts","/**\r\n * @fileoverview LaTeX style structures\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/**@module */\r\n\r\n\r\nimport {isNumber, mustNotBeUndefined, testProperties} from './Utils'; // object property testing function\r\n\r\nimport {\r\n  Lexeme, Mode, modes, mustBeMode, mustBeOperationProperties, Operation, OperationProperties,\r\n  State\r\n} from './Latex';\r\n\r\n\r\nfunction isArray(x: any): x is any[] {\r\n  return x.constructor === Array\r\n}\r\n\r\nfunction mustBeArray(x: any): any[] {\r\n  if (!isArray(x))throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX style package properties\r\n * @interface PackageProperties\r\n * @property {(!Array.<!SymbolProperties>|undefined)} symbols - The symbols of the package in the priority descending order\r\n * @property {(!Array.<!CommandProperties>|undefined)} commands - The commands of the package in the priority descending order\r\n * @property {(!Array.<!EnvironmentProperties>|undefined)} environments - The environments of the package\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface PackageProperties {\r\n  symbols?: SymbolProperties[];\r\n  commands?: CommandProperties[];\r\n  environments?: EnvironmentProperties[];\r\n}\r\n\r\n/**\r\n * LaTeX style collection\r\n * @class\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class LatexStyle {\r\n  private environments_: { [name: string]: EnvironmentAndPackage[] };\r\n  private commands_: { [name: string]: CommandAndPackage[] };\r\n  private symbols_: { [name: string]: SymbolAndPackage[] };\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor() {\r\n    /**\r\n     * The symbols by the first symbol of the pattern in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Symbol>>}\r\n     * @name symbols_\r\n     */\r\n    this.symbols_ = {};\r\n    /**\r\n     * The commands by the name in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Command>>}\r\n     * @name commands_\r\n     */\r\n    this.commands_ = {};\r\n    /**\r\n     * The environments by the name in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Environment>>}\r\n     * @name environments_\r\n     */\r\n    this.environments_ = {};\r\n  };\r\n\r\n\r\n  /**\r\n   * Load a package with style definitions\r\n   * @param {string} packageName the name of the style package\r\n   * @param {PackageProperties} stylePackage the style package\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  loadPackage(packageName: string, stylePackage: PackageProperties) {\r\n    if (stylePackage.symbols !== undefined) { // if the symbol descriptions are defined\r\n      if (!(stylePackage.symbols instanceof Array))\r\n        throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\r\n      // for all the symbol descriptions\r\n      for (let iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\r\n        let symbol: Symbol = new Symbol(stylePackage.symbols[iSymbol]); // the symbol description\r\n        if (symbol.pattern) { // if the symbol has a pattern\r\n          let symbolPatternFirstChar = symbol.pattern[0]; // the first char of the pattern\r\n          // the symbols with the same pattern first char\r\n          if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar))\r\n            this.symbols_[symbolPatternFirstChar] = [];\r\n          let symbols: SymbolAndPackage[] = this.symbols_[symbolPatternFirstChar];\r\n\r\n          symbols.push({symbol, packageName}); // store the symbol and the package name\r\n        }\r\n      }\r\n    }\r\n    if (stylePackage.commands !== undefined) { // if the command descriptions are defined\r\n      if (!(stylePackage.commands instanceof Array))\r\n        throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\r\n      // for all the command descriptions\r\n      for (let iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\r\n        let command = new Command(stylePackage.commands[iCommand]); // the command description\r\n        if (command.name) { // if the command has a name\r\n          // the commands with the same name\r\n          (this.commands_[command.name] || (this.commands_[command.name] = []))\r\n            .push({command, packageName}); // store the command and the package name\r\n        }\r\n      }\r\n    }\r\n    if (stylePackage.environments !== undefined) { // if the environment descriptions are defined\r\n      if (!(stylePackage.environments instanceof Array))\r\n        throw new TypeError(`\"stylePackage.environments\" isn't an Array`);\r\n      // for all the environment descriptions\r\n      for (let iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0;\r\n           --iEnvironment) {\r\n        // the environment description\r\n        let environment: Environment = new Environment(stylePackage.environments[iEnvironment]);\r\n        const envName: string = environment.name;\r\n        if (envName) { // if the environment has a name\r\n          // the environments with the same name\r\n          let storedEnv = this.environments_[envName];\r\n          if (storedEnv === undefined) {\r\n            storedEnv = [];\r\n            this.environments_[envName] = storedEnv;\r\n          }\r\n          storedEnv.push({environment, packageName}); // store the environment and the package name\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Unload a package with style definitions\r\n   * @param {string} packageName the name of the style package\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  unloadPackage(packageName: string) {\r\n    // for all the symbol pattern first chars\r\n    for (let symbolPatternFirstChar in this.symbols_)\r\n      if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\r\n        // the filtered symbols with the same pattern first char\r\n        let filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(styleItem => {\r\n          return styleItem.packageName !== packageName;\r\n        });\r\n        // if there are still some symbols with the same pattern first char\r\n        if (filteredSymbols.length) {\r\n          // store the filtered symbol descriptions\r\n          this.symbols_[symbolPatternFirstChar] = filteredSymbols;\r\n        } else { // if there are no the symbols with the same pattern first char\r\n          delete this.symbols_[symbolPatternFirstChar]; // delete the key-value pair\r\n        }\r\n      }\r\n    // for all the command names\r\n    for (let commandName in this.commands_) if (this.commands_.hasOwnProperty(commandName)) {\r\n      // the filtered commands with the same name\r\n      let filteredCommands = mustBeArray(this.commands_[commandName]).filter(styleItem => {\r\n        return styleItem.packageName !== packageName;\r\n      });\r\n      if (filteredCommands.length) { // if there are still some commands with the same name\r\n        this.commands_[commandName] = filteredCommands; // store the filtered command descriptions\r\n      } else { // if there are no the commands with the same name\r\n        delete this.commands_[commandName]; // delete the key-value pair\r\n      }\r\n    }\r\n    // for all the environment names\r\n    for (let environmentName in this.environments_)\r\n      if (this.environments_.hasOwnProperty(environmentName)) {\r\n        // the filtered environments with the same name\r\n        let filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(styleItem => {\r\n          return styleItem.packageName !== packageName;\r\n        });\r\n        // if there are still some environments with the same name\r\n        if (filteredEnvironments.length) {\r\n          // store the filtered environment descriptions\r\n          this.environments_[environmentName] = filteredEnvironments;\r\n        } else { // if there are no the environments with the same name\r\n          delete this.environments_[environmentName]; // delete the key-value pair\r\n        }\r\n      }\r\n  };\r\n\r\n\r\n  /**\r\n   * Get symbols\r\n   * @param {!State} state the state that the symbols must match to\r\n   * @param {string} patternFirstChar the first char of the symbol parameter pattern\r\n   * @return {!Array.<!Symbol>} the list of symbols in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  symbols(state: State, patternFirstChar: string) {\r\n    if (!(state instanceof State))\r\n      throw new SyntaxError('\"state\" isn\\'t a State instance');\r\n    // all the symbols with the defined first pattern char\r\n    let symbols = this.symbols_[patternFirstChar];\r\n    if (symbols === undefined) return []; // return empty list if there are no such symbols\r\n    let filteredSymbols = []; // the list of the symbols matching to the state\r\n    for (let iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) { // for all the symbols\r\n      let symbol = symbols[iSymbol].symbol; // the symbol\r\n      // store the symbol if it matches to the state\r\n      //noinspection JSUnresolvedFunction\r\n      if (state.test(symbol.modes)) filteredSymbols.push(symbol);\r\n    }\r\n    return filteredSymbols;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get commands\r\n   * @param {!State} state the state that the commands must match to\r\n   * @param {!string} name the name of the command\r\n   * @return {Array.<Command>} the list of commands in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  commands(state: State, name: string): Command[] {\r\n    if (!(state instanceof State))\r\n      throw new SyntaxError('\"state\" isn\\'t a State instance');\r\n    let commands = this.commands_[name]; // all the commands with the defined name\r\n    if (!commands) return []; // return empty list if there are no such commands\r\n    let filteredCommands = []; // the list of the commands matching to the state\r\n    for (let iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) { // for all the commands\r\n      let command = commands[iCommand].command; // the command\r\n      // store the command if it matches to the state\r\n      //noinspection JSUnresolvedFunction\r\n      if (state.test(command.modes)) filteredCommands.push(command);\r\n    }\r\n    return filteredCommands;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get environments\r\n   * @param {!State} state the state that the environments must match to\r\n   * @param {!string} name the name of the environment\r\n   * @return {Array.<Environment>} the list of environments in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  environments(state: State, name: string): EnvironmentAndPackage[] {\r\n    if (!(state instanceof State)) throw new SyntaxError('state isn\\'t State instance');\r\n    let environments: EnvironmentAndPackage[] = this.environments_[name]; // all the environments with the defined name\r\n    if (!environments) return []; // return empty list if there are no such environments\r\n\r\n    // store the environment if it matches to the state\r\n    return mustBeArray(environments)\r\n      .filter(env => state.test(env.modes));\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * LaTeX style item properties\r\n * @interface ItemProperties\r\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme\r\n * @property {(!Object.<Mode, boolean>|undefined)} modes -\r\n *           The modes where the item is defined or not\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ItemProperties {\r\n  lexeme?: Lexeme;\r\n  modes?: { [mode: string]: boolean };\r\n}\r\n\r\n\r\n/**\r\n * LaTeX style item encapsulation\r\n * @class\r\n * @property {(?Lexeme)} lexeme - The logical lexeme\r\n * @property {!Object.<Mode, boolean>} modes - The modes where the item is defined or not\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Item {\r\n  lexeme?: Lexeme;\r\n  modes: { [mode: string]: boolean };\r\n\r\n  /**\r\n   * Constructor.\r\n   * @param {!ItemProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: ItemProperties = {}) {\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (!(opt_initialProperties instanceof Object))\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    switch (opt_initialProperties.lexeme) {\r\n      case undefined:\r\n        break; // do nothing if no lexeme defined\r\n      case null:\r\n        break; // do nothing if the default lexeme defined\r\n      default:\r\n        let lexeme = Lexeme[opt_initialProperties.lexeme]; // verify the lexeme\r\n        if (lexeme === undefined)\r\n          throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\r\n        Object.defineProperty(this, 'lexeme', {value: lexeme});\r\n    }\r\n    if (opt_initialProperties.modes !== undefined) {// if the mode states are set\r\n      if (!(opt_initialProperties.modes instanceof Object))\r\n        throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\r\n      Object.defineProperty(this, 'modes', {value: {}}); // create the mode state storage\r\n      for (let modeKey in opt_initialProperties.modes) { // for all the given modes // TODO better loop\r\n        let mode: Mode = mustBeMode(modeKey); // verify the mode key\r\n        if (mode === undefined) // if the mode is unknown\r\n          throw new TypeError('\"initialProperties.modes[' + modeKey +\r\n            ']\" isn\\'t a Mode option');\r\n        // store the mode state\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(this.modes, mode, {\r\n          value: opt_initialProperties.modes[modeKey],\r\n          enumerable: true\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Compare this item with the other one\r\n   * @param {?Item} other the item to compare with\r\n   * @return {boolean} true if the items are equal, false otherwise\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Item)) return false;\r\n    return this.lexeme === other.lexeme &&\r\n      testProperties(this.modes, other.modes, modes, false);\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Item.prototype, { // default property values\r\n  lexeme: {value: undefined, enumerable: true}, // no lexeme by default\r\n  modes: {value: {}, enumerable: true} // no mode mask by default\r\n});\r\n\r\n\r\n/**\r\n * LaTeX symbol or command parameter properties\r\n * @interface ParameterProperties\r\n * @extends ItemProperties\r\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations -\r\n *           The LaTeX operations that are performed before the parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ParameterProperties extends ItemProperties {\r\n  operations?: (Operation | OperationProperties)[];\r\n}\r\n\r\nexport function isParameterProperties(ignored: any): ignored is ParameterProperties {\r\n  return true; // todo fields are all optional\r\n}\r\n\r\nexport function mustBeParameterProperties(x: any): ParameterProperties {\r\n  if (!isParameterProperties) throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX symbol or command parameter encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {!Array.<!Operation>} operations -\r\n *           The LaTeX operations that are performed before this parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Parameter extends Item {\r\n  //noinspection JSMismatchedCollectionQueryUpdate TODO\r\n  private operations_: Operation[];\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!ParameterProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: ParameterProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.operations !== undefined) { // if the operation list is set\r\n      if (!(opt_initialProperties.operations instanceof Array))\r\n        throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\r\n      Object.defineProperty(this, 'operations_', { // generate and store the operations list\r\n        value: opt_initialProperties.operations.map(operation => new Operation(operation))\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX operations that are performed before this parameter\r\n   * @return {!Array.<!Operation>} the operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get operations(): Operation[] {\r\n    return this.operations_.slice()\r\n  }\r\n\r\n\r\n  /**\r\n   * Compare this parameter with the other one\r\n   * @param {?Parameter} other the parameter to compare with\r\n   * @return {boolean} true if the parameters are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Parameter)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n\r\n    if (this.operations_.length !== other.operations_.length) return false;\r\n    // test all the operations\r\n\r\n    return this.operations_.every((operation, iOperation) =>\r\n      operation.equals(other.operations_[iOperation]));\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Parameter.prototype, { // make getters and setters enumerable\r\n  operations: {enumerable: true}\r\n});\r\nObject.defineProperties(Parameter.prototype, { // default property values\r\n  operations_: {value: [], enumerable: false} // empty operation list by default\r\n});\r\n\r\n\r\n/**\r\n * LaTeX symbol properties\r\n * @interface SymbolProperties\r\n * @extends ItemProperties\r\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations - The LaTeX operations that\r\n * @property {(!Array.<!Parameter|!ParameterProperties>|undefined)} parameters - The parameters description list\r\n * @property {(string|undefined)} pattern - The LaTeX input pattern\r\n * @property {(string|undefined)} html - The HTML output pattern\r\n * are performed after the symbol\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SymbolProperties extends ItemProperties {\r\n  operations?: (Operation | OperationProperties)[];\r\n  parameters?: (Parameter | ParameterProperties)[];\r\n  pattern?: string;\r\n  html?: string;\r\n}\r\n\r\nexport interface SymbolAndPackage {\r\n  symbol: Symbol;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * LaTeX symbol encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {!Array.<!Operation>} operations -\r\n *           The LaTeX operations that are performed after this symbol\r\n * @property {!Array.<!Parameter>} parameters - The parameters description list\r\n * @property {!Array.<undefined|string|number>} patternComponents - The LaTeX input pattern components\r\n * @property {string} pattern - The LaTeX input pattern\r\n * @property {string} html - The HTML output pattern\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Symbol extends Item {\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private operations_: Operation[];\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private parameters_: Parameter[];\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private patternComponents_: (undefined | string | number)[];\r\n\r\n  html: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SymbolProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: SymbolProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.operations !== undefined) { // if the operation list is set\r\n      if (!(opt_initialProperties.operations instanceof Array))\r\n        throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\r\n      Object.defineProperty(this, 'operations_', { // generate and store the operations list\r\n        value: opt_initialProperties.operations.map(operation => new Operation(mustBeOperationProperties(operation)))\r\n      });\r\n    }\r\n    if (opt_initialProperties.parameters !== undefined) { // if the parameters list is set\r\n      if (!(opt_initialProperties.parameters instanceof Array))\r\n        throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\r\n      // generate and store the parameters list\r\n      this.parameters_ = opt_initialProperties.parameters.map(parameter => new Parameter(mustBeParameterProperties(parameter)));\r\n    }\r\n    if (opt_initialProperties.pattern !== undefined) { // if the LaTeX pattern is set\r\n      if (typeof opt_initialProperties.pattern !== 'string')\r\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\r\n      // try to parse the pattern\r\n      const patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\r\n      if (!!patternComponents) { // if there is a non-trivial pattern\r\n\r\n        // store the pattern components\r\n        this.patternComponents_ = patternComponents.map((patternPart: string): string | undefined | number => {\r\n          switch (patternPart[0]) {\r\n            case ' ':\r\n            case '\\t': // if a space part\r\n              return undefined; // undefined is a mark for spaces\r\n            case '#': // if a parameter part\r\n              let parameterIndex = Number(patternPart.substring(1)) - 1; // the index of a parameter\r\n              if (!this.parameters_[parameterIndex])\r\n                throw new TypeError(\r\n                  '\"initialProperties.pattern\" contains the incorrect parameter number ' +\r\n                  patternPart.substring(1)\r\n                );\r\n              return parameterIndex;\r\n            default: // raw pattern part\r\n              return patternPart;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    if (opt_initialProperties.html !== undefined) { // if the LaTeX pattern is set\r\n      if (typeof opt_initialProperties.html !== 'string')\r\n        throw new TypeError('\"initialProperties.html\" isn\\'t a string');\r\n      // store the pattern\r\n      Object.defineProperty(this, 'html', {value: opt_initialProperties.html, enumerable: true});\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the LaTeX operations that are performed after this symbol\r\n   * @return {!Array.<!Operation>} the operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get operations(): Operation[] {\r\n    return this.operations_.slice()\r\n  }\r\n\r\n  /**\r\n   * Get the parameters description list\r\n   * @return {!Array.<!Latex.Parameter>} the parameter list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get parameters(): Parameter[] {\r\n    return this.parameters_.slice()\r\n  }\r\n\r\n  /**\r\n   * Get the parameter description\r\n   * @param {number} parameterIndex the index of the parameter\r\n   * @return {?Latex.Parameter} the parameter or undefined if there is no parameter with such an index\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parameter(parameterIndex: number): Parameter | undefined {\r\n    return this.parameters_[parameterIndex] || undefined\r\n  }\r\n\r\n  /**\r\n   * Get the pattern components\r\n   * @return {!Array.<!Latex.Parameter>} the pattern component list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get patternComponents(): any[] {\r\n    return mustNotBeUndefined(this.patternComponents_.slice())\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the pattern\r\n   * @return {string} the LaTeX input pattern\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get pattern() {\r\n    return this.patternComponents_.map(patternComponent => {\r\n      if (isNumber(patternComponent)) {\r\n        return '#' + (patternComponent + 1);\r\n      }\r\n      switch (typeof patternComponent) {\r\n        case 'string':\r\n          return patternComponent;\r\n        default:\r\n          return ' ';\r\n      }\r\n    }).join('');\r\n  }\r\n\r\n  /**\r\n   * Compare this symbol with the other one\r\n   * @param {?Symbol} other the symbol to compare with\r\n   * @return {boolean} true if the symbols are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any): boolean {\r\n    if (!(other instanceof Symbol)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n\r\n    if (this.operations_.length !== other.operations_.length) return false;\r\n    // test all the operations\r\n\r\n    if (!this.operations_.every((operation, iOperation) =>\r\n        operation.equals(other.operations_[iOperation])))\r\n      return false;\r\n\r\n    if (this.parameters_.length !== other.parameters_.length) return false;\r\n    // test all the parameters\r\n\r\n    if (!this.parameters_.every((parameter, iParameter) =>\r\n        parameter.equals(other.parameters_[iParameter])))\r\n      return false;\r\n    return this.html === other.html;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Symbol.prototype, { // make getters and setters enumerable\r\n  operations: {enumerable: true},\r\n  parameters: {enumerable: true},\r\n  patternComponents: {enumerable: true},\r\n  pattern: {enumerable: true}\r\n});\r\n\r\nObject.defineProperties(Symbol.prototype, { // default property values\r\n  operations_: {value: [], enumerable: false, writable: true}, // empty operation list\r\n  parameters_: {value: [], enumerable: false, writable: true}, // empty parameter list\r\n  patternComponents_: {value: [], enumerable: false, writable: true}, // empty pattern\r\n  html: {value: '', enumerable: true, writable: true} // empty HTML pattern\r\n});\r\n\r\n\r\n/**\r\n * LaTeX command properties\r\n * @interface CommandProperties\r\n * @extends SymbolProperties\r\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface CommandProperties extends SymbolProperties {\r\n  name?: string;\r\n}\r\n\r\nexport interface CommandAndPackage {\r\n  command: Command;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * LaTeX command encapsulation\r\n * @class\r\n * @extends Symbol\r\n * @property {string} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Command extends Symbol {\r\n  name: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!CommandProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: CommandProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.name !== undefined) { // if the name is set\r\n      if (typeof opt_initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      // store the name\r\n      Object.defineProperty(this, 'name', {value: opt_initialProperties.name});\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this command with the other one\r\n   * @param {?Command} other the command to compare with\r\n   * @return {boolean} true if the commands are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Command)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n    return this.name === other.name;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Command.prototype, { // default property values\r\n  name: {value: '', enumerable: true} // empty name\r\n});\r\nexport function isCommand(c: any): c is Command {\r\n  return c instanceof Command;\r\n}\r\nexport function mustBeCommand(c: any): Command {\r\n  if (!isCommand(c)) throw new Error();\r\n  return c;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX command properties\r\n * @interface EnvironmentProperties\r\n * @extends ItemProperties\r\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface EnvironmentProperties extends ItemProperties {\r\n  name?: string;\r\n}\r\n\r\nexport interface EnvironmentAndPackage {\r\n  environment: Environment;\r\n  packageName?: string;\r\n}\r\n\r\n/**\r\n * LaTeX environment encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {string} name - The environment name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Environment extends Item {\r\n  name: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!EnvironmentProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: EnvironmentProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.name !== undefined) { // if the name is set\r\n      if (typeof opt_initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      // store the name\r\n      Object.defineProperty(this, 'name', {value: opt_initialProperties.name});\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this environment with the other one\r\n   * @param {?Environment} other the environment to compare with\r\n   * @return {boolean} true if the environments are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Environment)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n    return this.name === other.name;\r\n  }\r\n}\r\n\r\nObject.defineProperties(Environment.prototype, { // default property values\r\n  name: {value: \"\", enumerable: true} // empty name\r\n});\r\n\r\nexport function isEnvironment(x: any): x is Environment {\r\n  return x instanceof Environment;\r\n}\r\n\r\n// export default LatexStyle;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle.ts","/**\r\n * @fileoverview LaTeX syntax tree structure elements\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/** @module */\r\n\r\n/** @external LatexStyle*/\r\nimport {Command, Environment, isEnvironment, mustBeCommand, Parameter, Symbol} from './LatexStyle'; // LaTeX style structures\r\n/** @external SyntaxTree */\r\nimport {SyntaxTree, Node} from './SyntaxTree';\r\nimport {Lexeme} from \"./Latex\";\r\nimport {mustNotBeUndefined} from \"./Utils\";\r\n\r\n\r\n/**\r\n * LaTeX syntax tree structure\r\n * @class\r\n * @extends SyntaxTree\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class LatexTree extends SyntaxTree {\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Token} rootToken the root token (must have no parent and no tree)\r\n   * @param {string} source the sources text that has this syntax tree\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(rootToken: Token, source: string) {\r\n    if (!(rootToken instanceof Token))\r\n      throw new TypeError('\"rootToken\" isn\\'t a Token instance');\r\n    super(rootToken, source); // the superclass constructor\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * LaTeX syntax tree token base properties\r\n * @interface TokenProperties\r\n * @property {(?Token|undefined)} parentToken - The parent token or undefined if there is no parent\r\n * @property {(!Array.<Token>|undefined)} childTokens - The list of the child tokens\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface TokenProperties {\r\n  parentToken?: Token;\r\n  childTokens?: Token[];\r\n}\r\n\r\n\r\n/**\r\n * LaTeX syntax tree token base structure\r\n * @class\r\n * @extends SyntaxTree.Node\r\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme of the token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Token extends Node {\r\n  lexeme?: Lexeme;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!TokenProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(opt_initialProperties: TokenProperties = {}) {\r\n    if (opt_initialProperties === undefined) { // if the initial properties are not set\r\n      super(); // superclass constructor\r\n    } else if (opt_initialProperties instanceof Object) { // if the initial properties are set\r\n      // superclass constructor\r\n      // superclass initial properties\r\n      let superInitialProperties = Object.create(opt_initialProperties);\r\n      superInitialProperties.parentNode = opt_initialProperties.parentToken;\r\n      superInitialProperties.childNodes = opt_initialProperties.childTokens;\r\n      super(superInitialProperties);\r\n    } else { // if the initial properties are in unsupported type\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ? super.toString(true) : 'Token{' + super.toString(true) + '}';\r\n  }\r\n};\r\nObject.defineProperties(Token.prototype, { // default properties\r\n  lexeme: { value: undefined, enumerable: true }, // no lexeme\r\n  parentNodeClass_: { value: Token } // parent node must be an EnvironmentToken instance\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX symbol token properties\r\n * @interface SymbolTokenProperties\r\n * @extends TokenProperties\r\n * @property {!Symbol|undefined} symbol - The LaTeX symbol or undefined if the symbol is unrecognized\r\n * @property {string|undefined} pattern - The pattern that corresponds to the unrecognized symbol\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SymbolTokenProperties extends TokenProperties {\r\n  symbol?: Symbol;\r\n  pattern?: string;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX symbol token structure\r\n * @class\r\n * @extends Token\r\n * @property {?Symbol} symbol - The corresponding LaTeX symbol or undefined if the symbol is unrecognized\r\n * @property {string} pattern - The symbol LaTeX pattern\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SymbolToken extends Token {\r\n  symbol?: Symbol;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SymbolTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SymbolTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (initialProperties.symbol) { // if the symbol is defined\r\n      if (!(initialProperties.symbol instanceof Symbol))\r\n        throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\r\n      // store the symbol\r\n      Object.defineProperty(this, 'symbol', {value: initialProperties.symbol, enumerable: true});\r\n    } else { // if the symbol isn't defined\r\n      if (typeof initialProperties.pattern !== 'string')\r\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\r\n      // store the unrecognized pattern\r\n      Object.defineProperty(this, 'pattern', { value: initialProperties.pattern });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme | undefined {\r\n    \r\n    return this.symbol ? this.symbol.lexeme : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the symbol LaTeX pattern\r\n   * @return {string} the symbol pattern\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get pattern (): string {\r\n    return mustNotBeUndefined(this.symbol).pattern;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    let source = '';\r\n    let iParameter = 0; // the parameter iterator\r\n    \r\n    let pattern = this.pattern; // LaTeX input pattern\r\n    // for all the pattern chars\r\n    for (\r\n      let nPatternChars = pattern.length, iPatternChar = 0;\r\n      iPatternChar < nPatternChars;\r\n      ++iPatternChar\r\n    ) {\r\n      let patternChar = pattern[iPatternChar]; // the pattern char\r\n      if (patternChar === '#') { // if a parameter place\r\n        ++iPatternChar; // go to the next pattern char\r\n        let parameterToken = this.childNode(iParameter++); // try to get the parameter token\r\n        source += parameterToken ? parameterToken.toString(true) : '??';\r\n      } else { // if the ordinary pattern char\r\n        source += patternChar;\r\n      }\r\n    }\r\n    return skipNodeClass ?\r\n      source :\r\n      'SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(SymbolToken.prototype, { // default properties\r\n  symbol: { value: undefined, enumerable: true } // no symbol token\r\n});\r\nObject.defineProperties(SymbolToken.prototype, { // make getters and setters enumerable\r\n  pattern: { enumerable: true }\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX parameter token properties\r\n * @interface ParameterTokenProperties\r\n * @extends TokenProperties\r\n * @property {boolean} hasBrackets - True if the parameter is bounded by the logical brackets, false otherwise\r\n * @property {boolean} hasSpacePrefix - True if the parameter is prefixed by a space, false otherwise\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ParameterTokenProperties extends TokenProperties {\r\n  hasBrackets: boolean;\r\n  hasSpacePrefix: boolean;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX parameter token structure\r\n * @class\r\n * @extends Token\r\n * @property {boolean} hasBrackets -\r\n *           True if the parameter is bounded by the logical brackets, false otherwise\r\n * @property {boolean} hasSpacePrefix -\r\n *           True if the parameter is prefixed by a space, false otherwise\r\n * @property {?LatexStyle.Parameter} parameter - The corresponding LaTeX parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class ParameterToken extends Token {\r\n  public parentNode: SymbolToken;\r\n\r\n  private hasBrackets: boolean;\r\n  hasSpacePrefix: boolean;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!ParameterTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: ParameterTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!initialProperties.hasBrackets) // if there are no bounding brackets\r\n      // store this fact\r\n      Object.defineProperty(this, 'hasBrackets', { value: false, enumerable: true });\r\n    if (initialProperties.hasSpacePrefix) // if there is a space before\r\n      // store this fact\r\n      Object.defineProperty(this, 'hasSpacePrefix', { value: true, enumerable: true });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme | undefined {\r\n    if(this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the corresponding LaTeX parameter description\r\n   * @return {?LatexStyle.Parameter}\r\n   *         the LaTeX parameter or undefined of there is parent symbol or such a parameter\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get parameter (): Parameter | undefined {\r\n    /** @type {?SymbolToken} */\r\n    let symbolToken = this.parentNode; // get the symbol token\r\n    let symbol = mustNotBeUndefined(symbolToken.symbol);\r\n    let parameterIndex = symbolToken.childIndex(this);\r\n    if(symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0)\r\n      return symbol.parameter(parameterIndex);\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    let source = this.hasSpacePrefix ? ' ' : '';\r\n    source += this.hasBrackets ? '{' + super.toString(true) + '}' : super.toString(true);\r\n    return skipNodeClass ? source : 'ParameterToken{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(ParameterToken.prototype, { // default properties\r\n  hasBrackets: { value: true, enumerable: true }, // there are bounding brackets\r\n  hasSpacePrefix: { value: false, enumerable: true }, // there is no space before\r\n  parentNodeClass_: { value: SymbolToken } // parent node must be a SymbolToken instance\r\n});\r\nObject.defineProperties(ParameterToken.prototype, { // make getters and setters enumerable\r\n  parameter: { enumerable: true }\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX command token properties\r\n * @interface CommandTokenProperties\r\n * @extends TokenProperties\r\n * @property {!LatexStyle.Command|undefined} command -\r\n *           The LaTeX command or undefined if the command is unrecognized\r\n * @property {string|undefined} name - The name that corresponds to the unrecognized command\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface CommandTokenProperties extends TokenProperties {\r\n  command?: Command;\r\n  name?: string;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX command token structure\r\n * @class\r\n * @extends SymbolToken\r\n * @property {!LatexStyle.Command} command -\r\n *           The corresponding LaTeX command or undefined if the command is unrecognized\r\n * @property {string|undefined} name - The LaTeX command name\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class CommandToken extends SymbolToken {\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!CommandTokenProperties} initialProperties the initial property values\r\n   */\r\n  constructor(initialProperties: CommandTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    // copy the initial properties for the superclass\r\n    let superInitialProperties = Object.create(initialProperties);\r\n    if (initialProperties.command) { // if the command is defined\r\n      if (!(initialProperties.command instanceof Command))\r\n        throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\r\n      // the command is the symbol for the superclass\r\n      superInitialProperties.symbol = initialProperties.command;\r\n      super(superInitialProperties); // the superclass constructor\r\n    } else { // if the command isn't defined\r\n      if (typeof initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      superInitialProperties.pattern = '';\r\n      super(superInitialProperties); // the superclass constructor\r\n      // store the unrecognized name\r\n      Object.defineProperty(this, 'name', { value: initialProperties.name });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX command\r\n   * @return {!LatexStyle.Command} the command description\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get command (): Command { return mustBeCommand(this.symbol) }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX command name\r\n   * @return {string} the command name\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get name (): string { return this.command.name }\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n   let source = '\\\\' + this.name + super.toString(true);\r\n   return skipNodeClass ?\r\n     source :\r\n     'CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\r\n  }\r\n};\r\n\r\nObject.defineProperties(CommandToken.prototype, { // make getters and setters enumerable\r\n  command: { enumerable: true },\r\n  name: {enumerable: true }\r\n});\r\n\r\nexport function isCommandToken(x: any): x is CommandToken {\r\n  return x && x instanceof CommandToken;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX environment token properties\r\n * @interface EnvironmentTokenProperties\r\n * @extends TokenProperties\r\n * @property {!LatexStyle.Environment} environment - The LaTeX environment\r\n * @property\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\n\r\nexport interface EnvironmentTokenPropertiesWithEnvironment\r\n  extends EnvironmentTokenProperties {\r\n  environment: Environment;\r\n  name: undefined;\r\n}\r\n\r\nexport interface EnvironmentTokenPropertiesWithName\r\n  extends EnvironmentTokenProperties {\r\n  environment: undefined;\r\n  name: string;\r\n}\r\n\r\nexport interface EnvironmentTokenProperties\r\n  extends TokenProperties {\r\n  environment?: Environment;\r\n  name?: string;\r\n}\r\n\r\n/**\r\n * LaTeX environment token structure\r\n * @class\r\n * @extends Token\r\n * @property {!Environment} environment - The corresponding LaTeX environment\r\n * @property {?CommandToken} beginCommandToken -\r\n *           The environment begin command token or undefined is there is no such a token\r\n * @property {?CommandToken} endCommandToken -\r\n *           The environment end command token or undefined is there is no such a token\r\n * @property {?EnvironmentBodyToken} bodyToken -\r\n *           The environment body token or undefined is there is no such a token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class EnvironmentToken extends Token {\r\n  environment: Environment;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!EnvironmentTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: EnvironmentTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!(initialProperties.environment instanceof Environment))\r\n      throw new TypeError(\r\n        '\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\r\n    // store the environment\r\n    Object.defineProperty(this, 'environment', {\r\n      value: initialProperties.environment,\r\n      enumerable: true\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme () { return this.environment.lexeme }\r\n\r\n\r\n  /**\r\n   * Get the begin command token\r\n   * @return {?CommandToken} the command token or undefined if there is no begin command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get beginCommandToken () {\r\n    let beginCommandToken = this.childNode(0);\r\n    return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the end command token\r\n   * @return {?CommandToken} the command token or undefined if there is no end command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get endCommandToken () {\r\n    let endCommandToken = this.childNode(2);\r\n    return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment body token\r\n   * @return {?EnvironmentBodyToken} the body or undefined if there is no body\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get bodyToken () {\r\n    let bodyToken = this.childNode(1);\r\n    return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass:boolean=false) {\r\n    let beginCommandToken = this.beginCommandToken; // the begin command token\r\n    let endCommandToken = this.endCommandToken; // the end command token\r\n    let bodyToken = this.bodyToken; // the environment body token\r\n    let source = '\\\\begin{' + this.environment.name + '}';\r\n    source += beginCommandToken ?\r\n      SymbolToken.prototype.toString.call(beginCommandToken, true) :\r\n      '??';\r\n    source += bodyToken ? bodyToken.toString(true) : '??';\r\n    source += '\\\\end{' + this.environment.name + '}';\r\n    source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\r\n    return skipNodeClass ? source : 'EnvironmentToken{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(EnvironmentToken.prototype, { // make getters and setters enumerable\r\n  beginToken: { enumerable: true },\r\n  endToken: { enumerable: true }\r\n});\r\n\r\nexport function mustBeEnvironmentToken(x: any): EnvironmentToken {\r\n  if(!isEnvironmentToken(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\nexport function isEnvironmentToken(x: any): x is EnvironmentToken {\r\n  return x instanceof EnvironmentToken;\r\n}\r\n\r\n\r\nfunction getBeginCommandToken(x: any): CommandToken | undefined {\r\n  if(isCommandToken(x.beginCommandToken))\r\n    return x.beginCommandToken;\r\n}\r\n\r\nfunction getEndCommandToken(x: any): CommandToken | undefined {\r\n  if(isCommandToken(x.endCommandToken))\r\n    return x.endCommandToken;\r\n}\r\n\r\nfunction getEnvironment(x: any): Environment | undefined {\r\n  if(x.environment && isEnvironment(x.environment))\r\n    return x.environment;\r\n}\r\n\r\n/**\r\n * LaTeX environment body token structure\r\n * @class\r\n * @extends Token\r\n * @property {?LatexStyle.Environment} environment -\r\n *           The LaTeX environment or undefined if there is no parent environment\r\n * @property {?EnvironmentToken} environmentToken - The parent environment token\r\n * @property {?CommandToken} beginCommandToken -\r\n *           The environment begin command token or undefined is there is no such a token\r\n * @property {?CommandToken} endCommandToken -\r\n *           The environment end command token or undefined is there is no such a token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class EnvironmentBodyToken extends Token {\r\n\r\n  /**\r\n   * Get the LaTeX environment\r\n   * @return {?LatexStyle.Environment} the environment or undefined if there is no parent environment\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get environment (): Environment | undefined { return this.parentNode && getEnvironment(this.parentNode) }\r\n\r\n\r\n\r\n  //noinspection JSUnusedGlobalSymbols\r\n  /**\r\n   * Get the parent environment token\r\n   * @return {?EnvironmentToken} the environment or undefined if there is no parent environment\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get environmentToken (): EnvironmentToken | undefined { return this.parentNode && mustBeEnvironmentToken(this.parentNode); }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment begin command token\r\n   * @return {?CommandToken} the command token or undefined if there is no begin command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get beginCommandToken () { return this.parentNode && getBeginCommandToken(this.parentNode) }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment end command token\r\n   * @return {(CommandToken|undefined)} the command token or undefined if there is no end command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get endCommandToken () { return this.parentNode && getEndCommandToken(this.parentNode) }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ?\r\n      super.toString(true) :\r\n      'EnvironmentBodyToken{' + super.toString(true) + '}';\r\n  }\r\n};\r\nObject.defineProperties(EnvironmentBodyToken.prototype, { // default properties\r\n  parentNodeClass_: { value: EnvironmentToken } // parent node must be an EnvironmentToken instance\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX space token properties\r\n * @interface SpaceTokenProperties\r\n * @extends TokenProperties\r\n * @property {number|undefined} lineBreakCount - The number of line breaks\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SpaceTokenProperties\r\n  extends TokenProperties {\r\n  lineBreakCount?: number;\r\n}\r\n\r\n/**\r\n * LaTeX space token structure\r\n * @class\r\n * @extends Token\r\n * @property {number} lineBreakCount - The number of line breaks\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SpaceToken extends Token {\r\n  lineBreakCount: number;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SpaceTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SpaceTokenProperties) {\r\n    if (initialProperties === undefined) {\r\n      super();\r\n      return;\r\n    }\r\n    else if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (initialProperties.lineBreakCount) { // if the line break number is defined\r\n      if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0)\r\n        throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\r\n      // store the line break number\r\n      Object.defineProperty(this, 'lineBreakCount', {\r\n        value: initialProperties.lineBreakCount,\r\n        enumerable: true\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme {\r\n    return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false): string {\r\n    if (skipNodeClass) { // if the node class name must be skipped\r\n      switch (this.lineBreakCount) {\r\n      case 0:\r\n        return ' ';\r\n      case 1:\r\n        return '\\n';\r\n      default:\r\n        return '\\n\\n';\r\n      }\r\n    } else { // if the node class name must be included\r\n      switch (this.lineBreakCount) {\r\n      case 0:\r\n        return 'SpaceToken{ }';\r\n      case 1:\r\n        return 'SpaceToken{\\n}';\r\n      default:\r\n        return 'SpaceToken{\\n\\n}';\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nObject.defineProperties(SpaceToken.prototype, { // default properties\r\n  lineBreakCount: { value: 0, enumerable: true } // line break number\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX source fragment token properties\r\n * @interface SourceTokenProperties\r\n * @extends TokenProperties\r\n * @property {Lexeme} lexeme - The logical lexeme\r\n * @property {string} source - The source fragment\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SourceTokenProperties\r\n  extends TokenProperties {\r\n  lexeme: Lexeme;\r\n  source: string;\r\n}\r\n\r\n/**\r\n * LaTeX source fragment token structure\r\n * @class\r\n * @extends Token\r\n * @property {string} source - The source fragment\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SourceToken extends Token {\r\n  private source: string;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SourceTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SourceTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!Lexeme[initialProperties.lexeme])\r\n      throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\r\n    // store the lexeme\r\n    Object.defineProperty(this, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\r\n    if (typeof initialProperties.source !== 'string')\r\n      throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\r\n    // store the sources\r\n    Object.defineProperty(this, 'source', { value: initialProperties.source, enumerable: true });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ? this.source : 'SourceToken[' + this.lexeme + ']{' + this.source + '}';\r\n  }\r\n};\r\n\r\nexport default SyntaxTree;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexTree.ts","/**\r\n * @fileoverview Syntax tree structure elements\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nimport {isNumber} from \"./Utils\";\r\n\r\n'use strict';\r\n\r\n/**@module */\r\n\r\n\r\n/**\r\n * Syntax tree structure\r\n * @class\r\n * @property {!Node} rootNode - The root node\r\n * @property {string} source - The source text\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SyntaxTree {\r\n  //noinspection JSUnusedGlobalSymbols // TODO\r\n  readonly rootNode: Node;\r\n  readonly source: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Node} rootNode the root node (must have no parent and no tree)\r\n   * @param {string} source the sources text that has this syntax tree\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(rootNode: Node, source: string) {\r\n    if (!(rootNode instanceof Node))\r\n      throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\r\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\r\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\r\n\r\n    if (typeof source !== 'string')  throw new TypeError('\"sources\" isn\\'t a string');\r\n    // store the root node\r\n    Object.defineProperty(this, 'rootNode', { value: rootNode, enumerable: true });\r\n    Object.defineProperty(this, 'source', { value: source, enumerable: true }); // store the sources\r\n    // update the root node tree\r\n    Object.defineProperty(rootNode, 'tree', { value: this, enumerable: true });\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * Syntax tree node properties\r\n * @interface NodeProperties\r\n * @property {(?Node|undefined)} parentNode - The parent node or undefined if there is no parent\r\n * @property {(!Array.<Node>|undefined)} childNodes - The list of the child nodes\r\n * @exports\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface NodeProperties {\r\n  parentNode?: Node;\r\n  childNodes?: Node[];\r\n}\r\n\r\n\r\n/**\r\n * Syntax tree node structure\r\n * @class\r\n * @property {?SyntaxTree} tree - The tree or undefined if this node isn't in any tree\r\n * @property {?Node} parentNode - The parent node or undefined if there is no parent\r\n * @property {!Array.<Node>} childNodes - The child node list\r\n * @property {number} subtreeSize - The size of the subtree formed by this node\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Node {\r\n  tree: SyntaxTree;\r\n  public parentNode: Node;\r\n  private subtreeSize: number;\r\n  private childNodes_:Node[];\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!NodeProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(opt_initialProperties?: NodeProperties) {\r\n    if (opt_initialProperties !== undefined) { // if the initial properties are defined\r\n      if (!(opt_initialProperties instanceof Object))\r\n        throw new TypeError('initialProperties isn\\'t an Object instance');\r\n      if (opt_initialProperties.childNodes !== undefined) { // if the child node list is set\r\n        if (!(opt_initialProperties.childNodes instanceof Array))\r\n          throw new TypeError('initialProperties.childNodes isn\\'t an Array instance');\r\n        opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\r\n      }\r\n      let optParentNode = opt_initialProperties.parentNode;\r\n      if (optParentNode !== undefined) { // if the parent node is set\r\n        if (!!optParentNode) {\r\n          //noinspection JSUnresolvedFunction\r\n          optParentNode.insertChildSubtree(this);\r\n        } else {\r\n          throw new TypeError('initialProperties.parentNode isn\\'t a SyntaxTree.Node instance');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the child nodes\r\n   * @return {!Array.<Node>} the child node list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get childNodes(): Node[] {\r\n    return this.childNodes_.slice()\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the child node\r\n   * @param {(!Node|number)} node the child node or its child index\r\n   * @return {?Node} the child node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  childNode(node: Node | number): Node | undefined {\r\n    if (isNumber(node)) // if the node child index is given\r\n      return this.childNodes_[node] || undefined;\r\n    if (node instanceof Node) // if the child node is given\r\n      return node.parentNode === this ? node : undefined;\r\n    throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the child node index\r\n   * @param {(!Node|number)} node the child node or its child index\r\n   * @return {(number|undefined)} the child node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  childIndex(node: Node | number): number | undefined {\r\n    if (isNumber(node)) // if the node child index is given\r\n      return this.childNodes_[node] ? node : undefined;\r\n    if (node instanceof Node) // if the child node is given\r\n      return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\r\n    throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Insert a node to this child node list\r\n   * @param {!Node} node the node to insert (must have no parent and no child nodes)\r\n   * @param {number=undefined} childIndex\r\n   *        the position of the node for this child node list, the last by default\r\n   * @param {number=0} childNodesToCover\r\n   *        the number of this child nodes to become the child nodes of the new node\r\n   * @return {?Node} the inserted node or undefined if cannot insert\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  insertChildNode(node: Node, childIndex: number, childNodesToCover: number): Node {\r\n    if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\r\n    if (node.parentNode) throw new TypeError('\"node\" has a parent');\r\n    if (node.tree) throw new TypeError('\"node\" is a tree root');\r\n\r\n    // TODO\r\n    // if (!(this instanceof node.parentNodeClass_))\r\n    //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\r\n\r\n    if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\r\n    if (!this.hasOwnProperty('childNodes_')) // if there was no child nodes\r\n    // init the property\r\n      Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\r\n    // use the last position by default\r\n    if (childIndex === undefined) childIndex = this.childNodes_.length;\r\n    // do not cover any child nodes by default\r\n    if (childNodesToCover === undefined) childNodesToCover = 0;\r\n    // replace the child nodes by the new node\r\n    let nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\r\n    // update the size of the subtree formed by this node\r\n    Object.defineProperty(this, 'subtreeSize', {\r\n      value: this.subtreeSize + 1,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize + 1 });\r\n    }\r\n    // update the parent node of the new node\r\n    Object.defineProperty(node, 'parentNode', {\r\n      value: this,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    if (nodeChildNodes.length) { // if there are child nodes for the new node\r\n      // store the child nodes\r\n      Object.defineProperty(node, 'childNodes_', { value: nodeChildNodes, configurable: true });\r\n      let subtreeSize = 1; // initiate the size of the subtree formed by the new node\r\n      // for all the child nodes of the new node\r\n      nodeChildNodes.forEach(nodeChildNode => { subtreeSize += nodeChildNode.subtreeSize });\r\n      // store the subtree size\r\n      Object.defineProperty(node, 'subtreeSize', {\r\n        value: subtreeSize,\r\n        enumerable: true,\r\n        configurable: true\r\n      });\r\n    }\r\n    return node;\r\n  }\r\n\r\n\r\n  /**\r\n   * Insert a subtree to this child node list.\r\n   * @param {!Node} node the subtree to insert root node (must have no parent)\r\n   * @param {number=} childIndex\r\n   *        the position of the subtree root for this child node list, the last by default\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  insertChildSubtree(node: Node, childIndex?: number) {\r\n    if (!(node instanceof Node))\r\n      throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\r\n    if (node.parentNode) throw new TypeError('\"node\" has a parent');\r\n    if (node.tree) throw new TypeError('\"node\" is a tree root');\r\n\r\n    // todo check\r\n    // if (!(this instanceof node.parentNodeClass_))\r\n    //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\r\n    // init child nodes property if not exists\r\n    if (!this.hasOwnProperty('childNodes_')) // if there was no child nodes\r\n    // init the property\r\n      Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\r\n    // use the last position by default\r\n    if (childIndex === undefined) childIndex = this.childNodes_.length;\r\n    this.childNodes_.splice(childIndex, 0, node); // insert the new node to the child list\r\n    let nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\r\n    // update the size of the subtree formed by this node\r\n    Object.defineProperty(this, 'subtreeSize', {\r\n      value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\r\n    });\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', {\r\n        value: parentNode.subtreeSize + nodeSubtreeSize\r\n      });\r\n    }\r\n    // update the parent node of the new node\r\n    Object.defineProperty(node, 'parentNode', {\r\n      value: this,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n  }\r\n\r\n  \r\n\r\n  /**\r\n   * Remove a child node of this node. All its child nodes become the child nodes of this node\r\n   * @param {(!Node|number)} nodeOrNodeIndex the subtree root or its child index\r\n   * @return {?Node} the removed node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  removeChildNode(nodeOrNodeIndex: number | Node): Node | undefined {\r\n    let nodeChildIndex: number | undefined = this.childIndex(nodeOrNodeIndex); // the child index of the node\r\n    if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\r\n\r\n    const node: Node = this.childNodes_[nodeChildIndex]; // the child node to remove\r\n\r\n    // replace the node with its child nodes at this child node list\r\n    // todo could be more efficient?\r\n    this.childNodes_.splice(nodeChildIndex, 1, ...node.childNodes_);\r\n\r\n    if (this.childNodes_.length) { // if there are child nodes\r\n      // update this node subtree size\r\n      Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - 1 });\r\n    } else { // if there are no child nodes\r\n      delete this.childNodes_; // this node has no child nodes anymore\r\n      delete this.subtreeSize; // this node has node subtree anymore\r\n    }\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize - 1 });\r\n    }\r\n    delete node.parentNode; // the node has no parent node anymore\r\n\r\n    delete node.childNodes_; // the node has no child nodes anymore\r\n    delete node.subtreeSize; // the node has no subtree anymore\r\n    return node;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Remove a subtree formed by a child node of this node\r\n   * @param {(!Node|number)} node the subtree root or its child index\r\n   * @return {?Node} the removed subtree root node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  removeChildSubtree(node: Node | number): Node | undefined {\r\n    let nodeChildIndex: number | undefined = this.childIndex(node); // the child index of the node\r\n    if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\r\n\r\n    node = this.childNodes_.splice(nodeChildIndex, 1)[0]; // remove the node from the child list\r\n    let nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\r\n    if (this.childNodes_.length) { // if there are child nodes\r\n      // update this node subtree size\r\n      Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - nodeSubtreeSize });\r\n    } else { // if there are no child nodes\r\n      delete this.childNodes_; // this node has no child nodes anymore\r\n      delete this.subtreeSize; // this node has node subtree anymore\r\n    }\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', {\r\n        value: parentNode.subtreeSize - nodeSubtreeSize\r\n      });\r\n    }\r\n    delete node.parentNode; // the node has no parent node anymore\r\n    return node;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false): string {\r\n    let source = ''; // the sources\r\n    // for all the child nodes\r\n    this.childNodes_.forEach(childNode => { source += childNode.toString(true) });\r\n    return skipNodeClass ? source : 'SourceTree.Node{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(Node.prototype, { // make getters and setters enumerable\r\n  childNodes: { enumerable: true }\r\n});\r\nObject.defineProperties(Node.prototype, { // default property values\r\n  tree: { value: undefined, enumerable: true }, // no tree\r\n  parentNode: { value: undefined, enumerable: true }, // no parent node\r\n  subtreeSize: { value: 1, enumerable: true }, // only one node in the subtree\r\n  childNodes_: { value: [], enumerable: false }, // no child nodes\r\n  parentNodeClass_: { value: Node, enumerable: false } // parent node must be a Node instance\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree.ts","/**\r\n * @fileoverview LaTeX parser class\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/**@module */\r\n\r\n\r\nimport {LatexStyle, Symbol as SymbolItem, Command, Parameter, Environment, EnvironmentAndPackage} from \"./LatexStyle\";\r\nimport {\r\n  ParameterToken,\r\n  CommandToken,\r\n  SymbolToken,\r\n  Token,\r\n  SpaceToken,\r\n  EnvironmentToken,\r\n  EnvironmentBodyToken\r\n} from \"./LatexTree\";\r\nimport {Directive, GROUP, Lexeme, ModeStates, Operation, State} from \"./Latex\";\r\nimport {isNumber, isString, mustNotBeUndefined} from \"./Utils\";\r\n\r\n\r\n/**\r\n * Parse a comment line\r\n * @param {!Context} context the parsing context\r\n * @return {boolean} true if there was a comment line, false otherwise\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction parseCommentLine_(context: Context): boolean {\r\n  // try to find a comment int the sources tail\r\n  let commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\r\n  if (!commentMatch) return false; // return if there is no comment at this position\r\n\r\n  context.comments.push(commentMatch[1]); // store the comment string\r\n  context.position += commentMatch[0].length; // position just after the comment\r\n  if (!commentMatch[2]) { // if there were no line breaks\r\n    context.charNumber += commentMatch[0].length; // go to the last char\r\n  } else { // if there was a line break\r\n    ++context.lineNumber; // one more line\r\n    context.charNumber = commentMatch[2].length - 1; // skip all the space chars in the new line\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Fill the parsed token position, comments and parent\r\n * @param {!Context} context the parsing context\r\n * @param {!Token} token the token to process\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction processParsedToken_(context: Context, token: Token) {\r\n  // TODO process comments and position\r\n  if (context.currentToken) { // if there is a current token\r\n\r\n    // console.log(context.currentToken.toString())\r\n\r\n    //noinspection JSUnresolvedFunction\r\n    context.currentToken.insertChildSubtree(token); // store this token as a child of the current\r\n  }\r\n}\r\n\r\n/**\r\n * Parse space for a token (space or paragraph separator)\r\n * @param {!Context} context the parsing context\r\n * @return {?SpaceToken} the parsed token or undefined if cannot parse a space token\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction parseSpaceToken_(context: Context): SpaceToken | undefined {\r\n  let isSpace = false; // true is the sources fragment is a space token, false otherwise\r\n  let nLineBreaks = 0; // number of parsed line breaks\r\n  while (context.position < context.source.length) { // while there is something to parse\r\n    // go to the next iteration if there was a comment\r\n    if (parseCommentLine_(context)) continue;\r\n    switch (context.source[context.position]) { // depend on the sources current character\r\n      case ' ': case '\\t': // if a space or a tabular\r\n      isSpace = true; // and one more parsed char\r\n      ++context.position; // go to the next sources char\r\n      ++context.charNumber; // the next char of the sources line\r\n      continue;\r\n      case '\\n': // if a line break\r\n        isSpace = true; // and one more parsed char\r\n        ++nLineBreaks; // one more parsed line\r\n        ++context.position; // go to the next sources char\r\n        ++context.lineNumber; // the next sources line\r\n        context.charNumber = 0; // the first char of the line\r\n        continue; // go to the next iteration\r\n    }\r\n    break; // stop if not a space char\r\n  }\r\n  // create a space token if needed\r\n  return isSpace ? new SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\r\n}\r\n\r\n/**\r\n * LaTeX parser structure\r\n * @class\r\n * @property {!LatexStyle} latexStyle - The LaTeX style description to be used for parsing\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class LatexParser {\r\n  latexStyle: LatexStyle;\r\n\r\n\r\n  //noinspection JSUnusedGlobalSymbols\r\n  /**\r\n   * Constructor\r\n   * @param {!LatexStyle} latexStyle LaTeX style description to be used for parsing\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(latexStyle: LatexStyle) {\r\n    if (!(latexStyle instanceof LatexStyle))\r\n      throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\r\n    // store the style description\r\n    Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Parse LaTeX sources\r\n   * @param {string} source the sources to parse\r\n   * @param {(!Context|undefined)} opt_context the parsing context\r\n   * @return {!Array.<!Token>} the list of the parsed tokens\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parse(source: string, opt_context?: Context): Token[] {\r\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\r\n    let context;\r\n\r\n    if (opt_context === undefined) { // if the parsing context isn't defined\r\n      context = new Context(source); // create the context\r\n    } else if (opt_context instanceof Context) { // if the parsing context is defined\r\n      context = opt_context;\r\n      context.source += source; // update the sources\r\n    } else { // if unexpected context type\r\n      throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\r\n    }\r\n    let parsedTokens: Token[] = []; // the list of the parsed tokens\r\n    while (true) {\r\n      let parsedToken = this.parseToken_(context);\r\n      if (parsedToken === undefined) break; // stop when cannot parse a token\r\n      parsedTokens.push(parsedToken); // store the parsed token\r\n    }\r\n    return parsedTokens;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse the next token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?Token} the parsed token or undefined if the token cannot be parsed\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseToken_(context: Context): Token | undefined {\r\n    let token: Token | undefined = parseSpaceToken_(context); // collect comments and try to parse a space token\r\n    if (!token) { // if cannot parse a space token\r\n      if (context.position >= context.source.length) return undefined;\r\n\r\n      let contextBackup = context.copy(); // backup the current context\r\n      if (!(token = this.parseEnvironmentToken_(context))) { // if cannot parse an environment token\r\n        contextBackup.copy(context); // restore the context\r\n        if (!(token = this.parseCommandToken_(context))) { // if cannot parse a command token\r\n          contextBackup.copy(context); // restore the context\r\n          if (!(token = this.parseSymbolsToken_(context))) { // if cannot parse a symbol token\r\n            return undefined; // no token can be parsed\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, token);\r\n    //noinspection JSValidateTypes\r\n    return token; // return the parsed token\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse a parameter token\r\n   * @param {!Context} context the parsing context\r\n   * @param {!LatexStyle.Parameter} parameter the symbol or command parameter description\r\n   * @param {string=} opt_endLabel\r\n   *        the parameter end label or undefined if there should be a single token\r\n   * @return {?ParameterToken} the parsed parameter token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseParameterToken_(context: Context, parameter: Parameter, opt_endLabel?: string) {\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\r\n    context.updateState(parameter.operations); // update the LaTeX state\r\n    if (opt_endLabel === undefined) { // if the parameter must be parsed as a single token\r\n      // has the param space prefix or not\r\n      let spacePrefixState = parseSpaceToken_(context) !== undefined;\r\n      if (context.source[context.position] === '{') { // if the parameter is bounded by brackets\r\n        // create the parameter token\r\n        context.currentToken =\r\n          new ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState});\r\n        ++context.position; // go to the sources next char\r\n        ++context.charNumber; // go to the current line next char\r\n        // exit if cannot parse until the closing bracket\r\n\r\n        if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return undefined;\r\n        ++context.position; // skip the bracket in the sources\r\n        ++context.charNumber; // skip the bracket in the current line\r\n      } else { // if the parameter is't bounded by brackets\r\n        // create the parameter token\r\n        context.currentToken =\r\n          new ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState});\r\n        // exit if cannot parse a parameter token\r\n        if (this.parseToken_(context) === undefined) return undefined;\r\n      }\r\n    } else { // if the parameter must be parsed until the end label\r\n      // create the parameter token\r\n      context.currentToken =\r\n        new ParameterToken({ hasBrackets: false, hasSpacePrefix: false});\r\n\r\n      // return if cannot parse\r\n      if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return undefined;\r\n    }\r\n    let parameterToken = context.currentToken; // the parsed parameter token\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, parameterToken);\r\n    //noinspection JSValidateTypes\r\n    return parameterToken;\r\n  }\r\n\r\n\r\n\r\n\r\n  /**\r\n   * Parse an environment token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?EnvironmentToken} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseEnvironmentToken_(context: Context): EnvironmentToken | undefined {\r\n    if (context.source.substring(context.position).indexOf('\\\\begin') !== 0) return undefined;\r\n    context.position += 6; // just after \"\\begin\"\r\n    parseSpaceToken_(context); // skip spaces\r\n    // try to obtain the environment name\r\n    let nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\r\n    if (!nameMatch) return undefined; // exit if cannot bet the environment name\r\n    let name = nameMatch[1]; // the environment name\r\n    context.position += nameMatch[0].length; // skip the environment name in the sources\r\n    context.charNumber += nameMatch[0].length; // skip the environment name in the current line\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    // try to get the corresponding environment\r\n    let environment: Environment | EnvironmentAndPackage = this.latexStyle.environments(context.currentState, name)[0];\r\n    let environmentToken = context.currentToken = environment ? // the environment token\r\n      new EnvironmentToken({ environment: environment.environment }) :\r\n      new EnvironmentToken({ name: name });\r\n    // TODO unknown environment notification\r\n    // try to parse the environment begin command\r\n    let symbols: Command[] = this.latexStyle.commands(context.currentState, name);\r\n    let beginCommandToken: Token | undefined = this.parsePatterns_(context, symbols);\r\n    if (beginCommandToken === undefined) { // if cannot parse a command\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      beginCommandToken = new CommandToken({ name: name });\r\n    }\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, beginCommandToken);\r\n    let environmentBodyToken = context.currentToken = new EnvironmentBodyToken();\r\n    let endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}'); // try to get to the end\r\n    context.currentToken = environmentToken;\r\n    processParsedToken_(context, environmentBodyToken); // process the body token\r\n    let endCommandToken: Token | undefined = undefined; // the environment end command token\r\n    if (endFound) { // if the environment end was reached\r\n      context.position += name.length + 6; // skip the environment name in the sources\r\n      context.charNumber += name.length + 6; // skip the environment name in the current line\r\n      endCommandToken = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\r\n    } else { // if cannot find the end of the environment\r\n      // TODO no environment end notification\r\n    }\r\n    if (endCommandToken === undefined) { // if cannot parse a command\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      endCommandToken = new CommandToken({ name: 'end' + name });\r\n    }\r\n    processParsedToken_(context, endCommandToken); // process the end command token\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    return environmentToken;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse a command token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?CommandToken} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseCommandToken_(context: Context): Token | undefined {\r\n    // try to find a command name\r\n    const cmdMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\r\n\r\n    if (!cmdMatch)\r\n      return undefined; // exit if cannot find a command name\r\n\r\n    context.position += cmdMatch[0].length; // set position just after the command name\r\n    context.charNumber += cmdMatch[0].length; // skip all the command name chars\r\n    \r\n    // try to parse a command token\r\n    \r\n    let token: Token | undefined = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, cmdMatch[1]));\r\n    if (token === undefined) { // if cannot parse a command token\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      token = new CommandToken({ name: cmdMatch[1] });\r\n    }\r\n    //noinspection JSValidateTypes\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse symbols for a token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?Token} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseSymbolsToken_(context: Context) {\r\n    // get the available symbols\r\n    let sourceCharacter = context.source[context.position]; // the current sources character\r\n    // get the symbols started with the current sources character\r\n    //noinspection JSValidateTypes\r\n    let token =\r\n      this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\r\n    if (token === undefined) { // if cannot parse a symbol token\r\n      // TODO notification about the unrecognized symbol\r\n      ++context.position; // go to the next sources character\r\n      // go to the next line character (the line is the same, \\n was parsed for a space token)\r\n      ++context.charNumber;\r\n      // generate unrecognized symbol token\r\n      token = new SymbolToken({ pattern: sourceCharacter });\r\n    } else { // if the token was parsed\r\n      // TODO parse words and numbers\r\n    }\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Try to parse a symbol pattern\r\n   * @param {!Context} context the parsing context// generate unrecognized symbol token\r\n   * @param {!Array.<!LatexStyle.Symbol>} symbols the symbol or command descriptions in the priority descending order\r\n   * @return {?Token} the parsed symbol or command token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parsePatterns_(context: Context, symbols: SymbolItem[]): Token | undefined {\r\n    let contextBackup = context.copy(); // backup the current context\r\n    let token: Token | undefined = undefined; // the parsed token\r\n\r\n    // TODO not how some() is meant to be used...?\r\n    symbols.some(symbol => { // for all the symbols until the parsing success\r\n      // stop if the token was parsed\r\n      if (token = this.parsePattern_(context, symbol)) {\r\n        return true;\r\n      } else {\r\n        contextBackup.copy(context); // restore the context\r\n        return false; // go to the next symbol\r\n      }\r\n    });\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Try to parse a symbol pattern\r\n   * @param {!Context} context the parsing context\r\n   * @param {!Array.<!LatexStyle.Symbol>} symbol the symbol or command description\r\n   * @return {?Token} the parsed symbol or command token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parsePattern_(context: Context, symbol: SymbolItem): Token | undefined {\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    // if a command description is given\r\n    context.currentToken = symbol instanceof Command ?\r\n      new CommandToken({ command: symbol }) : // generate a command token\r\n      new SymbolToken({ symbol: symbol }); // generate a symbol token\r\n\r\n    let patternComponents = symbol.patternComponents; // the symbol pattern components\r\n    let nPatternComponents = patternComponents.length; // the pattern componen number\r\n    let iPatternComponent = 0; // the pattern component iterator\r\n    // for all the pattern components\r\n    for ( ; iPatternComponent < nPatternComponents; ++iPatternComponent) {\r\n      let patternComponent = patternComponents[iPatternComponent]; // the pattern component\r\n      if(isNumber(patternComponent)){ // if a parameter is expected\r\n        let parameter: Parameter | undefined = symbol.parameter(patternComponent); // the parameter description\r\n        // try to get the end label for the parameter\r\n        let parameterEndLabel = patternComponents[iPatternComponent + 1];\r\n        if (typeof parameterEndLabel === 'string') { // if there is a end label\r\n          // if can parse the parameter token\r\n          if (this.parseParameterToken_(context, mustNotBeUndefined(parameter), parameterEndLabel)) {\r\n            // exit if there is no the end label at the positions\r\n            if (context.source.substring(context.position).indexOf(parameterEndLabel) !== 0) return undefined;\r\n            context.position += parameterEndLabel.length; // skip the end label in the sources\r\n            context.charNumber += parameterEndLabel.length; // skip the end label in the line\r\n            ++iPatternComponent; // skip the end label in the pattern\r\n            continue; // go to the next pattern component\r\n          }\r\n        } else { // if there is no a end label\r\n          // go to the next pattern char if can parse the parameter token\r\n          if (this.parseParameterToken_(context, mustNotBeUndefined(parameter))) continue;\r\n        }\r\n      }\r\n      else if(isString(patternComponent)){\r\n          while (parseCommentLine_(context)) {\r\n          } // skip all the comments\r\n          // if the sources fragment is equal the pattern component\r\n          if (context.source.substring(context.position).indexOf(patternComponent) === 0) {\r\n            context.position += patternComponent.length; // skip the pattern component in the sources\r\n            context.charNumber += patternComponent.length; // skip the pattern component in the line\r\n            continue; // go to the next pattern component\r\n          }\r\n      } else if (parseSpaceToken_(context))\r\n        continue;\r\n      break; // stop parsing if there was no continue call\r\n    }\r\n    // return if the pattern parsing was broken\r\n    if (iPatternComponent < nPatternComponents) return undefined;\r\n    let parsedToken = context.currentToken; // the parsed token to return\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\r\n    context.updateState(symbol.operations); // update the LaTeX state\r\n    return parsedToken;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse tokens until the label\r\n   * @param {!Context} context the parsing context\r\n   * @param {string} endLabel the label to parse until\r\n   * @param {Latex.Lexeme=} opt_lexeme the lexeme of the single token to parse\r\n   * @return {boolean} true if the parsing was successful, false otherwise\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseUntilLabel_(context: Context, endLabel: string, opt_lexeme?: Lexeme) {\r\n    switch (opt_lexeme) {\r\n      // TODO parse special lexemes\r\n    default: {\r\n      // while not reached the label\r\n      while (context.source.substring(context.position).indexOf(endLabel) !== 0) {\r\n        if (context.position >= context.source.length) { // if there is no more sources\r\n          // TODO notification about unexpected sources end\r\n          return false;\r\n        }\r\n        this.parseToken_(context);\r\n      }\r\n      return true;\r\n    }}\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * The parsing context\r\n * @struct\r\n * @property {string} source - The source to parse\r\n * @property {number} position - The current position in the source\r\n * @property {?Token} currentToken - The currently parsing token\r\n * @property {!Latex.State} currentState - The current LaTeX state\r\n * @property {!Array.<!Latex.State>} stateStack - The stack of LaTeX sates\r\n * @property {!Array.<string>} comments - The comment list for the nex token\r\n * @property {number} lineNumber - The current line number\r\n * @property {number} charNumber - The current char number in the current line\r\n * @property {function} copy\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class Context {\r\n  source: string;\r\n  position: number;\r\n  currentToken?: Token;\r\n  currentState: State;\r\n  stateStack: State[];\r\n  comments: string[];\r\n  lineNumber: number;\r\n  charNumber: number;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {string=} opt_source the sources to parse (empty string by default)\r\n   */\r\n  constructor(opt_source: string = \"\") {\r\n    this.source = opt_source || ''; // store the sources\r\n    this.position = 0; // start from the beginning\r\n    this.lineNumber = 0; // start from the line 0\r\n    this.charNumber = 0; // start from the char 0\r\n    this.currentToken = undefined; // no tokens were parsed\r\n    this.currentState = new State(); // initial LaTeX state\r\n    this.stateStack = []; // no stored states\r\n    this.comments = []; // no comments for the next token\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Copy this context\r\n   * @param {!Context=} opt_target the context to copy to or undefined to create a new one\r\n   * @return {!Context} the context copy\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  copy(opt_target?: Context): Context {\r\n    let target = opt_target || new Context(); // the context to copy this context in\r\n    target.source = this.source;\r\n    target.position = this.position;\r\n    target.lineNumber = this.lineNumber;\r\n    target.charNumber = this.charNumber;\r\n    target.currentToken = this.currentToken;\r\n    target.currentState = this.currentState.copy();\r\n    target.stateStack = this.stateStack.slice();\r\n    target.comments = this.comments.slice();\r\n    return target;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Update the LaTeX state\r\n   * @param {!Array.<!Latex.Operation>} operations the LaTeX operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  updateState(operations: Operation[]) {\r\n    if (!(operations instanceof Array))\r\n      throw new TypeError('\"operations\" isn\\'t an Array instance');\r\n    let newModeStates: ModeStates = {}; // the modes to update\r\n    operations.forEach((operation: Operation) => {\r\n\r\n      switch (operation.directive) {\r\n      case Directive.BEGIN:\r\n\r\n        switch (operation.operand) {\r\n        case GROUP:\r\n          this.currentState.update(newModeStates); // store the mode states\r\n          newModeStates = {}; // no more states to update\r\n          this.stateStack.push(this.currentState.copy()); // store the current state\r\n          break;\r\n        default:\r\n\r\n          newModeStates[operation.operand] = true; // turn the state on\r\n        }\r\n        break;\r\n      case Directive.END:\r\n\r\n        switch (operation.operand) {\r\n        case GROUP:\r\n          newModeStates = {}; // no need to store the states\r\n          if (this.stateStack.length < 1) throw new Error('state stack is empty');\r\n          this.currentState = mustNotBeUndefined(this.stateStack.pop()); // restore the current state\r\n          break;\r\n        default:\r\n\r\n          newModeStates[operation.operand] = false; // turn the state off\r\n        }\r\n        break;\r\n      }\r\n    });\r\n    this.currentState.update(newModeStates); // store the mode states\r\n  }\r\n};\r\n\r\n//noinspection JSUnusedGlobalSymbols // TODO\r\n// export default LatexParser;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexParser.ts","/**\r\n * @fileoverview Export file for LaTeX parser utilities.\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport * from \"./lib/Utils\" // general JavaScript utils\r\nexport * from \"./lib/Latex\" // general LaTeX definitions\r\nexport * from \"./lib/LatexStyle\" // LaTeX style structures\r\nexport * from \"./lib/SyntaxTree\" // syntax tree structure elements\r\nexport * from \"./lib/LatexTree\" // LaTeX syntax tree structure elements\r\nexport * from \"./lib/LatexParser\"// LaTeX parser class\n\n\n// WEBPACK FOOTER //\n// ./sources/main.ts"],"sourceRoot":""}