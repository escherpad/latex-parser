{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///latex-parser.min.js","webpack:///webpack/bootstrap 3e0e951d148a4946b645","webpack:///./sources/lib/Utils.ts","webpack:///./sources/lib/SyntaxTree/Token/index.ts","webpack:///./sources/lib/SyntaxTree/Token/SymbolToken.ts","webpack:///./sources/lib/Latex/Mode.ts","webpack:///./sources/lib/LatexStyle/Item/Environment.ts","webpack:///./sources/lib/LatexStyle/Item/Symbol/Command.ts","webpack:///./sources/lib/LatexStyle/Item/Symbol/index.ts","webpack:///./sources/lib/LatexStyle/Item/index.ts","webpack:///./sources/lib/SyntaxTree/Token/CommandToken.ts","webpack:///./sources/lib/Latex/Directive/GROUP.ts","webpack:///./sources/lib/Latex/Lexeme.ts","webpack:///./sources/lib/Latex/Operation.ts","webpack:///./sources/lib/Latex/State.ts","webpack:///./sources/lib/SyntaxTree/Node.ts","webpack:///./sources/lib/SyntaxTree/Token/EnvironmentBodyToken.ts","webpack:///./sources/lib/SyntaxTree/Token/EnvironmentToken.ts","webpack:///./sources/lib/Latex/Directive/index.ts","webpack:///./sources/lib/Latex/Parser/Context.ts","webpack:///./sources/lib/LatexStyle/Item/Parameter.ts","webpack:///./sources/lib/LatexStyle/index.ts","webpack:///./sources/lib/SyntaxTree/Token/ParameterToken.ts","webpack:///./sources/lib/SyntaxTree/Token/SpaceToken.ts","webpack:///./sources/lib/SyntaxTree/index.ts","webpack:///./sources/lib/Latex/Parser/Parser.ts","webpack:///./sources/lib/LatexStyle/PackageProperties.ts","webpack:///./sources/lib/SyntaxTree/LatexTree.ts","webpack:///./sources/lib/SyntaxTree/Token/SourceToken.ts","webpack:///./sources/main.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","updateProperties","target","values","opt_keys","opt_attributes","arguments","length","undefined","writable","TypeError","key","create","Array","forEach","targetKey","_key","testProperties","opt_skipUndefined","every","_key2","isNumber","x","isString","mustNotBeUndefined","msg","Error","mustBeObject","mustBeString","mustBeArray","a","isArray","constructor","_classCallCheck","instance","Constructor","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","isToken","Token","mustBeToken","_createClass","defineProperties","props","descriptor","protoProps","staticProps","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_Node2","_Node","opt_initialProperties","_this","superInitialProperties","parentNode","parentToken","childNodes","childTokens","Node","SymbolToken","_index","_index2","_Utils","_Token","initialProperties","symbol","Symbol","pattern","skipNodeClass","source","iParameter","nPatternChars","iPatternChar","patternChar","parameterToken","childNode","toString","lexeme","isKirillMode","modes","mustBeKirillMode","isLatexMode","mustBeLatexMode","LIST","MATH","PICTURE","TABLE","TEXT","VERTICAL","isEnvironment","Environment","_Item","other","Item","isCommand","Command","mustBeCommand","_Symbol2","_typeof","iterator","obj","_Parameter","_Operation","_Symbol","operations","map","operation","Operation","mustBeOperationProperties","parameters","parameters_","parameter","Parameter","mustBeParameterProperties","patternComponents","match","patternComponents_","patternPart","parameterIndex","Number","substring","html","operations_","iOperation","equals","slice","patternComponent","join","_Lexeme","_Mode","Lexeme","modeKey","mode","isCommandToken","CommandToken","_Command","_SymbolToken2","_SymbolToken","command","isGROUP","GROUP","isLexeme","mustBeLexeme","CELL_SEPARATOR","BRACKETS","BINARY_OPERATOR","CHAR","DIGIT","DIRECTIVE","DISPLAY_EQUATION","FILE_PATH","FLOATING_BOX","HORIZONTAL_SKIP","INLINE_EQUATION","LABEL","LENGTH","LETTER","LINE_BREAK","NUMBER","LIST_ITEM","PARAGRAPH_SEPARATOR","POST_OPERATOR","PRE_OPERATOR","RAW","SPACE","SUBSCRIPT","SUPERSCRIPT","TABULAR_PARAMETERS","TAG","UNKNOWN","VERTICAL_SKIP","WORD","WRAPPER","isOperationProperties","isDirective","directive","operand","_GROUP","Directive","State","opt_initialModeStates","modeStates_","update","modeStates","_toConsumableArray","arr","arr2","from","childNodes_","insertChildSubtree","optParentNode","node","indexOf","childIndex","childNodesToCover","tree","nodeChildNodes","splice","subtreeSize","nodeChildNode","nodeSubtreeSize","nodeOrNodeIndex","_childNodes_","nodeChildIndex","apply","concat","theNode","getBeginCommandToken","_CommandToken","beginCommandToken","getEndCommandToken","endCommandToken","getEnvironment","environment","_Environment","EnvironmentBodyToken","_EnvironmentToken","mustBeEnvironmentToken","parentNodeClass_","EnvironmentToken","isEnvironmentToken","_EnvironmentBodyToken","bodyToken","beginToken","endToken","BEGIN","END","Context","_State","opt_source","position","lineNumber","charNumber","currentToken","currentState","stateStack","comments","opt_target","copy","newModeStates","push","pop","isParameterProperties","ignored","LatexStyle","symbols_","commands_","environments_","packageName","stylePackage","symbols","iSymbol","symbolPatternFirstChar","commands","iCommand","environments","iEnvironment","envName","storedEnv","filteredSymbols","filter","styleItem","commandName","filteredCommands","environmentName","filteredEnvironments","state","patternFirstChar","SyntaxError","test","env","ParameterToken","hasBrackets","hasSpacePrefix","symbolToken","SpaceToken","lineBreakCount","isFinite","SyntaxTree","rootNode","parseToken_","context","latexStyle","token","parseSpaceToken_","contextBackup","parseEnvironmentToken_","parseCommandToken_","parseSymbolsToken_","processParsedToken_","parseParameterToken_","opt_endLabel","currentTokenBackup","updateState","spacePrefixState","_ParameterToken","parseUntilLabel_","nameMatch","environmentToken","parsePatterns_","environmentBodyToken","endFound","cmdMatch","sourceCharacter","some","parsePattern_","nPatternComponents","iPatternComponent","parameterEndLabel","parseCommentLine_","parsedToken","endLabel","opt_lexeme","commentMatch","isSpace","nLineBreaks","_SpaceToken","LatexParser","_Context","opt_context","parsedTokens","mustBePackageProperties","isPackageProperties","keys","k","LatexTree","_SyntaxTree","rootToken","SourceToken","_Parser","_PackageProperties","_index3","_index4","_index5","_LatexTree","_index6","_SourceToken"],"mappings":"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","file":"latex-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 27);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.updateProperties = updateProperties;\nexports.testProperties = testProperties;\nexports.isNumber = isNumber;\nexports.isString = isString;\nexports.mustNotBeUndefined = mustNotBeUndefined;\nexports.mustBeObject = mustBeObject;\nexports.mustBeString = mustBeString;\nexports.mustBeArray = mustBeArray;\nexports.isArray = isArray;\nfunction updateProperties(target, values, opt_keys) {\n    var opt_attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        writable: true,\n        enumerable: true,\n        configurable: true\n    };\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = { writable: true, enumerable: true, configurable: true };\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        }\n    } else if (opt_keys instanceof Array) {\n        opt_keys.forEach(function (key) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key = opt_keys[targetKey];\n            if (values[_key] !== undefined) Object.defineProperty(target, targetKey, Object.create(opt_attributes, { value: { value: values[_key] } }));\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\nfunction testProperties(target, values, opt_keys) {\n    var opt_skipUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true;\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined)) return false;\n        }\n    } else if (opt_keys instanceof Array) {\n        return opt_keys.every(function (key) {\n            return target[key] === values[key] || values[key] === undefined && opt_skipUndefined;\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key2 = opt_keys[targetKey];\n            if (target[targetKey] !== values[_key2] && !(values[_key2] === undefined && opt_skipUndefined)) return false;\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true;\n}\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction mustNotBeUndefined(x, msg) {\n    if (!x) throw new Error(msg);\n    return x;\n}\nfunction mustBeObject(o, msg) {\n    if (!(o instanceof Object)) throw new TypeError(msg ? msg : \"Expected Object\");\n    return o;\n}\nfunction mustBeString(o, msg) {\n    if (typeof o !== \"string\") throw new TypeError(msg ? msg : \"Expected string\");\n    return o;\n}\nfunction mustBeArray(a, msg) {\n    if (!isArray(a)) throw new TypeError(msg ? msg : \"Expected Array\");\n    return a;\n}\nfunction isArray(x) {\n    return x.constructor === Array;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Token = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isToken = isToken;\nexports.mustBeToken = mustBeToken;\n\nvar _Node2 = __webpack_require__(13);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction isToken(x) {\n    return x instanceof Token;\n}\nfunction mustBeToken(x, msg) {\n    if (!isToken(x)) throw new Error(msg);\n    return x;\n}\n\nvar Token = exports.Token = function (_Node) {\n    _inherits(Token, _Node);\n\n    function Token() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Token);\n\n        if (opt_initialProperties === undefined) {\n            var _this = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this));\n        } else if (opt_initialProperties instanceof Object) {\n            var superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n\n            var _this = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this, superInitialProperties));\n        } else {\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n        return _possibleConstructorReturn(_this);\n    }\n\n    _createClass(Token, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), \"toString\", this).call(this, true) : \"Token{\" + _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), \"toString\", this).call(this, true) + \"}\";\n        }\n    }]);\n\n    return Token;\n}(_Node2.Node);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SymbolToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _index = __webpack_require__(1);\n\nvar _index2 = __webpack_require__(6);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SymbolToken = exports.SymbolToken = function (_Token) {\n    _inherits(SymbolToken, _Token);\n\n    function SymbolToken(initialProperties) {\n        _classCallCheck(this, SymbolToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this = _possibleConstructorReturn(this, (SymbolToken.__proto__ || Object.getPrototypeOf(SymbolToken)).call(this, initialProperties));\n\n        if (initialProperties.symbol) {\n            if (!(initialProperties.symbol instanceof _index2.Symbol)) throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            Object.defineProperty(_this, \"symbol\", { value: initialProperties.symbol, enumerable: true });\n        } else {\n            if (typeof initialProperties.pattern !== \"string\") throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            Object.defineProperty(_this, \"pattern\", { value: initialProperties.pattern });\n        }\n        return _this;\n    }\n\n    _createClass(SymbolToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = \"\";\n            var iParameter = 0;\n            var pattern = this.pattern;\n            for (var nPatternChars = pattern.length, iPatternChar = 0; iPatternChar < nPatternChars; ++iPatternChar) {\n                var patternChar = pattern[iPatternChar];\n                if (patternChar === \"#\") {\n                    ++iPatternChar;\n                    var parameterToken = this.childNode(iParameter++);\n                    source += parameterToken ? parameterToken.toString(true) : \"??\";\n                } else {\n                    source += patternChar;\n                }\n            }\n            return skipNodeClass ? source : \"SymbolToken\" + (this.symbol ? \"\" : \"[?]\") + \"{\" + source + \"}\";\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.symbol ? this.symbol.lexeme : undefined;\n        }\n    }, {\n        key: \"pattern\",\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.symbol).pattern;\n        }\n    }]);\n\n    return SymbolToken;\n}(_index.Token);\n\nObject.defineProperties(SymbolToken.prototype, {\n    symbol: { value: undefined, enumerable: true }\n});\nObject.defineProperties(SymbolToken.prototype, {\n    pattern: { enumerable: true }\n});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.modes = undefined;\nexports.isKirillMode = isKirillMode;\nexports.mustBeKirillMode = mustBeKirillMode;\nexports.isLatexMode = isLatexMode;\nexports.mustBeLatexMode = mustBeLatexMode;\n\nvar _Utils = __webpack_require__(0);\n\nvar modes = exports.modes = {\n    LIST: \"LIST\",\n    MATH: \"MATH\",\n    PICTURE: \"PICTURE\",\n    TABLE: \"TABLE\",\n    TEXT: \"TEXT\",\n    VERTICAL: \"VERTICAL\"\n};\nfunction isKirillMode(x) {\n    return modes.hasOwnProperty(x);\n}\nfunction mustBeKirillMode(x, msg) {\n    if (!isKirillMode(x)) throw new Error(msg);\n    return x;\n}\nfunction isLatexMode(x) {\n    if (!(0, _Utils.isString)(x)) return false;\n    switch (x) {\n        case \"Paragraph\":\n        case \"Math\":\n        case \"LR\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction mustBeLatexMode(x, msg) {\n    if (!isLatexMode(x)) throw new Error(msg);\n    return x;\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Environment = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isEnvironment = isEnvironment;\n\nvar _index = __webpack_require__(7);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Environment = exports.Environment = function (_Item) {\n    _inherits(Environment, _Item);\n\n    function Environment() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Environment);\n\n        var _this = _possibleConstructorReturn(this, (Environment.__proto__ || Object.getPrototypeOf(Environment)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== \"string\") throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this, \"name\", { value: opt_initialProperties.name });\n        }\n        return _this;\n    }\n\n    _createClass(Environment, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Environment)) return false;\n            if (!_get(Environment.prototype.__proto__ || Object.getPrototypeOf(Environment.prototype), \"equals\", this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Environment;\n}(_index.Item);\n\nObject.defineProperties(Environment.prototype, {\n    name: { value: \"\", enumerable: true }\n});\nfunction isEnvironment(x) {\n    return x instanceof Environment;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Command = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isCommand = isCommand;\nexports.mustBeCommand = mustBeCommand;\n\nvar _index = __webpack_require__(6);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Command = exports.Command = function (_Symbol2) {\n    _inherits(Command, _Symbol2);\n\n    function Command() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Command);\n\n        var _this = _possibleConstructorReturn(this, (Command.__proto__ || Object.getPrototypeOf(Command)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== \"string\") throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this, \"name\", { value: opt_initialProperties.name });\n        }\n        return _this;\n    }\n\n    _createClass(Command, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Command)) return false;\n            if (!_get(Command.prototype.__proto__ || Object.getPrototypeOf(Command.prototype), \"equals\", this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Command;\n}(_index.Symbol);\n\nObject.defineProperties(Command.prototype, {\n    name: { value: \"\", enumerable: true }\n});\nfunction isCommand(c) {\n    return c instanceof Command;\n}\nfunction mustBeCommand(c) {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Symbol = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _Parameter = __webpack_require__(18);\n\nvar _index = __webpack_require__(7);\n\nvar _Operation = __webpack_require__(11);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _Symbol = function (_Item) {\n    _inherits(_Symbol, _Item);\n\n    function _Symbol() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, _Symbol);\n\n        var _this = _possibleConstructorReturn(this, (_Symbol.__proto__ || Object.getPrototypeOf(_Symbol)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this, \"operations_\", {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Operation.Operation((0, _Operation.mustBeOperationProperties)(operation));\n                })\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) {\n            if (!(opt_initialProperties.parameters instanceof Array)) throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            _this.parameters_ = opt_initialProperties.parameters.map(function (parameter) {\n                return new _Parameter.Parameter((0, _Parameter.mustBeParameterProperties)(parameter));\n            });\n        }\n        if (opt_initialProperties.pattern !== undefined) {\n            if (typeof opt_initialProperties.pattern !== \"string\") throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            var patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) {\n                _this.patternComponents_ = patternComponents.map(function (patternPart) {\n                    switch (patternPart[0]) {\n                        case \" \":\n                        case \"\\t\":\n                            return undefined;\n                        case \"#\":\n                            var parameterIndex = Number(patternPart.substring(1)) - 1;\n                            if (!_this.parameters_[parameterIndex]) throw new TypeError('\"initialProperties.pattern\" contains the incorrect parameter number ' + patternPart.substring(1));\n                            return parameterIndex;\n                        default:\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) {\n            if (typeof opt_initialProperties.html !== \"string\") throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            Object.defineProperty(_this, \"html\", { value: opt_initialProperties.html, enumerable: true });\n        }\n        return _this;\n    }\n\n    _createClass(_Symbol, [{\n        key: \"parameter\",\n        value: function parameter(parameterIndex) {\n            return this.parameters_[parameterIndex] || undefined;\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof _Symbol)) return false;\n            if (!_get(_Symbol.prototype.__proto__ || Object.getPrototypeOf(_Symbol.prototype), \"equals\", this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            if (!this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            })) return false;\n            if (this.parameters_.length !== other.parameters_.length) return false;\n            if (!this.parameters_.every(function (parameter, iParameter) {\n                return parameter.equals(other.parameters_[iParameter]);\n            })) return false;\n            return this.html === other.html;\n        }\n    }, {\n        key: \"operations\",\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }, {\n        key: \"parameters\",\n        get: function get() {\n            return this.parameters_.slice();\n        }\n    }, {\n        key: \"patternComponents\",\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.patternComponents_.slice());\n        }\n    }, {\n        key: \"pattern\",\n        get: function get() {\n            return this.patternComponents_.map(function (patternComponent) {\n                if ((0, _Utils.isNumber)(patternComponent)) {\n                    return \"#\" + (patternComponent + 1);\n                }\n                switch (typeof patternComponent === \"undefined\" ? \"undefined\" : _typeof(patternComponent)) {\n                    case \"string\":\n                        return patternComponent;\n                    default:\n                        return \" \";\n                }\n            }).join(\"\");\n        }\n    }]);\n\n    return _Symbol;\n}(_index.Item);\n\nexports.Symbol = _Symbol;\n\nObject.defineProperties(_Symbol.prototype, {\n    operations: { enumerable: true },\n    parameters: { enumerable: true },\n    patternComponents: { enumerable: true },\n    pattern: { enumerable: true }\n});\nObject.defineProperties(_Symbol.prototype, {\n    operations_: { value: [], enumerable: false, writable: true },\n    parameters_: { value: [], enumerable: false, writable: true },\n    patternComponents_: { value: [], enumerable: false, writable: true },\n    html: { value: \"\", enumerable: true, writable: true }\n});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Item = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Lexeme = __webpack_require__(10);\n\nvar _Mode = __webpack_require__(3);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Item = exports.Item = function () {\n    function Item() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Item);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break;\n            default:\n                var lexeme = _Lexeme.Lexeme[opt_initialProperties.lexeme];\n                if (lexeme === undefined) throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, \"lexeme\", { value: lexeme });\n        }\n        if (opt_initialProperties.modes !== undefined) {\n            if (!(opt_initialProperties.modes instanceof Object)) throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, \"modes\", { value: {} });\n            for (var modeKey in opt_initialProperties.modes) {\n                var mode = (0, _Mode.mustBeKirillMode)(modeKey);\n                if (mode === undefined) throw new TypeError(\"\\\"initialProperties.modes[\" + modeKey + \"]\\\" isn't a Mode option\");\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n    _createClass(Item, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Item)) return false;\n            return this.lexeme === other.lexeme && (0, _Utils.testProperties)(this.modes, other.modes, _Mode.modes, false);\n        }\n    }]);\n\n    return Item;\n}();\n\nObject.defineProperties(Item.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    modes: { value: {}, enumerable: true }\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CommandToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isCommandToken = isCommandToken;\n\nvar _Command = __webpack_require__(5);\n\nvar _SymbolToken2 = __webpack_require__(2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CommandToken = exports.CommandToken = function (_SymbolToken) {\n    _inherits(CommandToken, _SymbolToken);\n\n    function CommandToken(initialProperties) {\n        _classCallCheck(this, CommandToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var superInitialProperties = Object.create(initialProperties);\n        if (initialProperties.command) {\n            if (!(initialProperties.command instanceof _Command.Command)) throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            superInitialProperties.symbol = initialProperties.command;\n\n            var _this = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n\n            _this.command = (0, _Command.mustBeCommand)(initialProperties.command);\n            _this.name = _this.command.name;\n        } else {\n            if (typeof initialProperties.name !== \"string\") throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = \"\";\n\n            var _this = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n\n            _this.name = initialProperties.name;\n        }\n        return _possibleConstructorReturn(_this);\n    }\n\n    _createClass(CommandToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = \"\\\\\" + this.name + _get(CommandToken.prototype.__proto__ || Object.getPrototypeOf(CommandToken.prototype), \"toString\", this).call(this, true);\n            return skipNodeClass ? source : \"CommandToken\" + ((0, _Command.isCommand)(this.symbol) ? \"\" : \"[?]\") + (\"{\" + source + \"}\");\n        }\n    }]);\n\n    return CommandToken;\n}(_SymbolToken2.SymbolToken);\n\nfunction isCommandToken(x) {\n    return x && x instanceof CommandToken;\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isGROUP = isGROUP;\nvar GROUP = exports.GROUP = \"GROUP\";\nfunction isGROUP(x) {\n    return x === GROUP;\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isLexeme = isLexeme;\nexports.mustBeLexeme = mustBeLexeme;\nvar Lexeme = exports.Lexeme = {\n    CELL_SEPARATOR: \"CELL_SEPARATOR\",\n    BRACKETS: \"BRACKETS\",\n    BINARY_OPERATOR: \"BINARY_OPERATOR\",\n    CHAR: \"CHAR\",\n    DIGIT: \"DIGIT\",\n    DIRECTIVE: \"DIRECTIVE\",\n    DISPLAY_EQUATION: \"DISPLAY_EQUATION\",\n    FILE_PATH: \"FILE_PATH\",\n    FLOATING_BOX: \"FLOATING_BOX\",\n    HORIZONTAL_SKIP: \"HORIZONTAL_SKIP\",\n    INLINE_EQUATION: \"INLINE_EQUATION\",\n    LABEL: \"LABEL\",\n    LENGTH: \"LENGTH\",\n    LETTER: \"LETTER\",\n    LINE_BREAK: \"LINE_BREAK\",\n    NUMBER: \"NUMBER\",\n    LIST: \"LIST\",\n    LIST_ITEM: \"LIST_ITEM\",\n    PARAGRAPH_SEPARATOR: \"PARAGRAPH_SEPARATOR\",\n    PICTURE: \"PICTURE\",\n    POST_OPERATOR: \"POST_OPERATOR\",\n    PRE_OPERATOR: \"PRE_OPERATOR\",\n    RAW: \"RAW\",\n    SPACE: \"SPACE\",\n    SUBSCRIPT: \"SUBSCRIPT\",\n    SUPERSCRIPT: \"SUPERSCRIPT\",\n    TABLE: \"TABLE\",\n    TABULAR_PARAMETERS: \"TABULAR_PARAMETERS\",\n    TAG: \"TAG\",\n    UNKNOWN: \"UNKNOWN\",\n    VERTICAL_SKIP: \"VERTICAL_SKIP\",\n    WORD: \"WORD\",\n    WRAPPER: \"WRAPPER\"\n};\nfunction isLexeme(x) {\n    return Lexeme.hasOwnProperty(x);\n}\nfunction mustBeLexeme(x, msg) {\n    if (!isLexeme(x)) throw new Error(msg);\n    return x;\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Operation = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isOperationProperties = isOperationProperties;\nexports.mustBeOperationProperties = mustBeOperationProperties;\n\nvar _index = __webpack_require__(16);\n\nvar _GROUP = __webpack_require__(9);\n\nvar _Mode = __webpack_require__(3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction isOperationProperties(x) {\n    return x && x.hasOwnProperty(\"directive\") && (0, _index.isDirective)(x.directive) && x.hasOwnProperty(\"operand\") && ((0, _Mode.isKirillMode)(x.operand) || (0, _GROUP.isGROUP)(x.operand));\n}\nfunction mustBeOperationProperties(x) {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\n\nvar Operation = exports.Operation = function () {\n    function Operation(opt_initialProperties) {\n        _classCallCheck(this, Operation);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var directive = _index.Directive[opt_initialProperties.directive];\n        if (!directive) throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, \"directive\", { value: directive, enumerable: true });\n        switch (opt_initialProperties.operand) {\n            case _GROUP.GROUP:\n                Object.defineProperty(this, \"operand\", { value: _GROUP.GROUP, enumerable: true });\n                break;\n            default:\n                var mode = _Mode.modes[opt_initialProperties.operand];\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.KirillMode option');\n                Object.defineProperty(this, \"operand\", { value: mode, enumerable: true });\n        }\n    }\n\n    _createClass(Operation, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Operation)) return false;\n            return this.directive === other.directive && this.operand === other.operand;\n        }\n    }]);\n\n    return Operation;\n}();\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.State = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Mode = __webpack_require__(3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar State = exports.State = function () {\n    function State() {\n        var opt_initialModeStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, State);\n\n        Object.defineProperty(this, \"modeStates_\", { value: {}, enumerable: false });\n        this.modeStates_[_Mode.modes.LIST] = false;\n        this.modeStates_[_Mode.modes.MATH] = false;\n        this.modeStates_[_Mode.modes.PICTURE] = false;\n        this.modeStates_[_Mode.modes.TABLE] = false;\n        this.modeStates_[_Mode.modes.TEXT] = true;\n        this.modeStates_[_Mode.modes.VERTICAL] = false;\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n    _createClass(State, [{\n        key: \"copy\",\n        value: function copy() {\n            return new State(this.modeStates_);\n        }\n    }, {\n        key: \"update\",\n        value: function update(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = _Mode.modes[(0, _Mode.mustBeKirillMode)(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.KirillMode option');\n                this.modeStates_[mode] = modeStates[modeKey];\n            }\n        }\n    }, {\n        key: \"test\",\n        value: function test(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = _Mode.modes[(0, _Mode.mustBeKirillMode)(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.KirillMode option');\n                if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n            }\n            return true;\n        }\n    }]);\n\n    return State;\n}();\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Node = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = exports.Node = function () {\n    function Node(opt_initialProperties) {\n        _classCallCheck(this, Node);\n\n        this.childNodes_ = [];\n        if (opt_initialProperties !== undefined) {\n            (0, _Utils.mustBeObject)(opt_initialProperties, \"initialProperties isn't an Object instance\");\n            if (opt_initialProperties.childNodes !== undefined) {\n                (0, _Utils.mustBeArray)(opt_initialProperties.childNodes, \"initialProperties.childNodes isn't an Array instance\");\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n            }\n            var optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) {\n                if (!!optParentNode) {\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError(\"initialProperties.parentNode isn't a SyntaxTree.Node instance\");\n                }\n            }\n        }\n    }\n\n    _createClass(Node, [{\n        key: \"childNode\",\n        value: function childNode(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] || undefined;\n            if (node instanceof Node) return node.parentNode === this ? node : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: \"childIndex\",\n        value: function childIndex(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] ? node : undefined;\n            if (node instanceof Node) return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: \"insertChildNode\",\n        value: function insertChildNode(node, childIndex, childNodesToCover) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n            if (!this.hasOwnProperty(\"childNodes_\")) this.childNodes_ = [];\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            if (childNodesToCover === undefined) childNodesToCover = 0;\n            var nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n            this.subtreeSize = this.subtreeSize + 1;\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                parentNode.subtreeSize = parentNode.subtreeSize + 1;\n            }\n            Object.defineProperty(node, \"parentNode\", {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n            if (nodeChildNodes.length) {\n                Object.defineProperty(node, \"childNodes_\", { value: nodeChildNodes, configurable: true });\n                var subtreeSize = 1;\n                nodeChildNodes.forEach(function (nodeChildNode) {\n                    subtreeSize += nodeChildNode.subtreeSize;\n                });\n                Object.defineProperty(node, \"subtreeSize\", {\n                    value: subtreeSize,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n            return node;\n        }\n    }, {\n        key: \"insertChildSubtree\",\n        value: function insertChildSubtree(node, childIndex) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (!this.hasOwnProperty(\"childNodes_\")) Object.defineProperty(this, \"childNodes_\", { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            this.childNodes_.splice(childIndex, 0, node);\n            var nodeSubtreeSize = node.subtreeSize;\n            Object.defineProperty(this, \"subtreeSize\", {\n                value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, \"subtreeSize\", {\n                    value: parentNode.subtreeSize + nodeSubtreeSize\n                });\n            }\n            Object.defineProperty(node, \"parentNode\", {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }, {\n        key: \"removeChildNode\",\n        value: function removeChildNode(nodeOrNodeIndex) {\n            var _childNodes_;\n\n            var nodeChildIndex = this.childIndex(nodeOrNodeIndex);\n            if (nodeChildIndex === undefined) return undefined;\n            var node = this.childNodes_[nodeChildIndex];\n            (_childNodes_ = this.childNodes_).splice.apply(_childNodes_, [nodeChildIndex, 1].concat(_toConsumableArray(node.childNodes_)));\n            if (this.childNodes_.length) {\n                this.subtreeSize = this.subtreeSize - 1;\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                parentNode.subtreeSize = parentNode.subtreeSize - 1;\n            }\n            delete node.parentNode;\n            delete node.childNodes_;\n            delete node.subtreeSize;\n            return node;\n        }\n    }, {\n        key: \"removeChildSubtree\",\n        value: function removeChildSubtree(node) {\n            var nodeChildIndex = this.childIndex(node);\n            if (nodeChildIndex === undefined) return undefined;\n            var theNode = (0, _Utils.mustNotBeUndefined)(this.childNodes_.splice(nodeChildIndex, 1)[0]);\n            var nodeSubtreeSize = theNode.subtreeSize;\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, \"subtreeSize\", { value: this.subtreeSize - nodeSubtreeSize });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, \"subtreeSize\", {\n                    value: parentNode.subtreeSize - nodeSubtreeSize\n                });\n            }\n            delete theNode.parentNode;\n            return theNode;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = \"\";\n            this.childNodes_.forEach(function (childNode) {\n                source += childNode.toString(true);\n            });\n            return skipNodeClass ? source : \"SourceTree.Node{\" + source + \"}\";\n        }\n    }, {\n        key: \"childNodes\",\n        get: function get() {\n            return this.childNodes_.slice();\n        }\n    }]);\n\n    return Node;\n}();\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.EnvironmentBodyToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _index = __webpack_require__(1);\n\nvar _CommandToken = __webpack_require__(8);\n\nvar _Environment = __webpack_require__(4);\n\nvar _EnvironmentToken = __webpack_require__(15);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction getBeginCommandToken(x) {\n    if ((0, _CommandToken.isCommandToken)(x.beginCommandToken)) return x.beginCommandToken;\n}\nfunction getEndCommandToken(x) {\n    if ((0, _CommandToken.isCommandToken)(x.endCommandToken)) return x.endCommandToken;\n}\nfunction getEnvironment(x) {\n    if (x.environment && (0, _Environment.isEnvironment)(x.environment)) return x.environment;\n}\n\nvar EnvironmentBodyToken = exports.EnvironmentBodyToken = function (_Token) {\n    _inherits(EnvironmentBodyToken, _Token);\n\n    function EnvironmentBodyToken() {\n        _classCallCheck(this, EnvironmentBodyToken);\n\n        return _possibleConstructorReturn(this, (EnvironmentBodyToken.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken)).apply(this, arguments));\n    }\n\n    _createClass(EnvironmentBodyToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), \"toString\", this).call(this, true) : \"EnvironmentBodyToken{\" + _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), \"toString\", this).call(this, true) + \"}\";\n        }\n    }, {\n        key: \"environment\",\n        get: function get() {\n            return this.parentNode && getEnvironment(this.parentNode);\n        }\n    }, {\n        key: \"environmentToken\",\n        get: function get() {\n            return this.parentNode && (0, _EnvironmentToken.mustBeEnvironmentToken)(this.parentNode);\n        }\n    }, {\n        key: \"beginCommandToken\",\n        get: function get() {\n            return this.parentNode && getBeginCommandToken(this.parentNode);\n        }\n    }, {\n        key: \"endCommandToken\",\n        get: function get() {\n            return this.parentNode && getEndCommandToken(this.parentNode);\n        }\n    }]);\n\n    return EnvironmentBodyToken;\n}(_index.Token);\n\nObject.defineProperties(EnvironmentBodyToken.prototype, {\n    parentNodeClass_: { value: _EnvironmentToken.EnvironmentToken }\n});\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.EnvironmentToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.mustBeEnvironmentToken = mustBeEnvironmentToken;\nexports.isEnvironmentToken = isEnvironmentToken;\n\nvar _index = __webpack_require__(1);\n\nvar _Environment = __webpack_require__(4);\n\nvar _CommandToken = __webpack_require__(8);\n\nvar _EnvironmentBodyToken = __webpack_require__(14);\n\nvar _SymbolToken = __webpack_require__(2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction mustBeEnvironmentToken(x) {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\nfunction isEnvironmentToken(x) {\n    return x instanceof EnvironmentToken;\n}\n\nvar EnvironmentToken = exports.EnvironmentToken = function (_Token) {\n    _inherits(EnvironmentToken, _Token);\n\n    function EnvironmentToken(initialProperties) {\n        _classCallCheck(this, EnvironmentToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this = _possibleConstructorReturn(this, (EnvironmentToken.__proto__ || Object.getPrototypeOf(EnvironmentToken)).call(this, initialProperties));\n\n        if (!(initialProperties.environment instanceof _Environment.Environment)) throw new TypeError('\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        Object.defineProperty(_this, \"environment\", {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n        return _this;\n    }\n\n    _createClass(EnvironmentToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var beginCommandToken = this.beginCommandToken;\n            var endCommandToken = this.endCommandToken;\n            var bodyToken = this.bodyToken;\n            var source = \"\\\\begin{\" + this.environment.name + \"}\";\n            source += beginCommandToken ? _SymbolToken.SymbolToken.prototype.toString.call(beginCommandToken, true) : \"??\";\n            source += bodyToken ? bodyToken.toString(true) : \"??\";\n            source += \"\\\\end{\" + this.environment.name + \"}\";\n            source += endCommandToken ? _SymbolToken.SymbolToken.prototype.toString.call(endCommandToken, true) : \"??\";\n            return skipNodeClass ? source : \"EnvironmentToken{\" + source + \"}\";\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.environment.lexeme;\n        }\n    }, {\n        key: \"beginCommandToken\",\n        get: function get() {\n            var beginCommandToken = this.childNode(0);\n            return beginCommandToken instanceof _CommandToken.CommandToken ? beginCommandToken : undefined;\n        }\n    }, {\n        key: \"endCommandToken\",\n        get: function get() {\n            var endCommandToken = this.childNode(2);\n            return endCommandToken instanceof _CommandToken.CommandToken ? endCommandToken : undefined;\n        }\n    }, {\n        key: \"bodyToken\",\n        get: function get() {\n            var bodyToken = this.childNode(1);\n            return bodyToken instanceof _EnvironmentBodyToken.EnvironmentBodyToken ? bodyToken : undefined;\n        }\n    }]);\n\n    return EnvironmentToken;\n}(_index.Token);\n\nObject.defineProperties(EnvironmentToken.prototype, {\n    beginToken: { enumerable: true },\n    endToken: { enumerable: true }\n});\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isDirective = isDirective;\nvar Directive = exports.Directive = {\n    BEGIN: \"BEGIN\",\n    END: \"END\"\n};\nfunction isDirective(x) {\n    return Directive.hasOwnProperty(x);\n}\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Context = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _State = __webpack_require__(12);\n\nvar _GROUP = __webpack_require__(9);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Context = exports.Context = function () {\n    function Context() {\n        var opt_source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n        _classCallCheck(this, Context);\n\n        this.source = opt_source;\n        this.position = 0;\n        this.lineNumber = 0;\n        this.charNumber = 0;\n        this.currentToken = undefined;\n        this.currentState = new _State.State();\n        this.stateStack = [];\n        this.comments = [];\n    }\n\n    _createClass(Context, [{\n        key: \"copy\",\n        value: function copy(opt_target) {\n            var target = opt_target || new Context();\n            target.source = this.source;\n            target.position = this.position;\n            target.lineNumber = this.lineNumber;\n            target.charNumber = this.charNumber;\n            target.currentToken = this.currentToken;\n            target.currentState = this.currentState.copy();\n            target.stateStack = this.stateStack.slice();\n            target.comments = this.comments.slice();\n            return target;\n        }\n    }, {\n        key: \"updateState\",\n        value: function updateState(operations) {\n            var _this = this;\n\n            if (!(operations instanceof Array)) throw new TypeError('\"operations\" isn\\'t an Array instance');\n            var newModeStates = {};\n            operations.forEach(function (operation) {\n                switch (operation.directive) {\n                    case \"BEGIN\":\n                        switch (operation.operand) {\n                            case \"GROUP\":\n                                _this.currentState.update(newModeStates);\n                                newModeStates = {};\n                                _this.stateStack.push(_this.currentState.copy());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = true;\n                        }\n                        break;\n                    case \"END\":\n                        switch (operation.operand) {\n                            case _GROUP.GROUP:\n                                newModeStates = {};\n                                if (_this.stateStack.length < 1) throw new Error(\"state stack is empty\");\n                                _this.currentState = (0, _Utils.mustNotBeUndefined)(_this.stateStack.pop());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = false;\n                        }\n                        break;\n                    default:\n                        throw new Error();\n                }\n            });\n            this.currentState.update(newModeStates);\n        }\n    }]);\n\n    return Context;\n}();\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Parameter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isParameterProperties = isParameterProperties;\nexports.mustBeParameterProperties = mustBeParameterProperties;\n\nvar _index = __webpack_require__(7);\n\nvar _Operation = __webpack_require__(11);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction isParameterProperties(ignored) {\n    return true;\n}\nfunction mustBeParameterProperties(x) {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\n\nvar Parameter = exports.Parameter = function (_Item) {\n    _inherits(Parameter, _Item);\n\n    function Parameter() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Parameter);\n\n        var _this = _possibleConstructorReturn(this, (Parameter.__proto__ || Object.getPrototypeOf(Parameter)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this, \"operations_\", {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Operation.Operation(operation);\n                })\n            });\n        }\n        return _this;\n    }\n\n    _createClass(Parameter, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!(other instanceof Parameter)) return false;\n            if (!_get(Parameter.prototype.__proto__ || Object.getPrototypeOf(Parameter.prototype), \"equals\", this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            return this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            });\n        }\n    }, {\n        key: \"operations\",\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }]);\n\n    return Parameter;\n}(_index.Item);\n\nObject.defineProperties(Parameter.prototype, {\n    operations: { enumerable: true }\n});\nObject.defineProperties(Parameter.prototype, {\n    operations_: { value: [], enumerable: false }\n});\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LatexStyle = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Command = __webpack_require__(5);\n\nvar _Environment = __webpack_require__(4);\n\nvar _index = __webpack_require__(6);\n\nvar _Utils = __webpack_require__(0);\n\nvar _State = __webpack_require__(12);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LatexStyle = exports.LatexStyle = function () {\n    function LatexStyle() {\n        _classCallCheck(this, LatexStyle);\n\n        this.symbols_ = {};\n        this.commands_ = {};\n        this.environments_ = {};\n    }\n\n    _createClass(LatexStyle, [{\n        key: \"loadPackage\",\n        value: function loadPackage(packageName, stylePackage) {\n            if (stylePackage.symbols !== undefined) {\n                if (!(stylePackage.symbols instanceof Array)) throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n                for (var iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                    var symbol = new _index.Symbol(stylePackage.symbols[iSymbol]);\n                    if (symbol.pattern) {\n                        var symbolPatternFirstChar = symbol.pattern[0];\n                        if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar)) this.symbols_[symbolPatternFirstChar] = [];\n                        var symbols = this.symbols_[symbolPatternFirstChar];\n                        symbols.push({ symbol: symbol, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.commands !== undefined) {\n                if (!(stylePackage.commands instanceof Array)) throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n                for (var iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                    var command = new _Command.Command(stylePackage.commands[iCommand]);\n                    if (command.name) {\n                        (this.commands_[command.name] || (this.commands_[command.name] = [])).push({ command: command, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.environments !== undefined) {\n                if (!(stylePackage.environments instanceof Array)) throw new TypeError(\"\\\"stylePackage.environments\\\" isn't an Array\");\n                for (var iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0; --iEnvironment) {\n                    var environment = new _Environment.Environment(stylePackage.environments[iEnvironment]);\n                    var envName = environment.name;\n                    if (envName) {\n                        var storedEnv = this.environments_[envName];\n                        if (storedEnv === undefined) {\n                            storedEnv = [];\n                            this.environments_[envName] = storedEnv;\n                        }\n                        storedEnv.push({ environment: environment, packageName: packageName });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"unloadPackage\",\n        value: function unloadPackage(packageName) {\n            for (var symbolPatternFirstChar in this.symbols_) {\n                if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                    var filteredSymbols = (0, _Utils.mustBeArray)(this.symbols_[symbolPatternFirstChar]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredSymbols.length) {\n                        this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                    } else {\n                        delete this.symbols_[symbolPatternFirstChar];\n                    }\n                }\n            }for (var commandName in this.commands_) {\n                if (this.commands_.hasOwnProperty(commandName)) {\n                    var filteredCommands = (0, _Utils.mustBeArray)(this.commands_[commandName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredCommands.length) {\n                        this.commands_[commandName] = filteredCommands;\n                    } else {\n                        delete this.commands_[commandName];\n                    }\n                }\n            }for (var environmentName in this.environments_) {\n                if (this.environments_.hasOwnProperty(environmentName)) {\n                    var filteredEnvironments = (0, _Utils.mustBeArray)(this.environments_[environmentName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredEnvironments.length) {\n                        this.environments_[environmentName] = filteredEnvironments;\n                    } else {\n                        delete this.environments_[environmentName];\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"symbols\",\n        value: function symbols(state, patternFirstChar) {\n            if (!(state instanceof _State.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var symbols = this.symbols_[patternFirstChar];\n            if (symbols === undefined) return [];\n            var filteredSymbols = [];\n            for (var iSymbol = (0, _Utils.mustBeArray)(symbols).length - 1; iSymbol >= 0; --iSymbol) {\n                var symbol = symbols[iSymbol].symbol;\n                if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n            }\n            return filteredSymbols;\n        }\n    }, {\n        key: \"commands\",\n        value: function commands(state, name) {\n            if (!(state instanceof _State.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var commands = this.commands_[name];\n            if (!commands) return [];\n            var filteredCommands = [];\n            for (var iCommand = (0, _Utils.mustBeArray)(commands).length - 1; iCommand >= 0; --iCommand) {\n                var command = commands[iCommand].command;\n                if (state.test(command.modes)) filteredCommands.push(command);\n            }\n            return filteredCommands;\n        }\n    }, {\n        key: \"environments\",\n        value: function environments(state, name) {\n            if (!(state instanceof _State.State)) throw new SyntaxError(\"state isn't State instance\");\n            var environments = this.environments_[name];\n            if (!environments) return [];\n            return (0, _Utils.mustBeArray)(environments).filter(function (env) {\n                return state.test(env.modes);\n            });\n        }\n    }]);\n\n    return LatexStyle;\n}();\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ParameterToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _SymbolToken = __webpack_require__(2);\n\nvar _index = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ParameterToken = exports.ParameterToken = function (_Token) {\n    _inherits(ParameterToken, _Token);\n\n    function ParameterToken(initialProperties) {\n        _classCallCheck(this, ParameterToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this = _possibleConstructorReturn(this, (ParameterToken.__proto__ || Object.getPrototypeOf(ParameterToken)).call(this, initialProperties));\n\n        if (!initialProperties.hasBrackets) Object.defineProperty(_this, \"hasBrackets\", { value: false, enumerable: true });\n        if (initialProperties.hasSpacePrefix) Object.defineProperty(_this, \"hasSpacePrefix\", { value: true, enumerable: true });\n        return _this;\n    }\n\n    _createClass(ParameterToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = this.hasSpacePrefix ? \" \" : \"\";\n            source += this.hasBrackets ? \"{\" + _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), \"toString\", this).call(this, true) + \"}\" : _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), \"toString\", this).call(this, true);\n            return skipNodeClass ? source : \"ParameterToken{\" + source + \"}\";\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n        }\n    }, {\n        key: \"parameter\",\n        get: function get() {\n            var symbolToken = this.parentNode;\n            var symbol = (0, _Utils.mustNotBeUndefined)(symbolToken.symbol);\n            var parameterIndex = symbolToken.childIndex(this);\n            if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0) return symbol.parameter(parameterIndex);\n        }\n    }]);\n\n    return ParameterToken;\n}(_index.Token);\n\nObject.defineProperties(ParameterToken.prototype, {\n    hasBrackets: { value: true, enumerable: true },\n    hasSpacePrefix: { value: false, enumerable: true },\n    parentNodeClass_: { value: _SymbolToken.SymbolToken }\n});\nObject.defineProperties(ParameterToken.prototype, {\n    parameter: { enumerable: true }\n});\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SpaceToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _index = __webpack_require__(1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SpaceToken = exports.SpaceToken = function (_Token) {\n    _inherits(SpaceToken, _Token);\n\n    function SpaceToken(initialProperties) {\n        _classCallCheck(this, SpaceToken);\n\n        var _this = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this, initialProperties));\n\n        _this.lineBreakCount = 0;\n        if (initialProperties !== undefined) {\n            if (initialProperties.lineBreakCount !== undefined) {\n                if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0) throw new TypeError(\"\\\"initialProperties.lineBreakCount\\\" isn't a non-negative number\");\n                _this.lineBreakCount = initialProperties.lineBreakCount;\n            }\n        }\n        return _this;\n    }\n\n    _createClass(SpaceToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (skipNodeClass) {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return \" \";\n                    case 1:\n                        return \"\\n\";\n                    default:\n                        return \"\\n\\n\";\n                }\n            } else {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return \"SpaceToken{ }\";\n                    case 1:\n                        return \"SpaceToken{\\n}\";\n                    default:\n                        return \"SpaceToken{\\n\\n}\";\n                }\n            }\n        }\n    }, {\n        key: \"lexeme\",\n        get: function get() {\n            return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n        }\n    }]);\n\n    return SpaceToken;\n}(_index.Token);\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SyntaxTree = undefined;\n\nvar _Node = __webpack_require__(13);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SyntaxTree = exports.SyntaxTree = function SyntaxTree(rootNode, source) {\n    _classCallCheck(this, SyntaxTree);\n\n    if (!(rootNode instanceof _Node.Node)) throw new TypeError(\"\\\"rootNode\\\" isn't a SyntaxTree.Node instance\");\n    if (!!rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n    if (!!rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n    this.rootNode = rootNode;\n    this.source = (0, _Utils.mustBeString)(source, \"\\\"sources\\\" isn't a string\");\n    rootNode.tree = this;\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LatexParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Context = __webpack_require__(17);\n\nvar _index = __webpack_require__(19);\n\nvar _EnvironmentToken = __webpack_require__(15);\n\nvar _EnvironmentBodyToken = __webpack_require__(14);\n\nvar _Command = __webpack_require__(5);\n\nvar _SpaceToken = __webpack_require__(21);\n\nvar _SymbolToken = __webpack_require__(2);\n\nvar _ParameterToken = __webpack_require__(20);\n\nvar _CommandToken = __webpack_require__(8);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction parseToken_(context, latexStyle) {\n    var token = parseSpaceToken_(context);\n    if (!token) {\n        if (context.position >= context.source.length) return undefined;\n        var contextBackup = context.copy();\n        if (!(token = parseEnvironmentToken_(context, latexStyle))) {\n            contextBackup.copy(context);\n            if (!(token = parseCommandToken_(context, latexStyle))) {\n                contextBackup.copy(context);\n                if (!(token = parseSymbolsToken_(context, latexStyle))) {\n                    return undefined;\n                }\n            }\n        }\n    }\n    processParsedToken_(context, token);\n    return token;\n}\nfunction parseParameterToken_(context, latexStyle, parameter, opt_endLabel) {\n    var currentTokenBackup = context.currentToken;\n    context.updateState(parameter.operations);\n    if (opt_endLabel === undefined) {\n        var spacePrefixState = parseSpaceToken_(context) !== undefined;\n        if (context.source[context.position] === \"{\") {\n            context.currentToken = new _ParameterToken.ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState });\n            ++context.position;\n            ++context.charNumber;\n            if (!parseUntilLabel_(context, latexStyle, \"}\", parameter.lexeme)) return undefined;\n            ++context.position;\n            ++context.charNumber;\n        } else {\n            context.currentToken = new _ParameterToken.ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState });\n            if (parseToken_(context, latexStyle) === undefined) return undefined;\n        }\n    } else {\n        context.currentToken = new _ParameterToken.ParameterToken({ hasBrackets: false, hasSpacePrefix: false });\n        if (!parseUntilLabel_(context, latexStyle, opt_endLabel, parameter.lexeme)) return undefined;\n    }\n    var parameterToken = context.currentToken;\n    context.currentToken = currentTokenBackup;\n    processParsedToken_(context, parameterToken);\n    return parameterToken;\n}\nfunction parseEnvironmentToken_(context, latexStyle) {\n    if (context.source.substring(context.position).indexOf(\"\\\\begin\") !== 0) return undefined;\n    context.position += 6;\n    parseSpaceToken_(context);\n    var nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n    if (!nameMatch) return undefined;\n    var name = nameMatch[1];\n    context.position += nameMatch[0].length;\n    context.charNumber += nameMatch[0].length;\n    var currentTokenBackup = context.currentToken;\n    var environment = latexStyle.environments(context.currentState, name)[0];\n    var environmentToken = context.currentToken = environment ? new _EnvironmentToken.EnvironmentToken({ environment: environment.environment }) : new _EnvironmentToken.EnvironmentToken({ name: name });\n    var symbols = latexStyle.commands(context.currentState, name);\n    var beginCommandToken = parsePatterns_(context, latexStyle, symbols);\n    if (beginCommandToken === undefined) {\n        beginCommandToken = new _CommandToken.CommandToken({ name: name });\n    }\n    processParsedToken_(context, beginCommandToken);\n    var environmentBodyToken = context.currentToken = new _EnvironmentBodyToken.EnvironmentBodyToken();\n    var endFound = parseUntilLabel_(context, latexStyle, \"\\\\end{\" + name + \"}\");\n    context.currentToken = environmentToken;\n    processParsedToken_(context, environmentBodyToken);\n    var endCommandToken = undefined;\n    if (endFound) {\n        context.position += name.length + 6;\n        context.charNumber += name.length + 6;\n        endCommandToken = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, \"end\" + name));\n    } else {}\n    if (endCommandToken === undefined) {\n        endCommandToken = new _CommandToken.CommandToken({ name: \"end\" + name });\n    }\n    processParsedToken_(context, endCommandToken);\n    context.currentToken = currentTokenBackup;\n    return environmentToken;\n}\nfunction parseCommandToken_(context, latexStyle) {\n    var cmdMatch = context.source.substring(context.position).match(/^\\\\((?:[\\w@]+\\*?)|(?:[^\\w]))/);\n    if (!cmdMatch) return undefined;\n    context.position += cmdMatch[0].length;\n    context.charNumber += cmdMatch[0].length;\n    var token = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, cmdMatch[1]));\n    if (token === undefined) {\n        token = new _CommandToken.CommandToken({ name: cmdMatch[1] });\n    }\n    return token;\n}\nfunction parseSymbolsToken_(context, latexStyle) {\n    var sourceCharacter = context.source[context.position];\n    var token = parsePatterns_(context, latexStyle, latexStyle.symbols(context.currentState, sourceCharacter));\n    if (token === undefined) {\n        ++context.position;\n        ++context.charNumber;\n        token = new _SymbolToken.SymbolToken({ pattern: sourceCharacter });\n    } else {}\n    return token;\n}\nfunction parsePatterns_(context, latexStyle, symbols) {\n    var contextBackup = context.copy();\n    var token = undefined;\n    symbols.some(function (symbol) {\n        if (token = parsePattern_(context, latexStyle, symbol)) {\n            return true;\n        } else {\n            contextBackup.copy(context);\n            return false;\n        }\n    });\n    return token;\n}\nfunction parsePattern_(context, latexStyle, symbol) {\n    var currentTokenBackup = context.currentToken;\n    context.currentToken = symbol instanceof _Command.Command ? new _CommandToken.CommandToken({ command: symbol }) : new _SymbolToken.SymbolToken({ symbol: symbol });\n    var patternComponents = symbol.patternComponents;\n    var nPatternComponents = patternComponents.length;\n    var iPatternComponent = 0;\n    for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n        var patternComponent = patternComponents[iPatternComponent];\n        if ((0, _Utils.isNumber)(patternComponent)) {\n            var parameter = symbol.parameter(patternComponent);\n            var parameterEndLabel = patternComponents[iPatternComponent + 1];\n            if (typeof parameterEndLabel === \"string\") {\n                if (parseParameterToken_(context, latexStyle, (0, _Utils.mustNotBeUndefined)(parameter), parameterEndLabel)) {\n                    if (context.source.substring(context.position).indexOf(parameterEndLabel) !== 0) return undefined;\n                    context.position += parameterEndLabel.length;\n                    context.charNumber += parameterEndLabel.length;\n                    ++iPatternComponent;\n                    continue;\n                }\n            } else {\n                if (parseParameterToken_(context, latexStyle, (0, _Utils.mustNotBeUndefined)(parameter))) continue;\n            }\n        } else if ((0, _Utils.isString)(patternComponent)) {\n            while (parseCommentLine_(context)) {}\n            if (context.source.substring(context.position).indexOf(patternComponent) === 0) {\n                context.position += patternComponent.length;\n                context.charNumber += patternComponent.length;\n                continue;\n            }\n        } else if (parseSpaceToken_(context)) continue;\n        break;\n    }\n    if (iPatternComponent < nPatternComponents) return undefined;\n    var parsedToken = context.currentToken;\n    context.currentToken = currentTokenBackup;\n    context.updateState(symbol.operations);\n    return parsedToken;\n}\nfunction parseUntilLabel_(context, latexStyle, endLabel, opt_lexeme) {\n    switch (opt_lexeme) {\n        default:\n            {\n                while (context.source.substring(context.position).indexOf(endLabel) !== 0) {\n                    if (context.position >= context.source.length) {\n                        return false;\n                    }\n                    parseToken_(context, latexStyle);\n                }\n                return true;\n            }\n    }\n}\nfunction parseCommentLine_(context) {\n    var commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false;\n    context.comments.push(commentMatch[1]);\n    context.position += commentMatch[0].length;\n    if (!commentMatch[2]) {\n        context.charNumber += commentMatch[0].length;\n    } else {\n        ++context.lineNumber;\n        context.charNumber = commentMatch[2].length - 1;\n    }\n    return true;\n}\nfunction processParsedToken_(context, token) {\n    if (context.currentToken) {\n        context.currentToken.insertChildSubtree(token);\n    }\n}\nfunction parseSpaceToken_(context) {\n    var isSpace = false;\n    var nLineBreaks = 0;\n    while (context.position < context.source.length) {\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) {\n            case \" \":\n            case \"\\t\":\n                isSpace = true;\n                ++context.position;\n                ++context.charNumber;\n                continue;\n            case \"\\n\":\n                isSpace = true;\n                ++nLineBreaks;\n                ++context.position;\n                ++context.lineNumber;\n                context.charNumber = 0;\n                continue;\n        }\n        break;\n    }\n    return isSpace ? new _SpaceToken.SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\n}\n\nvar LatexParser = exports.LatexParser = function () {\n    function LatexParser(latexStyle) {\n        _classCallCheck(this, LatexParser);\n\n        if (!(latexStyle instanceof _index.LatexStyle)) throw new TypeError(\"\\\"latexStyle\\\" isn't a LatexStyle instance\");\n        this.latexStyle = latexStyle;\n    }\n\n    _createClass(LatexParser, [{\n        key: \"parse\",\n        value: function parse(source, opt_context) {\n            if (typeof source !== \"string\") throw new TypeError(\"\\\"sources\\\" isn't a string\");\n            var context = void 0;\n            if (opt_context === undefined) {\n                context = new _Context.Context(source);\n            } else if (opt_context instanceof _Context.Context) {\n                context = opt_context;\n                context.source += source;\n            } else {\n                throw new TypeError(\"\\\"context\\\" isn't a LatexParser.Context instance\");\n            }\n            var parsedTokens = [];\n            var parsedToken = void 0;\n            while (parsedToken = parseToken_(context, this.latexStyle)) {\n                parsedTokens.push(parsedToken);\n            }return parsedTokens;\n        }\n    }]);\n\n    return LatexParser;\n}();\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.mustBePackageProperties = mustBePackageProperties;\nexports.isPackageProperties = isPackageProperties;\nfunction mustBePackageProperties(x) {\n    if (!isPackageProperties(x)) throw new Error(\"Invalid format for PackageProperties\");\n    return x;\n}\nfunction isPackageProperties(x) {\n    return !Object.keys(x).some(function (k) {\n        switch (k) {\n            case \"symbols\":\n            case \"commands\":\n            case \"environments\":\n                return false;\n            default:\n                return true;\n        }\n    });\n}\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LatexTree = undefined;\n\nvar _index = __webpack_require__(22);\n\nvar _index2 = __webpack_require__(1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar LatexTree = exports.LatexTree = function (_SyntaxTree) {\n    _inherits(LatexTree, _SyntaxTree);\n\n    function LatexTree(rootToken, source) {\n        _classCallCheck(this, LatexTree);\n\n        var token = (0, _index2.mustBeToken)(rootToken, \"\\\"rootToken\\\" isn't a Token instance\");\n        return _possibleConstructorReturn(this, (LatexTree.__proto__ || Object.getPrototypeOf(LatexTree)).call(this, token, source));\n    }\n\n    return LatexTree;\n}(_index.SyntaxTree);\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SourceToken = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _index = __webpack_require__(1);\n\nvar _Lexeme = __webpack_require__(10);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SourceToken = exports.SourceToken = function (_Token) {\n    _inherits(SourceToken, _Token);\n\n    function SourceToken(initialProperties) {\n        _classCallCheck(this, SourceToken);\n\n        var _this = _possibleConstructorReturn(this, (SourceToken.__proto__ || Object.getPrototypeOf(SourceToken)).call(this, initialProperties));\n\n        _this.lexeme = (0, _Lexeme.mustBeLexeme)(initialProperties.lexeme, \"\\\"initialProperties.lexeme\\\" isn't known\");\n        _this.source = (0, _Utils.mustBeString)(initialProperties.source, \"\\\"initialProperties.sources\\\" isn't a string\");\n        return _this;\n    }\n\n    _createClass(SourceToken, [{\n        key: \"toString\",\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? this.source : \"SourceToken[\" + this.lexeme + \"]{\" + this.source + \"}\";\n        }\n    }]);\n\n    return SourceToken;\n}(_index.Token);\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(0);\n\nObject.keys(_Utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Utils[key];\n    }\n  });\n});\n\nvar _Lexeme = __webpack_require__(10);\n\nObject.keys(_Lexeme).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Lexeme[key];\n    }\n  });\n});\n\nvar _Mode = __webpack_require__(3);\n\nObject.keys(_Mode).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Mode[key];\n    }\n  });\n});\n\nvar _Operation = __webpack_require__(11);\n\nObject.keys(_Operation).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Operation[key];\n    }\n  });\n});\n\nvar _State = __webpack_require__(12);\n\nObject.keys(_State).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _State[key];\n    }\n  });\n});\n\nvar _index = __webpack_require__(16);\n\nObject.keys(_index).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _index[key];\n    }\n  });\n});\n\nvar _GROUP = __webpack_require__(9);\n\nObject.keys(_GROUP).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _GROUP[key];\n    }\n  });\n});\n\nvar _Parser = __webpack_require__(23);\n\nObject.keys(_Parser).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Parser[key];\n    }\n  });\n});\n\nvar _Context = __webpack_require__(17);\n\nObject.keys(_Context).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Context[key];\n    }\n  });\n});\n\nvar _index2 = __webpack_require__(19);\n\nObject.keys(_index2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _index2[key];\n    }\n  });\n});\n\nvar _PackageProperties = __webpack_require__(24);\n\nObject.keys(_PackageProperties).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PackageProperties[key];\n    }\n  });\n});\n\nvar _index3 = __webpack_require__(7);\n\nObject.keys(_index3).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _index3[key];\n    }\n  });\n});\n\nvar _Environment = __webpack_require__(4);\n\nObject.keys(_Environment).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Environment[key];\n    }\n  });\n});\n\nvar _Parameter = __webpack_require__(18);\n\nObject.keys(_Parameter).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Parameter[key];\n    }\n  });\n});\n\nvar _index4 = __webpack_require__(6);\n\nObject.keys(_index4).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _index4[key];\n    }\n  });\n});\n\nvar _Command = __webpack_require__(5);\n\nObject.keys(_Command).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Command[key];\n    }\n  });\n});\n\nvar _index5 = __webpack_require__(22);\n\nObject.keys(_index5).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _index5[key];\n    }\n  });\n});\n\nvar _LatexTree = __webpack_require__(25);\n\nObject.keys(_LatexTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexTree[key];\n    }\n  });\n});\n\nvar _Node = __webpack_require__(13);\n\nObject.keys(_Node).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Node[key];\n    }\n  });\n});\n\nvar _index6 = __webpack_require__(1);\n\nObject.keys(_index6).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _index6[key];\n    }\n  });\n});\n\nvar _CommandToken = __webpack_require__(8);\n\nObject.keys(_CommandToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _CommandToken[key];\n    }\n  });\n});\n\nvar _EnvironmentBodyToken = __webpack_require__(14);\n\nObject.keys(_EnvironmentBodyToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _EnvironmentBodyToken[key];\n    }\n  });\n});\n\nvar _EnvironmentToken = __webpack_require__(15);\n\nObject.keys(_EnvironmentToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _EnvironmentToken[key];\n    }\n  });\n});\n\nvar _ParameterToken = __webpack_require__(20);\n\nObject.keys(_ParameterToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _ParameterToken[key];\n    }\n  });\n});\n\nvar _SourceToken = __webpack_require__(26);\n\nObject.keys(_SourceToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _SourceToken[key];\n    }\n  });\n});\n\nvar _SpaceToken = __webpack_require__(21);\n\nObject.keys(_SpaceToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _SpaceToken[key];\n    }\n  });\n});\n\nvar _SymbolToken = __webpack_require__(2);\n\nObject.keys(_SymbolToken).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _SymbolToken[key];\n    }\n  });\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// latex-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3e0e951d148a4946b645","/**\n * @fileoverview General JavaScript utils\n * This file is a part of TeXnous project.\n *\n * @copyright TeXnous project team (http://texnous.org) 2016\n * @license LGPL-3.0\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\nexport type StringMap = { [s: string]: string };\n\nexport type TargetObject = any;\nexport type ValuesObject = any;\n\nexport type OptKeys = StringMap | string[];\n\nexport interface OptAttributes {\n    writable: boolean;\n    enumerable: boolean;\n    configurable: boolean;\n}\n/**\n * Update object properties by property values\n * @param {!Object} target the object to copy properties to\n * @param {!Object} values the object with property values (undefined values will be skipped)\n * @param {(!Object.<string,string>|!Array.<string>)=} opt_keys\n *        list of keys or map of the target keys to the property names, all the enumerable\n *        properties will be used if undefined\n * @param {{writable:boolean,enumerable:boolean,configurable:boolean}=} opt_attributes\n *        property attributes, { writable: true, enumerable: true, configurable: true } by default\n */\nexport function updateProperties(target: TargetObject,\n                                 values: ValuesObject,\n                                 opt_keys?: OptKeys,\n                                 opt_attributes: OptAttributes = {\n                                     writable: true,\n                                     enumerable: true,\n                                     configurable: true\n                                 }) {\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return; // do noting is the sources is undefined\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = {writable: true, enumerable: true, configurable: true};\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) { // if the key map isn't defined\n        for (const key in values) { // for all the enumerable properties\n            //noinspection JSUnfilteredForInLoop\n            if (values[key] !== undefined) {\n                //noinspection JSUnfilteredForInLoop\n                Object.defineProperty(target, key, // update the property\n                    // using the defined value\n                    Object.create(opt_attributes, {value: {value: values[key]}})\n                );\n            }\n        }\n    } else if (opt_keys instanceof Array) { // if the list of the keys is defined\n        opt_keys.forEach(key => {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, // update the property\n                    Object.create(opt_attributes, {value: {value: values[key]}}) // using the defined value\n                );\n            }\n        });\n    } else if (opt_keys instanceof Object) { // if the map of the keys is defined\n        for (const targetKey in opt_keys) { // for all the target keys\n            //noinspection JSUnfilteredForInLoop\n            const key = opt_keys[targetKey]; // the sources key\n            if (values[key] !== undefined)\n            //noinspection JSUnfilteredForInLoop\n                Object.defineProperty(target, targetKey, // update the property\n                    // using the defined value\n                    Object.create(opt_attributes, {value: {value: values[key]}})\n                );\n        }\n    } else { // if \"keys\" has unsupported value\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\n\n\n/**\n * Test object properties with property values (strict comparing is used)\n * @param {!Object} target the object with properties to test\n * @param {?Object} values the object with property values (undefined values will be skipped)\n * @param {?(Object.<string,string>|Array.<string>)} opt_keys\n *        list of keys or map of the target keys to the property names, all the enumerable\n *        properties will be used if undefined\n * @param {boolean=true} opt_skipUndefined true to skip keys with undefined values, false otherwise\n * @return {boolean} true if all the defined properties are the same false otherwise\n */\nexport function testProperties(target: TargetObject,\n                               values?: ValuesObject,\n                               opt_keys?: OptKeys,\n                               opt_skipUndefined = true) {\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true; // do noting is the sources is undefined\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true; // skip undefined by default\n\n    if (opt_keys === undefined) { // if the key map isn't defined\n        for (const key in values) { // for all the enumerable properties\n            //noinspection JSUnfilteredForInLoop // TODO what to do?\n            if (\n                target[key] !== values[key]\n                && !(values[key] === undefined && opt_skipUndefined)\n            )\n                return false; // false if any value is different\n        }\n    } else if (opt_keys instanceof Array) { // if the list of the keys is defined\n        return opt_keys.every(key => {\n            return target[key] === values[key] || (values[key] === undefined && opt_skipUndefined);\n        });\n    } else if (opt_keys instanceof Object) { // if the map of the keys is defined\n        for (const targetKey in opt_keys) { // for all the target keys\n            const key = opt_keys[targetKey]; // the sources key\n            if (target[targetKey] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\n                return false; // false if any value is different\n        }\n    } else { // if \"keys\" has unsupported value\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true; // return true if all the defined properties are the same\n}\n\n\nexport function isNumber(x: any): x is number {\n    return typeof x === \"number\";\n}\n\nexport function isString(x: any): x is string {\n    return typeof x === \"string\";\n}\n\nexport function mustNotBeUndefined<T>(x?: T, msg?: string): T {\n    if (!x) throw new Error(msg);\n    return x;\n}\n\n// @Deprecated\nexport function mustBeObject(o: any, msg?: string) {\n    if (!(o instanceof Object))\n        throw new TypeError(msg ? msg : \"Expected Object\");\n    return o;\n}\n\nexport function mustBeString(o: any, msg?: string): string {\n    if (typeof o !== \"string\")\n        throw new TypeError(msg ? msg : \"Expected string\");\n    return o;\n}\n\nexport function mustBeArray(a: any, msg?: string): any[] {\n    if (!(isArray(a)))\n        throw new TypeError(msg ? msg : \"Expected Array\");\n    return a;\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function isArray(x: any): x is any[] {\n    return x.constructor === Array;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Utils.ts","import {Node} from \"../Node\";\nimport {Lexeme} from \"../../Latex/Lexeme\";\n\n/**\n * LaTeX syntax tree token base properties\n * @interface TokenProperties\n * @property {(?Token|undefined)} parentToken - The parent token or undefined if there is no parent\n * @property {(!Array.<Token>|undefined)} childTokens - The list of the child tokens\n */\nexport interface TokenProperties {\n    parentToken?: Token;\n    childTokens?: Token[];\n}\n\nexport function isToken(x: any): x is Token {\n    return x instanceof Token;\n}\n\nexport function mustBeToken(x: any, msg?: string): Token {\n    if (!isToken(x)) throw new Error(msg);\n    return x;\n}\n\n/**\n * LaTeX syntax tree token base structure\n * @class\n * @extends Node\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme of the token\n */\nexport class Token extends Node {\n    public lexeme?: Lexeme;\n\n    /**\n     * Constructor\n     * @param {!TokenProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: TokenProperties = {}) {\n        if (opt_initialProperties === undefined) { // if the initial properties are not set\n            super(); // superclass constructor\n        } else if (opt_initialProperties instanceof Object) { // if the initial properties are set\n            // superclass constructor\n            // superclass initial properties\n            const superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n            super(superInitialProperties);\n        } else { // if the initial properties are in unsupported type\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        return skipNodeClass ? super.toString(true) : \"Token{\" + super.toString(true) + \"}\";\n    }\n}\n\n// Object.defineProperties(Token.prototype, { // default properties\n//     parentNodeClass_: {value: Token} // parent node must be an EnvironmentToken instance\n// });\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/index.ts","\n\nimport {Token, TokenProperties} from \"./index\";\nimport {Symbol} from \"../../LatexStyle/Item/Symbol/index\";\nimport {Lexeme} from \"../../Latex/Lexeme\";\nimport {mustNotBeUndefined} from \"../../Utils\";\n\n\n/**\n * LaTeX symbol token properties\n * @interface SymbolTokenProperties\n * @extends TokenProperties\n * @property {!Symbol|undefined} symbol - The LaTeX symbol or undefined if the symbol is unrecognized\n * @property {string|undefined} pattern - The pattern that corresponds to the unrecognized symbol\n */\nexport interface SymbolTokenProperties extends TokenProperties {\n    symbol?: Symbol;\n    pattern?: string;\n}\n\n\n/**\n * LaTeX symbol token structure\n * @class\n * @extends Token\n * @property {?Symbol} symbol - The corresponding LaTeX symbol or undefined if the symbol is unrecognized\n * @property {string} pattern - The symbol LaTeX pattern\n */\nexport class SymbolToken extends Token {\n    symbol?: Symbol;\n\n    /**\n     * Constructor\n     * @param {!SymbolTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: SymbolTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (initialProperties.symbol) { // if the symbol is defined\n            if (!(initialProperties.symbol instanceof Symbol))\n                throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            // store the symbol\n            Object.defineProperty(this, \"symbol\", {value: initialProperties.symbol, enumerable: true});\n        } else { // if the symbol isn't defined\n            if (typeof initialProperties.pattern !== \"string\")\n                throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            // store the unrecognized pattern\n            Object.defineProperty(this, \"pattern\", {value: initialProperties.pattern});\n        }\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     */\n    get lexeme(): Lexeme | undefined {\n\n        return this.symbol ? this.symbol.lexeme : undefined;\n    }\n\n\n    /**\n     * Get the symbol LaTeX pattern\n     * @return {string} the symbol pattern\n     */\n    get pattern(): string {\n        return mustNotBeUndefined(this.symbol).pattern;\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        let source = \"\";\n        let iParameter = 0; // the parameter iterator\n\n        const pattern = this.pattern; // LaTeX input pattern\n        // for all the pattern chars\n        for (\n            let nPatternChars = pattern.length, iPatternChar = 0;\n            iPatternChar < nPatternChars;\n            ++iPatternChar\n        ) {\n            const patternChar = pattern[iPatternChar]; // the pattern char\n            if (patternChar === \"#\") { // if a parameter place\n                ++iPatternChar; // go to the next pattern char\n                const parameterToken = this.childNode(iParameter++); // try to get the parameter token\n                source += parameterToken ? parameterToken.toString(true) : \"??\";\n            } else { // if the ordinary pattern char\n                source += patternChar;\n            }\n        }\n        return skipNodeClass ?\n            source :\n            \"SymbolToken\" + (this.symbol ? \"\" : \"[?]\") + \"{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(SymbolToken.prototype, { // default properties\n    symbol: {value: undefined, enumerable: true} // no symbol token\n});\n\nObject.defineProperties(SymbolToken.prototype, { // make getters and setters enumerable\n    pattern: {enumerable: true}\n});\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/SymbolToken.ts","import {isString} from \"../Utils\";\n\n/**\n * TODO Maarten: where does this list come from?! AFAIK LaTeX has just three modes: paragraph, math and LR\n *\n * LaTeX modes\n * @enum {string}\n */\nexport const modes = {\n    LIST: \"LIST\",        // list of items\n    MATH: \"MATH\",        // mathematical expressionLatex\n    PICTURE: \"PICTURE\",  // picture\n    TABLE: \"TABLE\",      // LaTeX tabular\n    TEXT: \"TEXT\",        // general text\n    VERTICAL: \"VERTICAL\" // vertical spacing\n};\n\nexport type KirillMode = keyof typeof modes;\nexport function isKirillMode(x: any): x is KirillMode {\n    return modes.hasOwnProperty(x);\n}\nexport function mustBeKirillMode(x: any, msg?: string): KirillMode {\n    if (!isKirillMode(x)) throw new Error(msg);\n    return x;\n}\n\n/**\n */\nexport type LatexMode = \"Paragraph\" | \"Math\" | \"LR\";\nexport function isLatexMode(x: any): x is LatexMode {\n    if (!isString(x))\n        return false;\n\n    switch (x) {\n        case \"Paragraph\":\n        case \"Math\":\n        case \"LR\":\n            return true;\n        default:\n            return false;\n    }\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function mustBeLatexMode(x: any, msg?: string): LatexMode {\n    if (!isLatexMode(x)) throw new Error(msg);\n    return x;\n}\n\nexport type ModeStates = { [mode: string]: boolean };\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Mode.ts","\nimport {Item, ItemProperties} from \"./index\";\n\n\nexport interface EnvironmentAndPackage {\n    environment: Environment;\n    packageName?: string;\n}\n\n/**\n * LaTeX command properties\n * @interface EnvironmentProperties\n * @extends ItemProperties\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\n */\nexport interface EnvironmentProperties extends ItemProperties {\n    name?: string;\n}\n\n/**\n * LaTeX environment encapsulation\n * @class\n * @extends Item\n * @property {string} name - The environment name (a sequence of letters and optional star)\n */\nexport class Environment extends Item {\n    name: string;\n\n\n    /**\n     * Constructor\n     * @param {!EnvironmentProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: EnvironmentProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.name !== undefined) { // if the name is set\n            if (typeof opt_initialProperties.name !== \"string\")\n                throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            // store the name\n            Object.defineProperty(this, \"name\", {value: opt_initialProperties.name});\n        }\n    }\n\n\n    /**\n     * Compare this environment with the other one\n     * @param {?Environment} other the environment to compare with\n     * @return {boolean} true if the environments are equal, false otherwise\n     * @override\n     */\n    equals(other: any) {\n        if (!(other instanceof Environment)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n        return this.name === other.name;\n    }\n}\n\nObject.defineProperties(Environment.prototype, { // default property values\n    name: {value: \"\", enumerable: true} // empty name\n});\n\n\n\nexport function isEnvironment(x: any): x is Environment {\n    return x instanceof Environment;\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/Item/Environment.ts","import {Symbol, SymbolProperties} from \"./index\";\n\n/**\n * LaTeX command properties\n * @interface CommandProperties\n * @extends SymbolProperties\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\n */\nexport interface CommandProperties extends SymbolProperties {\n    name?: string;\n}\n\nexport interface CommandAndPackage {\n    command: Command;\n    packageName: string;\n}\n\n/**\n * LaTeX command encapsulation\n * @class\n * @extends Symbol\n * @property {string} name - The command name (a sequence of letters and optional star)\n */\nexport class Command extends Symbol {\n    name: string;\n\n\n    /**\n     * Constructor\n     * @param {!CommandProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: CommandProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.name !== undefined) { // if the name is set\n            if (typeof opt_initialProperties.name !== \"string\")\n                throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            // store the name\n            Object.defineProperty(this, \"name\", {value: opt_initialProperties.name});\n        }\n    }\n\n\n    /**\n     * Compare this command with the other one\n     * @param {?Command} other the command to compare with\n     * @return {boolean} true if the commands are equal, false otherwise\n     * @override\n     */\n    equals(other: any) {\n        if (!(other instanceof Command)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n        return this.name === other.name;\n    }\n}\n\nObject.defineProperties(Command.prototype, { // default property values\n    name: {value: \"\", enumerable: true} // empty name\n});\nexport function isCommand(c: any): c is Command {\n    return c instanceof Command;\n}\nexport function mustBeCommand(c: any): Command {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/Item/Symbol/Command.ts","\nimport {mustBeParameterProperties, Parameter, ParameterProperties} from \"../Parameter\";\nimport {Item, ItemProperties} from \"../index\";\nimport {mustBeOperationProperties, Operation, OperationProperties} from \"../../../Latex/Operation\";\nimport {isNumber, mustNotBeUndefined} from \"../../../Utils\";\n/**\n * LaTeX symbol properties\n * @interface SymbolProperties\n * @extends ItemProperties\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations - The LaTeX operations that\n * @property {(!Array.<!Parameter|!ParameterProperties>|undefined)} parameters - The parameters description list\n * @property {(string|undefined)} pattern - The LaTeX input pattern\n * @property {(string|undefined)} html - The HTML output pattern\n * are performed after the symbol\n */\nexport interface SymbolProperties extends ItemProperties {\n    operations?: (Operation | OperationProperties)[];\n    parameters?: (Parameter | ParameterProperties)[];\n    pattern?: string;\n    html?: string;\n}\n\nexport interface SymbolAndPackage {\n    symbol: Symbol;\n    packageName: string;\n}\n\n/**\n * LaTeX symbol encapsulation\n * @class\n * @extends Item\n * @property {!Array.<!Operation>} operations -\n *           The LaTeX operations that are performed after this symbol\n * @property {!Array.<!Parameter>} parameters - The parameters description list\n * @property {!Array.<undefined|string|number>} patternComponents - The LaTeX input pattern components\n * @property {string} pattern - The LaTeX input pattern\n * @property {string} html - The HTML output pattern\n */\nexport class Symbol extends Item {\n    //noinspection JSMismatchedCollectionQueryUpdate // TODO\n    private operations_: Operation[];\n    //noinspection JSMismatchedCollectionQueryUpdate // TODO\n    private parameters_: Parameter[];\n    //noinspection JSMismatchedCollectionQueryUpdate // TODO\n    private patternComponents_: (undefined | string | number)[];\n\n    html: string;\n\n\n    /**\n     * Constructor\n     * @param {!SymbolProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: SymbolProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.operations !== undefined) { // if the operation list is set\n            if (!(opt_initialProperties.operations instanceof Array))\n                throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(this, \"operations_\", { // generate and store the operations list\n                value: opt_initialProperties.operations.map(operation => new Operation(mustBeOperationProperties(operation)))\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) { // if the parameters list is set\n            if (!(opt_initialProperties.parameters instanceof Array))\n                throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            // generate and store the parameters list\n            this.parameters_ = opt_initialProperties.parameters.map(parameter => new Parameter(mustBeParameterProperties(parameter)));\n        }\n        if (opt_initialProperties.pattern !== undefined) { // if the LaTeX pattern is set\n            if (typeof opt_initialProperties.pattern !== \"string\")\n                throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            // try to parse the pattern\n            const patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) { // if there is a non-trivial pattern\n\n                // store the pattern components\n                this.patternComponents_ = patternComponents.map((patternPart: string): string | undefined | number => {\n                    switch (patternPart[0]) {\n                        case \" \":\n                        case \"\\t\": // if a space part\n                            return undefined; // undefined is a mark for spaces\n                        case \"#\": // if a parameter part\n                            const parameterIndex = Number(patternPart.substring(1)) - 1; // the index of a parameter\n                            if (!this.parameters_[parameterIndex])\n                                throw new TypeError(\n                                    '\"initialProperties.pattern\" contains the incorrect parameter number ' +\n                                    patternPart.substring(1)\n                                );\n                            return parameterIndex;\n                        default: // raw pattern part\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) { // if the LaTeX pattern is set\n            if (typeof opt_initialProperties.html !== \"string\")\n                throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            // store the pattern\n            Object.defineProperty(this, \"html\", {value: opt_initialProperties.html, enumerable: true});\n        }\n    }\n\n    /**\n     * Get the LaTeX operations that are performed after this symbol\n     * @return {!Array.<!Operation>} the operation list\n     */\n    get operations(): Operation[] {\n        return this.operations_.slice();\n    }\n\n    /**\n     * Get the parameters description list\n     * @return {!Array.<!Parameter>} the parameter list\n     */\n    get parameters(): Parameter[] {\n        return this.parameters_.slice();\n    }\n\n    /**\n     * Get the parameter description\n     * @param {number} parameterIndex the index of the parameter\n     * @return {?Parameter} the parameter or undefined if there is no parameter with such an index\n     */\n    parameter(parameterIndex: number): Parameter | undefined {\n        return this.parameters_[parameterIndex] || undefined;\n    }\n\n    /**\n     * Get the pattern components\n     * @return {!Array.<!Parameter>} the pattern component list\n     */\n    get patternComponents(): any[] {\n        return mustNotBeUndefined(this.patternComponents_.slice());\n    }\n\n\n    /**\n     * Get the pattern\n     * @return {string} the LaTeX input pattern\n     */\n    get pattern() {\n        return this.patternComponents_.map(patternComponent => {\n            if (isNumber(patternComponent)) {\n                return \"#\" + (patternComponent + 1);\n            }\n            switch (typeof patternComponent) {\n                case \"string\":\n                    return patternComponent;\n                default:\n                    return \" \";\n            }\n        }).join(\"\");\n    }\n\n    /**\n     * Compare this symbol with the other one\n     * @param {?Symbol} other the symbol to compare with\n     * @return {boolean} true if the symbols are equal, false otherwise\n     * @override\n     */\n    equals(other: any): boolean {\n        if (!(other instanceof Symbol)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n\n        if (this.operations_.length !== other.operations_.length) return false;\n        // test all the operations\n\n        if (!this.operations_.every((operation, iOperation) =>\n                operation.equals(other.operations_[iOperation])))\n            return false;\n\n        if (this.parameters_.length !== other.parameters_.length) return false;\n        // test all the parameters\n\n        if (!this.parameters_.every((parameter, iParameter) =>\n                parameter.equals(other.parameters_[iParameter])))\n            return false;\n        return this.html === other.html;\n    }\n}\n\nObject.defineProperties(Symbol.prototype, { // make getters and setters enumerable\n    operations: {enumerable: true},\n    parameters: {enumerable: true},\n    patternComponents: {enumerable: true},\n    pattern: {enumerable: true}\n});\n\nObject.defineProperties(Symbol.prototype, { // default property values\n    operations_: {value: [], enumerable: false, writable: true}, // empty operation list\n    parameters_: {value: [], enumerable: false, writable: true}, // empty parameter list\n    patternComponents_: {value: [], enumerable: false, writable: true}, // empty pattern\n    html: {value: \"\", enumerable: true, writable: true} // empty HTML pattern\n});\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/Item/Symbol/index.ts","import {Lexeme} from \"../../Latex/Lexeme\";\nimport {modes, KirillMode, mustBeKirillMode} from \"../../Latex/Mode\";\nimport {testProperties} from \"../../Utils\";\n\n/**\n * LaTeX style item properties\n * @interface ItemProperties\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme\n * @property {(!Object.<KirillMode, boolean>|undefined)} modes -\n *           The modes where the item is defined or not\n */\nexport interface ItemProperties {\n    lexeme?: Lexeme;\n    modes?: { [mode: string]: boolean };\n}\n\n\n/**\n * LaTeX style item encapsulation\n * @class\n * @property {(?Lexeme)} lexeme - The logical lexeme\n * @property {!Object.<KirillMode, boolean>} modes - The modes where the item is defined or not\n */\nexport class Item {\n    lexeme?: Lexeme;\n    modes: { [mode: string]: boolean };\n\n    /**\n     * Constructor.\n     * @param {!ItemProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: ItemProperties = {}) {\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break; // do nothing if no lexeme defined\n            default:\n                const lexeme = Lexeme[opt_initialProperties.lexeme]; // verify the lexeme\n                if (lexeme === undefined)\n                    throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, \"lexeme\", {value: lexeme});\n        }\n        if (opt_initialProperties.modes !== undefined) {// if the mode states are set\n            if (!(opt_initialProperties.modes instanceof Object))\n                throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, \"modes\", {value: {}}); // create the mode state storage\n            for (const modeKey in opt_initialProperties.modes) { // for all the given modes // TODO better loop\n                const mode: KirillMode = mustBeKirillMode(modeKey); // verify the mode key\n                if (mode === undefined) // if the mode is unknown\n                    throw new TypeError(`\"initialProperties.modes[${modeKey}]\" isn't a Mode option`);\n                // store the mode state\n                //noinspection JSUnfilteredForInLoop\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n\n    /**\n     * Compare this item with the other one\n     * @param {?Item} other the item to compare with\n     * @return {boolean} true if the items are equal, false otherwise\n     */\n    equals(other: any) {\n        if (!(other instanceof Item)) return false;\n        return this.lexeme === other.lexeme &&\n            testProperties(this.modes, other.modes, modes, false);\n    }\n}\n\nObject.defineProperties(Item.prototype, { // default property values\n    lexeme: {value: undefined, enumerable: true}, // no lexeme by default\n    modes: {value: {}, enumerable: true} // no mode mask by default\n});\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/Item/index.ts","import {Command, isCommand, mustBeCommand} from \"../../LatexStyle/Item/Symbol/Command\";\nimport {TokenProperties} from \"./index\";\nimport {SymbolToken} from \"./SymbolToken\";\n\n/**\n * LaTeX command token properties\n * @interface CommandTokenProperties\n * @extends TokenProperties\n * @property {!Command|undefined} command -\n *           The LaTeX command or undefined if the command is unrecognized\n * @property {string|undefined} name - The name that corresponds to the unrecognized command\n */\nexport interface CommandTokenProperties extends TokenProperties {\n    command?: Command;\n    name?: string;\n}\n\n\n/**\n * LaTeX command token structure\n * @class\n * @extends SymbolToken\n * @property {!Command} command -\n *           The corresponding LaTeX command or undefined if the command is unrecognized\n * @property {string|undefined} name - The LaTeX command name\n */\nexport class CommandToken extends SymbolToken {\n    /**\n     * LaTeX command\n     */\n    readonly command: Command;\n    /**\n     * Command name\n     */\n    readonly name: string;\n\n    /**\n     * Constructor\n     * @param {!CommandTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: CommandTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        // copy the initial properties for the superclass\n        const superInitialProperties = Object.create(initialProperties);\n\n        if (initialProperties.command) { // if the command is defined\n            if (!(initialProperties.command instanceof Command))\n                throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            // the command is the symbol for the superclass\n            superInitialProperties.symbol = initialProperties.command;\n            super(superInitialProperties); // the superclass constructor\n\n            this.command = mustBeCommand(initialProperties.command);\n            this.name = this.command.name;\n        } else { // if the command isn't defined\n            if (typeof initialProperties.name !== \"string\")\n                throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = \"\";\n            super(superInitialProperties); // the superclass constructor\n\n            // store the unrecognized name\n            this.name = initialProperties.name;\n        }\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        const source = \"\\\\\" + this.name + super.toString(true);\n        return skipNodeClass ?\n            source :\n            `CommandToken${(isCommand(this.symbol) ? \"\" : \"[?]\")}`\n            + `\\{${source}}`;\n    }\n}\n\n\n// Object.defineProperties(CommandToken.prototype, { // make getters and setters enumerable\n//     command: {enumerable: true},\n//     name: {enumerable: true}\n// });\n\nexport function isCommandToken(x: any): x is CommandToken {\n    return x && x instanceof CommandToken;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/CommandToken.ts","/**\n * Group operand for directives\n * @const {string}\n */\nexport const GROUP = \"GROUP\";\nexport type GROUP = \"GROUP\"; //noinspection JSUnusedGlobalSymbols\nexport function isGROUP(x: any): x is GROUP {\n    return x === GROUP;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Directive/GROUP.ts","/**\n * LaTeX lexeme\n * @enum {string}\n */\nexport const Lexeme = {\n    CELL_SEPARATOR: \"CELL_SEPARATOR\",           // table cell separator\n    BRACKETS: \"BRACKETS\",                       // logical brackets\n    BINARY_OPERATOR: \"BINARY_OPERATOR\",         // mathematical binary operator\n    CHAR: \"CHAR\",                               // character\n    DIGIT: \"DIGIT\",                             // digit\n    DIRECTIVE: \"DIRECTIVE\",                     // LaTeX directive\n    DISPLAY_EQUATION: \"DISPLAY_EQUATION\",       // mathematical equation for display mode\n    FILE_PATH: \"FILE_PATH\",                     // file system path\n    FLOATING_BOX: \"FLOATING_BOX\",               // floating box\n    HORIZONTAL_SKIP: \"HORIZONTAL_SKIP\",         // any type of horizontal skip but not space\n    INLINE_EQUATION: \"INLINE_EQUATION\",         // mathematical equation for inline mode\n    LABEL: \"LABEL\",                             // label identifier\n    LENGTH: \"LENGTH\",                           // linear dimension\n    LETTER: \"LETTER\",                           // word letter\n    LINE_BREAK: \"LINE_BREAK\",                   // text line break\n    NUMBER: \"NUMBER\",                           // sequence of digits\n    LIST: \"LIST\",                               // list of items\n    LIST_ITEM: \"LIST_ITEM\",                     // list item\n    PARAGRAPH_SEPARATOR: \"PARAGRAPH_SEPARATOR\", // paragraph separator\n    PICTURE: \"PICTURE\",                         // picture\n    POST_OPERATOR: \"POST_OPERATOR\",             // mathematical post-operator\n    PRE_OPERATOR: \"PRE_OPERATOR\",               // mathematical pre-operator\n    RAW: \"RAW\",                                 // unprocessable or raw sources\n    SPACE: \"SPACE\",                             // any type of space equivalent\n    SUBSCRIPT: \"SUBSCRIPT\",                     // subscript text\n    SUPERSCRIPT: \"SUPERSCRIPT\",                 // subscript text\n    TABLE: \"TABLE\",                             // table\n    TABULAR_PARAMETERS: \"TABULAR_PARAMETERS\",   // LaTeX tabular parameters\n    TAG: \"TAG\",                                 // formatting tag\n    UNKNOWN: \"UNKNOWN\",                         // unrecognized element\n    VERTICAL_SKIP: \"VERTICAL_SKIP\",             // any type of vertical skip\n    WORD: \"WORD\",                               // sequence of letters\n    WRAPPER: \"WRAPPER\"                          // wrapper for something\n};\nexport type Lexeme = keyof typeof Lexeme;\nexport function isLexeme(x: any): x is Lexeme {\n    return Lexeme.hasOwnProperty(x);\n}\nexport function mustBeLexeme(x: any, msg: string): Lexeme {\n    if (!isLexeme(x)) throw new Error(msg);\n    return x;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Lexeme.ts","\nimport {Directive, isDirective} from \"./Directive/index\";\nimport {GROUP, isGROUP} from \"./Directive/GROUP\";\nimport {isKirillMode, KirillMode, modes} from \"./Mode\";\n\n/**\n * LaTeX operation properties\n * @interface OperationProperties\n * @property {Directive} directive - The directive or undefined if there is no a directive\n * @property {KirillMode|GROUP} operand - The operand or undefined if there is no an operand\n */\nexport interface OperationProperties {\n    directive: Directive;\n    operand: KirillMode | GROUP;\n}\n\nexport function isOperationProperties(x: any): x is OperationProperties {\n    return x\n        && x.hasOwnProperty(\"directive\")\n        && isDirective(x.directive)\n        && x.hasOwnProperty(\"operand\")\n        && (isKirillMode(x.operand) || isGROUP(x.operand))\n        ;\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function mustBeOperationProperties(x: any): OperationProperties {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\n\n/**\n * LaTeX operation encapsulation\n * @class\n * @property {Directive} directive - The directive or undefined if there is no a directive\n * @property {KirillMode|GROUP} operand - The operand or undefined if there is no an operand\n */\nexport class Operation {\n    directive: Directive;\n    operand: KirillMode | GROUP;\n\n\n    /**\n     * Constructor\n     * @param {!OperationProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties?: OperationProperties) {\n        // do nothing if the initial properties aren't defined\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        const directive = Directive[opt_initialProperties.directive]; // validate the directive\n        if (!directive)\n            throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, \"directive\", {value: directive, enumerable: true});\n        switch (opt_initialProperties.operand) {\n            case GROUP: // if operand is a group\n                // store the operand\n                Object.defineProperty(this, \"operand\", {value: GROUP, enumerable: true});\n                break;\n            default:\n                const mode = modes[opt_initialProperties.operand]; // validate the operand as a mode\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.KirillMode option');\n                // store the operand\n                Object.defineProperty(this, \"operand\", {value: mode, enumerable: true});\n        }\n    }\n\n\n    /**\n     * Compare this operation with the other\n     * @param {!Operation} other the operation to compare with\n     * @return {boolean} True if the operations are equal false otherwise\n     */\n    equals(other: any) {\n        if (!(other instanceof Operation)) return false; // type test\n        return this.directive === other.directive && this.operand === other.operand;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Operation.ts","import {modes, ModeStates, mustBeKirillMode} from \"./Mode\";\n\n/**\n * LaTeX state encapsulation\n * @class\n */\nexport class State {\n    private modeStates_: ModeStates;\n\n\n    /**\n     * Constructor\n     * @param {!Object.<KirillMode,boolean>=} opt_initialModeStates the initial mode states\n     * @constructor\n     */\n    constructor(opt_initialModeStates: ModeStates = {}) {\n        Object.defineProperty(this, \"modeStates_\", {value: {}, enumerable: false});\n\n        this.modeStates_[modes.LIST] = false;\n        this.modeStates_[modes.MATH] = false;\n        this.modeStates_[modes.PICTURE] = false;\n        this.modeStates_[modes.TABLE] = false;\n        this.modeStates_[modes.TEXT] = true;\n        this.modeStates_[modes.VERTICAL] = false;\n\n        // update the mode states\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n\n    /**\n     * Create a copy of this state.\n     * @return {!State} the created copy\n     */\n    copy() {\n        return new State(this.modeStates_);\n    }\n\n\n    /**\n     * Update the state with states for modes\n     * @param {!Object.<KirillMode,boolean>} modeStates the states for modes\n     */\n    update(modeStates: ModeStates) {\n        for (const modeKey in modeStates) { // for all the given modes\n            const mode = modes[mustBeKirillMode(modeKey)]; // verify the mode key\n            if (mode === undefined) // if the mode is unknown\n                throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.KirillMode option');\n            this.modeStates_[mode] = modeStates[modeKey]; // store the mode state\n        }\n    }\n\n\n    /**\n     * Test the state with mode states\n     * @param {!Object.<KirillMode,boolean>} modeStates the states for modes\n     * @return {boolean} true if the state fits the modes, false otherwise\n     */\n    test(modeStates: ModeStates) {\n        for (const modeKey in modeStates) { // for all the given modes\n            const mode = modes[mustBeKirillMode(modeKey)]; // verify the mode key\n            if (mode === undefined) // if the mode is unknown\n                throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.KirillMode option');\n            // exit if the mode has different states\n            if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n        }\n        return true;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/State.ts","import {SyntaxTree} from \"./index\";\nimport {isNumber, mustBeArray, mustBeObject, mustNotBeUndefined} from \"../Utils\";\n\n/**\n * Syntax tree node properties\n * @interface NodeProperties\n * @property {(?Node|undefined)} parentNode - The parent node or undefined if there is no parent\n * @property {(!Array.<Node>|undefined)} childNodes - The list of the child nodes\n * @exports\n */\nexport interface NodeProperties {\n    parentNode?: Node;\n    childNodes?: Node[];\n}\n\n\n/**\n * Syntax tree node structure\n * @class\n * @property {?SyntaxTree} tree - The tree or undefined if this node isn't in any tree\n * @property {?Node} parentNode - The parent node or undefined if there is no parent\n * @property {!Array.<Node>} childNodes - The child node list\n * @property {number} subtreeSize - The size of the subtree formed by this node\n */\nexport class Node {\n    tree: SyntaxTree;\n    public parentNode: Node;\n    private subtreeSize: number;\n    private childNodes_: Node[];\n\n    /**\n     * Constructor\n     * @param {!NodeProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties?: NodeProperties) {\n        this.childNodes_ = [];\n\n        if (opt_initialProperties !== undefined) { // if the initial properties are defined\n            mustBeObject(opt_initialProperties, \"initialProperties isn't an Object instance\");\n            if (opt_initialProperties.childNodes !== undefined) { // if the child node list is set\n\n                mustBeArray(opt_initialProperties.childNodes, \"initialProperties.childNodes isn't an Array instance\");\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n\n            }\n            const optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) { // if the parent node is set\n                if (!!optParentNode) {\n                    //noinspection JSUnresolvedFunction\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError(\"initialProperties.parentNode isn't a SyntaxTree.Node instance\");\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Get the child nodes\n     * @return {!Array.<Node>} the child node list\n     */\n    get childNodes(): Node[] {\n        return this.childNodes_.slice();\n    }\n\n\n    /**\n     * Get the child node\n     * @param {(!Node|number)} node the child node or its child index\n     * @return {?Node} the child node or undefined of there is no such a child node\n     */\n    childNode(node: Node | number): Node | undefined {\n        if (isNumber(node)) // if the node child index is given\n            return this.childNodes_[node] || undefined;\n        if (node instanceof Node) // if the child node is given\n            return node.parentNode === this ? node : undefined;\n        throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n    }\n\n\n    /**\n     * Get the child node index\n     * @param {(!Node|number)} node the child node or its child index\n     * @return {(number|undefined)} the child node or undefined of there is no such a child node\n     */\n    childIndex(node: Node | number): number | undefined {\n        if (isNumber(node)) // if the node child index is given\n            return this.childNodes_[node] ? node : undefined;\n        if (node instanceof Node) // if the child node is given\n            return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n        throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n    }\n\n\n    /**\n     * Insert a node to this child node list\n     * @param {!Node} node the node to insert (must have no parent and no child nodes)\n     * @param {number=undefined} childIndex\n     *        the position of the node for this child node list, the last by default\n     * @param {number=0} childNodesToCover\n     *        the number of this child nodes to become the child nodes of the new node\n     * @return {?Node} the inserted node or undefined if cannot insert\n     */\n    insertChildNode(node: Node, childIndex: number, childNodesToCover: number): Node {\n        if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n        if (node.parentNode) throw new TypeError('\"node\" has a parent');\n        if (node.tree) throw new TypeError('\"node\" is a tree root');\n\n        // TODO\n        // if (!(this instanceof node.parentNodeClass_))\n        //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\n\n        if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n        if (!this.hasOwnProperty(\"childNodes_\")) // if there was no child nodes\n        // init the property\n            this.childNodes_ = [];\n        // use the last position by default\n        if (childIndex === undefined) childIndex = this.childNodes_.length;\n        // do not cover any child nodes by default\n        if (childNodesToCover === undefined) childNodesToCover = 0;\n        // replace the child nodes by the new node\n        const nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n        // update the size of the subtree formed by this node\n        this.subtreeSize = this.subtreeSize + 1;\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            parentNode.subtreeSize = parentNode.subtreeSize + 1;\n        }\n        // update the parent node of the new node\n        Object.defineProperty(node, \"parentNode\", {\n            value: this,\n            enumerable: true,\n            configurable: true\n        });\n        if (nodeChildNodes.length) { // if there are child nodes for the new node\n            // store the child nodes\n            Object.defineProperty(node, \"childNodes_\", {value: nodeChildNodes, configurable: true});\n            let subtreeSize = 1; // initiate the size of the subtree formed by the new node\n            // for all the child nodes of the new node\n            nodeChildNodes.forEach(nodeChildNode => {\n                subtreeSize += nodeChildNode.subtreeSize;\n            });\n            // store the subtree size\n            Object.defineProperty(node, \"subtreeSize\", {\n                value: subtreeSize,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        return node;\n    }\n\n\n    /**\n     * Insert a subtree to this child node list.\n     * @param {!Node} node the subtree to insert root node (must have no parent)\n     * @param {number=} childIndex\n     *        the position of the subtree root for this child node list, the last by default\n     */\n    insertChildSubtree(node: Node, childIndex?: number) {\n        if (!(node instanceof Node))\n            throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n        if (node.parentNode) throw new TypeError('\"node\" has a parent');\n        if (node.tree) throw new TypeError('\"node\" is a tree root');\n\n        // todo check\n        // if (!(this instanceof node.parentNodeClass_))\n        //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\n        // init child nodes property if not exists\n        if (!this.hasOwnProperty(\"childNodes_\")) // if there was no child nodes\n        // init the property\n            Object.defineProperty(this, \"childNodes_\", {value: [], configurable: true});\n        // use the last position by default\n        if (childIndex === undefined)\n            childIndex = this.childNodes_.length;\n\n        this.childNodes_.splice(childIndex, 0, node); // insert the new node to the child list\n        const nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\n        // update the size of the subtree formed by this node\n        Object.defineProperty(this, \"subtreeSize\", {\n            value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n        });\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            Object.defineProperty(parentNode, \"subtreeSize\", {\n                value: parentNode.subtreeSize + nodeSubtreeSize\n            });\n        }\n        // update the parent node of the new node\n        Object.defineProperty(node, \"parentNode\", {\n            value: this,\n            enumerable: true,\n            configurable: true\n        });\n    }\n\n\n    /**\n     * Remove a child node of this node. All its child nodes become the child nodes of this node\n     * @param {(!Node|number)} nodeOrNodeIndex the subtree root or its child index\n     * @return {?Node} the removed node or undefined of there is no such a child node\n     */\n    removeChildNode(nodeOrNodeIndex: number | Node): Node | undefined {\n        const nodeChildIndex: number | undefined = this.childIndex(nodeOrNodeIndex); // the child index of the node\n        if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\n\n        const node: Node = this.childNodes_[nodeChildIndex]; // the child node to remove\n\n        // replace the node with its child nodes at this child node list\n        // todo could be more efficient?\n        this.childNodes_.splice(nodeChildIndex, 1, ...node.childNodes_);\n\n        if (this.childNodes_.length) { // if there are child nodes\n            // update this node subtree size\n            this.subtreeSize = this.subtreeSize - 1;\n        } else { // if there are no child nodes\n            delete this.childNodes_; // this node has no child nodes anymore\n            delete this.subtreeSize; // this node has node subtree anymore\n        }\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            parentNode.subtreeSize = parentNode.subtreeSize - 1;\n        }\n        delete node.parentNode; // the node has no parent node anymore\n\n        delete node.childNodes_; // the node has no child nodes anymore\n        delete node.subtreeSize; // the node has no subtree anymore\n        return node;\n    }\n\n\n    /**\n     * Remove a subtree formed by a child node of this node\n     * @param {(!Node|number)} node the subtree root or its child index\n     * @return {?Node} the removed subtree root node or undefined of there is no such a child node\n     */\n    removeChildSubtree(node: Node | number): Node | undefined {\n        const nodeChildIndex: number | undefined = this.childIndex(node); // the child index of the node\n\n        if (nodeChildIndex === undefined)\n            return undefined; // return if there is no such a child\n\n        const theNode: Node = mustNotBeUndefined(this.childNodes_.splice(nodeChildIndex, 1)[0]); // remove the node from the child list\n        const nodeSubtreeSize = theNode.subtreeSize; // the size of the subtree formed by the node\n        if (this.childNodes_.length) { // if there are child nodes\n            // update this node subtree size\n            Object.defineProperty(this, \"subtreeSize\", {value: this.subtreeSize - nodeSubtreeSize});\n        } else { // if there are no child nodes\n            delete this.childNodes_; // this node has no child nodes anymore\n            delete this.subtreeSize; // this node has node subtree anymore\n        }\n        // for all the parent nodes\n        for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n            // update the size of the subtree formed by the parent node\n            Object.defineProperty(parentNode, \"subtreeSize\", {\n                value: parentNode.subtreeSize - nodeSubtreeSize\n            });\n        }\n        delete theNode.parentNode; // the node has no parent node anymore\n        return theNode;\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false): string {\n        let source = \"\"; // the sources\n        // for all the child nodes\n        this.childNodes_.forEach(childNode => {\n            source += childNode.toString(true);\n        });\n        return skipNodeClass ? source : \"SourceTree.Node{\" + source + \"}\";\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Node.ts","\nimport {Token} from \"./index\";\nimport {CommandToken, isCommandToken} from \"./CommandToken\";\nimport {Environment, isEnvironment} from \"../../LatexStyle/Item/Environment\";\nimport {EnvironmentToken, mustBeEnvironmentToken} from \"./EnvironmentToken\";\n\n\nfunction getBeginCommandToken(x: any): CommandToken | undefined {\n    if (isCommandToken(x.beginCommandToken))\n        return x.beginCommandToken;\n}\n\nfunction getEndCommandToken(x: any): CommandToken | undefined {\n    if (isCommandToken(x.endCommandToken))\n        return x.endCommandToken;\n}\n\nfunction getEnvironment(x: any): Environment | undefined {\n    if (x.environment && isEnvironment(x.environment))\n        return x.environment;\n}\n\n\n/**\n * LaTeX environment body token structure\n * @class\n * @extends Token\n * @property {?Environment} environment -\n *           The LaTeX environment or undefined if there is no parent environment\n * @property {?EnvironmentToken} environmentToken - The parent environment token\n * @property {?CommandToken} beginCommandToken -\n *           The environment begin command token or undefined is there is no such a token\n * @property {?CommandToken} endCommandToken -\n *           The environment end command token or undefined is there is no such a token\n */\nexport class EnvironmentBodyToken extends Token {\n\n    /**\n     * Get the LaTeX environment\n     * @return {?Environment} the environment or undefined if there is no parent environment\n     */\n    get environment(): Environment | undefined {\n        return this.parentNode && getEnvironment(this.parentNode);\n    }\n\n\n    //noinspection JSUnusedGlobalSymbols\n    /**\n     * Get the parent environment token\n     * @return {?EnvironmentToken} the environment or undefined if there is no parent environment\n     */\n    get environmentToken(): EnvironmentToken | undefined {\n        return this.parentNode && mustBeEnvironmentToken(this.parentNode);\n    }\n\n\n    /**\n     * Get the environment begin command token\n     * @return {?CommandToken} the command token or undefined if there is no begin command\n     */\n    get beginCommandToken() {\n        return this.parentNode && getBeginCommandToken(this.parentNode);\n    }\n\n\n    /**\n     * Get the environment end command token\n     * @return {(CommandToken|undefined)} the command token or undefined if there is no end command\n     */\n    get endCommandToken() {\n        return this.parentNode && getEndCommandToken(this.parentNode);\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        return skipNodeClass ?\n            super.toString(true) :\n            \"EnvironmentBodyToken{\" + super.toString(true) + \"}\";\n    }\n}\n\n// todo remove\nObject.defineProperties(EnvironmentBodyToken.prototype, { // default properties\n    // parent node must be an EnvironmentToken instance\n    parentNodeClass_: {value: EnvironmentToken}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/EnvironmentBodyToken.ts","\nimport {Token, TokenProperties} from \"./index\";\nimport {Environment} from \"../../LatexStyle/Item/Environment\";\nimport {CommandToken} from \"./CommandToken\";\nimport {EnvironmentBodyToken} from \"./EnvironmentBodyToken\";\nimport {SymbolToken} from \"./SymbolToken\";\n\n/**\n * LaTeX environment token properties\n * @interface EnvironmentTokenProperties\n * @extends TokenProperties\n * @property {!Environment} environment - The LaTeX environment\n * @property\n */\n\nexport interface EnvironmentTokenPropertiesWithEnvironment\n    extends EnvironmentTokenProperties {\n    environment: Environment;\n    name: undefined;\n}\n\nexport interface EnvironmentTokenPropertiesWithName\n    extends EnvironmentTokenProperties {\n    environment: undefined;\n    name: string;\n}\n\nexport interface EnvironmentTokenProperties\n    extends TokenProperties {\n    environment?: Environment;\n    name?: string;\n}\n\n\nexport function mustBeEnvironmentToken(x: any): EnvironmentToken {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\n\nexport function isEnvironmentToken(x: any): x is EnvironmentToken {\n    return x instanceof EnvironmentToken;\n}\n\n/**\n * LaTeX environment token structure\n * @class\n * @extends Token\n * @property {!Environment} environment - The corresponding LaTeX environment\n * @property {?CommandToken} beginCommandToken -\n *           The environment begin command token or undefined is there is no such a token\n * @property {?CommandToken} endCommandToken -\n *           The environment end command token or undefined is there is no such a token\n * @property {?EnvironmentBodyToken} bodyToken -\n *           The environment body token or undefined is there is no such a token\n */\nexport class EnvironmentToken extends Token {\n    environment: Environment;\n\n    /**\n     * Constructor\n     * @param {!EnvironmentTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: EnvironmentTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (!(initialProperties.environment instanceof Environment))\n            throw new TypeError(\n                '\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        // store the environment\n        Object.defineProperty(this, \"environment\", {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     */\n    get lexeme() {\n        return this.environment.lexeme;\n    }\n\n\n    /**\n     * Get the begin command token\n     * @return {?CommandToken} the command token or undefined if there is no begin command\n     */\n    get beginCommandToken() {\n        const beginCommandToken = this.childNode(0);\n        return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\n    }\n\n\n    /**\n     * Get the end command token\n     * @return {?CommandToken} the command token or undefined if there is no end command\n     */\n    get endCommandToken() {\n        const endCommandToken = this.childNode(2);\n        return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\n    }\n\n\n    /**\n     * Get the environment body token\n     * @return {?EnvironmentBodyToken} the body or undefined if there is no body\n     */\n    get bodyToken() {\n        const bodyToken = this.childNode(1);\n        return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        const beginCommandToken = this.beginCommandToken; // the begin command token\n        const endCommandToken = this.endCommandToken; // the end command token\n        const bodyToken = this.bodyToken; // the environment body token\n        let source = \"\\\\begin{\" + this.environment.name + \"}\";\n        source += beginCommandToken ?\n            SymbolToken.prototype.toString.call(beginCommandToken, true) :\n            \"??\";\n        source += bodyToken ? bodyToken.toString(true) : \"??\";\n        source += \"\\\\end{\" + this.environment.name + \"}\";\n        source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : \"??\";\n        return skipNodeClass ? source : \"EnvironmentToken{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(EnvironmentToken.prototype, { // make getters and setters enumerable\n    beginToken: {enumerable: true},\n    endToken: {enumerable: true}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/EnvironmentToken.ts","/**\n * LaTeX directive\n * @enum {string}\n */\nexport const Directive = {\n    BEGIN: \"BEGIN\", // begin something\n    END: \"END\"    // end something\n};\nexport type Directive = keyof typeof Directive;\n\nexport function isDirective(x: any): x is Directive {\n    return Directive.hasOwnProperty(x);\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Directive/index.ts","import {State} from \"../State\";\nimport {Token} from \"../../SyntaxTree/Token/index\";\nimport {Operation} from \"../Operation\";\nimport {ModeStates} from \"../Mode\";\nimport {GROUP} from \"../Directive/GROUP\";\nimport {mustNotBeUndefined} from \"../../Utils\";\n\n/**\n * The parsing context\n *\n * @struct\n * @property {string} source - The source to parse\n * @property {number} position - The current position in the source\n * @property {?Token} currentToken - The currently parsing token\n * @property {!State} currentState - The current LaTeX state\n * @property {!Array.<!State>} stateStack - The stack of LaTeX sates\n * @property {!Array.<string>} comments - The comment list for the nex token\n * @property {number} lineNumber - The current line number\n * @property {number} charNumber - The current char number in the current line\n * @property {function} copy\n */\nexport class Context {\n    source: string;\n    position: number;\n    currentToken?: Token;\n    currentState: State;\n    stateStack: State[];\n    comments: string[];\n    lineNumber: number;\n    charNumber: number;\n\n\n    /**\n     * Constructor\n     * @param {string=} opt_source the sources to parse (empty string by default)\n     */\n    constructor(opt_source = \"\") {\n        this.source = opt_source; // store the sources\n        this.position = 0; // start from the beginning\n        this.lineNumber = 0; // start from the line 0\n        this.charNumber = 0; // start from the char 0\n        this.currentToken = undefined; // no tokens were parsed\n        this.currentState = new State(); // initial LaTeX state\n        this.stateStack = []; // no stored states\n        this.comments = []; // no comments for the next token\n    }\n\n\n    /**\n     * Copy this context\n     * @param {!Context=} opt_target the context to copy to or undefined to create a new one\n     * @return {!Context} the context copy\n     */\n    copy(opt_target?: Context): Context {\n        const target = opt_target || new Context(); // the context to copy this context in\n        target.source = this.source;\n        target.position = this.position;\n        target.lineNumber = this.lineNumber;\n        target.charNumber = this.charNumber;\n        target.currentToken = this.currentToken;\n        target.currentState = this.currentState.copy();\n        target.stateStack = this.stateStack.slice();\n        target.comments = this.comments.slice();\n        return target;\n    }\n\n\n    /**\n     * Update the LaTeX state\n     * @param {!Array.<!Operation>} operations the LaTeX operation list\n     */\n    updateState(operations: Operation[]) {\n        if (!(operations instanceof Array))\n            throw new TypeError('\"operations\" isn\\'t an Array instance');\n        let newModeStates: ModeStates = {}; // the modes to update\n        operations.forEach((operation: Operation) => {\n\n            switch (operation.directive) {\n                case \"BEGIN\":\n                    switch (operation.operand) {\n                        case \"GROUP\":\n                            this.currentState.update(newModeStates); // store the mode states\n                            newModeStates = {}; // no more states to update\n                            this.stateStack.push(this.currentState.copy()); // store the current state\n                            break;\n                        default:\n\n                            newModeStates[operation.operand] = true; // turn the state on\n                    }\n                    break;\n                case \"END\":\n                    switch (operation.operand) {\n                        case GROUP:\n                            newModeStates = {}; // no need to store the states\n                            if (this.stateStack.length < 1) throw new Error(\"state stack is empty\");\n                            this.currentState = mustNotBeUndefined(this.stateStack.pop()); // restore the current state\n                            break;\n                        default:\n\n                            newModeStates[operation.operand] = false; // turn the state off\n                    }\n                    break;\n                default:\n                    throw new Error();\n            }\n        });\n        this.currentState.update(newModeStates); // store the mode states\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Parser/Context.ts","import {Item, ItemProperties} from \"./index\";\nimport {Operation, OperationProperties} from \"../../Latex/Operation\";\n\n/**\n * LaTeX symbol or command parameter properties\n * @interface ParameterProperties\n * @extends ItemProperties\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations -\n *           The LaTeX operations that are performed before the parameter\n */\nexport interface ParameterProperties extends ItemProperties {\n    operations?: (Operation | OperationProperties)[];\n}\n\nexport function isParameterProperties(ignored: any): ignored is ParameterProperties {\n    return true; // todo fields are all optional\n}\n\nexport function mustBeParameterProperties(x: any): ParameterProperties {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\n\n/**\n * LaTeX symbol or command parameter encapsulation\n * @class\n * @extends Item\n * @property {!Array.<!Operation>} operations -\n *           The LaTeX operations that are performed before this parameter\n */\nexport class Parameter extends Item {\n    //noinspection JSMismatchedCollectionQueryUpdate TODO\n    private operations_: Operation[];\n\n\n    /**\n     * Constructor\n     * @param {!ParameterProperties=} opt_initialProperties the initial property values\n     */\n    constructor(opt_initialProperties: ParameterProperties = {}) {\n        super(opt_initialProperties); // the superclass constructor\n        // do nothing if there are no initial properties\n        if (opt_initialProperties === undefined) return;\n        if (opt_initialProperties.operations !== undefined) { // if the operation list is set\n            if (!(opt_initialProperties.operations instanceof Array))\n                throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(this, \"operations_\", { // generate and store the operations list\n                value: opt_initialProperties.operations.map(operation => new Operation(operation))\n            });\n        }\n    }\n\n\n    /**\n     * Get the LaTeX operations that are performed before this parameter\n     * @return {!Array.<!Operation>} the operation list\n     */\n    get operations(): Operation[] {\n        return this.operations_.slice();\n    }\n\n\n    /**\n     * Compare this parameter with the other one\n     * @param {?Parameter} other the parameter to compare with\n     * @return {boolean} true if the parameters are equal, false otherwise\n     * @override\n     */\n    equals(other: any) {\n        if (!(other instanceof Parameter)) return false; // type test\n        if (!super.equals(other)) return false; // superclass test\n\n        if (this.operations_.length !== other.operations_.length) return false;\n        // test all the operations\n\n        return this.operations_.every((operation, iOperation) =>\n            operation.equals(other.operations_[iOperation]));\n    }\n}\n\nObject.defineProperties(Parameter.prototype, { // make getters and setters enumerable\n    operations: {enumerable: true}\n});\nObject.defineProperties(Parameter.prototype, { // default property values\n    operations_: {value: [], enumerable: false} // empty operation list by default\n});\n\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/Item/Parameter.ts","import {Command, CommandAndPackage} from \"./Item/Symbol/Command\";\nimport {Environment, EnvironmentAndPackage} from \"./Item/Environment\";\nimport {Symbol, SymbolAndPackage} from \"./Item/Symbol/index\";\nimport {mustBeArray} from \"../Utils\";\nimport {State} from \"../Latex/State\";\nimport {PackageProperties} from \"./PackageProperties\";\n\n\n/**\n * LaTeX style collection\n * @class\n */\nexport class LatexStyle {\n    private environments_: { [name: string]: EnvironmentAndPackage[] };\n    private commands_: { [name: string]: CommandAndPackage[] };\n    private symbols_: { [name: string]: SymbolAndPackage[] };\n\n\n    /**\n     * Constructor\n     */\n    constructor() {\n        /**\n         * The symbols by the first symbol of the pattern in the priority increasing order\n         * @private {!Object.<string,!Array.<!Symbol>>}\n         * @name symbols_\n         */\n        this.symbols_ = {};\n        /**\n         * The commands by the name in the priority increasing order\n         * @private {!Object.<string,!Array.<!Command>>}\n         * @name commands_\n         */\n        this.commands_ = {};\n        /**\n         * The environments by the name in the priority increasing order\n         * @private {!Object.<string,!Array.<!Environment>>}\n         * @name environments_\n         */\n        this.environments_ = {};\n    }\n\n\n    /**\n     * Load a package with style definitions\n     * @param {string} packageName the name of the style package\n     * @param {PackageProperties} stylePackage the style package\n     */\n    loadPackage(packageName: string, stylePackage: PackageProperties) {\n        if (stylePackage.symbols !== undefined) { // if the symbol descriptions are defined\n            if (!(stylePackage.symbols instanceof Array))\n                throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n            // for all the symbol descriptions\n            for (let iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                const symbol: Symbol = new Symbol(stylePackage.symbols[iSymbol]); // the symbol description\n                if (symbol.pattern) { // if the symbol has a pattern\n                    const symbolPatternFirstChar = symbol.pattern[0]; // the first char of the pattern\n                    // the symbols with the same pattern first char\n                    if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar))\n                        this.symbols_[symbolPatternFirstChar] = [];\n                    //noinspection JSMismatchedCollectionQueryUpdate // TODO what to do?\n                    const symbols: SymbolAndPackage[] = this.symbols_[symbolPatternFirstChar];\n\n                    symbols.push({symbol, packageName}); // store the symbol and the package name\n                }\n            }\n        }\n        if (stylePackage.commands !== undefined) { // if the command descriptions are defined\n            if (!(stylePackage.commands instanceof Array))\n                throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n            // for all the command descriptions\n            for (let iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                const command = new Command(stylePackage.commands[iCommand]); // the command description\n                if (command.name) { // if the command has a name\n                    // the commands with the same name\n                    (this.commands_[command.name] || (this.commands_[command.name] = []))\n                        .push({command, packageName}); // store the command and the package name\n                }\n            }\n        }\n        if (stylePackage.environments !== undefined) { // if the environment descriptions are defined\n            if (!(stylePackage.environments instanceof Array))\n                throw new TypeError(`\"stylePackage.environments\" isn't an Array`);\n            // for all the environment descriptions\n            for (let iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0;\n                 --iEnvironment) {\n                // the environment description\n                const environment: Environment = new Environment(stylePackage.environments[iEnvironment]);\n                const envName: string = environment.name;\n                if (envName) { // if the environment has a name\n                    // the environments with the same name\n                    let storedEnv = this.environments_[envName];\n                    if (storedEnv === undefined) {\n                        storedEnv = [];\n                        this.environments_[envName] = storedEnv;\n                    }\n                    storedEnv.push({environment, packageName}); // store the environment and the package name\n                }\n            }\n        }\n    }\n\n    /**\n     * Unload a package with style definitions\n     * @param {string} packageName the name of the style package\n     */\n    unloadPackage(packageName: string) {\n        // for all the symbol pattern first chars\n        for (const symbolPatternFirstChar in this.symbols_)\n            if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                // the filtered symbols with the same pattern first char\n                const filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar])\n                    .filter(styleItem => {\n                        return styleItem.packageName !== packageName;\n                    });\n                // if there are still some symbols with the same pattern first char\n                if (filteredSymbols.length) {\n                    // store the filtered symbol descriptions\n                    this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                } else { // if there are no the symbols with the same pattern first char\n                    delete this.symbols_[symbolPatternFirstChar]; // delete the key-value pair\n                }\n            }\n        // for all the command names\n        for (const commandName in this.commands_) if (this.commands_.hasOwnProperty(commandName)) {\n            // the filtered commands with the same name\n            const filteredCommands = mustBeArray(this.commands_[commandName]).filter(styleItem => {\n                return styleItem.packageName !== packageName;\n            });\n            if (filteredCommands.length) { // if there are still some commands with the same name\n                this.commands_[commandName] = filteredCommands; // store the filtered command descriptions\n            } else { // if there are no the commands with the same name\n                delete this.commands_[commandName]; // delete the key-value pair\n            }\n        }\n        // for all the environment names\n        for (const environmentName in this.environments_)\n            if (this.environments_.hasOwnProperty(environmentName)) {\n                // the filtered environments with the same name\n                const filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(styleItem => {\n                    return styleItem.packageName !== packageName;\n                });\n                // if there are still some environments with the same name\n                if (filteredEnvironments.length) {\n                    // store the filtered environment descriptions\n                    this.environments_[environmentName] = filteredEnvironments;\n                } else { // if there are no the environments with the same name\n                    delete this.environments_[environmentName]; // delete the key-value pair\n                }\n            }\n    }\n\n\n    /**\n     * Get symbols\n     * @param {!State} state the state that the symbols must match to\n     * @param {string} patternFirstChar the first char of the symbol parameter pattern\n     * @return {!Array.<!Symbol>} the list of symbols in the priority descending order\n     */\n    symbols(state: State, patternFirstChar: string) {\n        if (!(state instanceof State))\n            throw new SyntaxError('\"state\" isn\\'t a State instance');\n        // all the symbols with the defined first pattern char\n        const symbols = this.symbols_[patternFirstChar];\n        if (symbols === undefined) return []; // return empty list if there are no such symbols\n        const filteredSymbols = []; // the list of the symbols matching to the state\n        for (let iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) { // for all the symbols\n            const symbol = symbols[iSymbol].symbol; // the symbol\n            // store the symbol if it matches to the state\n            //noinspection JSUnresolvedFunction\n            if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n        }\n        return filteredSymbols;\n    }\n\n\n    /**\n     * Get commands\n     * @param {!State} state the state that the commands must match to\n     * @param {!string} name the name of the command\n     * @return {Array.<Command>} the list of commands in the priority descending order\n     */\n    commands(state: State, name: string): Command[] {\n        if (!(state instanceof State))\n            throw new SyntaxError('\"state\" isn\\'t a State instance');\n        const commands = this.commands_[name]; // all the commands with the defined name\n        if (!commands) return []; // return empty list if there are no such commands\n        const filteredCommands = []; // the list of the commands matching to the state\n        for (let iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) { // for all the commands\n            const command = commands[iCommand].command; // the command\n            // store the command if it matches to the state\n            //noinspection JSUnresolvedFunction\n            if (state.test(command.modes)) filteredCommands.push(command);\n        }\n        return filteredCommands;\n    }\n\n\n    /**\n     * Get environments\n     * @param {!State} state the state that the environments must match to\n     * @param {!string} name the name of the environment\n     * @return {Array.<Environment>} the list of environments in the priority descending order\n     */\n    environments(state: State, name: string): EnvironmentAndPackage[] {\n        if (!(state instanceof State)) throw new SyntaxError(\"state isn't State instance\");\n        const environments: EnvironmentAndPackage[] = this.environments_[name]; // all the environments with the defined name\n        if (!environments) return []; // return empty list if there are no such environments\n\n        // store the environment if it matches to the state\n        return mustBeArray(environments)\n            .filter(env => state.test(env.modes));\n    }\n}\n\n\n// export default LatexStyle;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/index.ts","\nimport {SymbolToken} from \"./SymbolToken\";\nimport {Token, TokenProperties} from \"./index\";\nimport {Lexeme} from \"../../Latex/Lexeme\";\nimport {Parameter} from \"../../LatexStyle/Item/Parameter\";\nimport {mustNotBeUndefined} from \"../../Utils\";\n\n\n/**\n * LaTeX parameter token properties\n * @interface ParameterTokenProperties\n * @extends TokenProperties\n * @property {boolean} hasBrackets - True if the parameter is bounded by the logical brackets, false otherwise\n * @property {boolean} hasSpacePrefix - True if the parameter is prefixed by a space, false otherwise\n */\nexport interface ParameterTokenProperties extends TokenProperties {\n    hasBrackets: boolean;\n    hasSpacePrefix: boolean;\n}\n\n\n/**\n * LaTeX parameter token structure\n * @class\n * @extends Token\n * @property {boolean} hasBrackets -\n *           True if the parameter is bounded by the logical brackets, false otherwise\n * @property {boolean} hasSpacePrefix -\n *           True if the parameter is prefixed by a space, false otherwise\n * @property {?Parameter} parameter - The corresponding LaTeX parameter\n */\nexport class ParameterToken extends Token {\n    public parentNode: SymbolToken;\n\n    private hasBrackets: boolean;\n    hasSpacePrefix: boolean;\n\n    /**\n     * Constructor\n     * @param {!ParameterTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: ParameterTokenProperties) {\n        if (!(initialProperties instanceof Object))\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        super(initialProperties); // the superclass constructor\n        if (!initialProperties.hasBrackets) // if there are no bounding brackets\n        // store this fact\n            Object.defineProperty(this, \"hasBrackets\", {value: false, enumerable: true});\n        if (initialProperties.hasSpacePrefix) // if there is a space before\n        // store this fact\n            Object.defineProperty(this, \"hasSpacePrefix\", {value: true, enumerable: true});\n    }\n\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     */\n    get lexeme(): Lexeme | undefined {\n        if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n    }\n\n\n    /**\n     * Get the corresponding LaTeX parameter description\n     * @return {?Parameter}\n     *         the LaTeX parameter or undefined of there is parent symbol or such a parameter\n     */\n    get parameter(): Parameter | undefined {\n        /** @type {?SymbolToken} */\n        const symbolToken: SymbolToken = this.parentNode; // get the symbol token\n        const symbol = mustNotBeUndefined(symbolToken.symbol);\n        const parameterIndex = symbolToken.childIndex(this);\n        if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0)\n            return symbol.parameter(parameterIndex);\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        let source = this.hasSpacePrefix ? \" \" : \"\";\n        source += this.hasBrackets ? \"{\" + super.toString(true) + \"}\" : super.toString(true);\n        return skipNodeClass ? source : \"ParameterToken{\" + source + \"}\";\n    }\n}\n\nObject.defineProperties(ParameterToken.prototype, { // default properties\n    hasBrackets: {value: true, enumerable: true}, // there are bounding brackets\n    hasSpacePrefix: {value: false, enumerable: true}, // there is no space before\n    parentNodeClass_: {value: SymbolToken} // parent node must be a SymbolToken instance\n});\nObject.defineProperties(ParameterToken.prototype, { // make getters and setters enumerable\n    parameter: {enumerable: true}\n});\n\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/ParameterToken.ts","import {Token, TokenProperties} from \"./index\";\nimport {Lexeme} from \"../../Latex/Lexeme\";\n\n/**\n * LaTeX space token properties\n * @interface SpaceTokenProperties\n * @extends TokenProperties\n * @property {number|undefined} lineBreakCount - The number of line breaks\n */\nexport interface SpaceTokenProperties\n    extends TokenProperties {\n    lineBreakCount?: number;\n}\n\n/**\n * LaTeX space token structure\n * @class\n * @extends Token\n * @property {number} lineBreakCount The number of line breaks\n */\nexport class SpaceToken extends Token {\n    lineBreakCount: number;\n\n    /**\n     * @param {!SpaceTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: SpaceTokenProperties) {\n        super(initialProperties);\n        this.lineBreakCount = 0;\n\n        if (initialProperties !== undefined) {\n            if (initialProperties.lineBreakCount !== undefined) {\n                if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0)\n                    throw new TypeError(`\"initialProperties.lineBreakCount\" isn't a non-negative number`);\n                this.lineBreakCount = initialProperties.lineBreakCount;\n            }\n        }\n    }\n\n    /**\n     * Get the logical lexeme\n     * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\n     */\n    get lexeme(): Lexeme {\n        return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false): string {\n        if (skipNodeClass) { // if the node class name must be skipped\n            switch (this.lineBreakCount) {\n                case 0:\n                    return \" \";\n                case 1:\n                    return \"\\n\";\n                default:\n                    return \"\\n\\n\";\n            }\n        } else { // if the node class name must be included\n            switch (this.lineBreakCount) {\n                case 0:\n                    return \"SpaceToken{ }\";\n                case 1:\n                    return \"SpaceToken{\\n}\";\n                default:\n                    return \"SpaceToken{\\n\\n}\";\n            }\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/SpaceToken.ts","import {Node} from \"./Node\";\nimport {mustBeString} from \"../Utils\";\n\n/**\n * Syntax tree structure\n * @class\n * @property {!Node} rootNode - The root node\n * @property {string} source - The source text\n */\nexport class SyntaxTree {\n    //noinspection JSUnusedGlobalSymbols // TODO\n    readonly rootNode: Node;\n    readonly source: string;\n\n\n    /**\n     * Constructor\n     * @param {!Node} rootNode the root node (must have no parent and no tree)\n     * @param {string} source the sources text that represents this syntax tree\n     */\n    constructor(rootNode: Node, source: string) {\n        if (!(rootNode instanceof Node)) throw new TypeError(`\"rootNode\" isn't a SyntaxTree.Node instance`);\n        if (!!rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n        if (!!rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n\n        this.rootNode = rootNode;\n        this.source = mustBeString(source, `\"sources\" isn't a string`);\n\n        // Note reflective relation, naturally\n        rootNode.tree = this;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/index.ts","import {Context} from \"./Context\";\nimport {LatexStyle} from \"../../LatexStyle/index\";\nimport {Token} from \"../../SyntaxTree/Token/index\";\nimport {Parameter} from \"../../LatexStyle/Item/Parameter\";\nimport {EnvironmentToken} from \"../../SyntaxTree/Token/EnvironmentToken\";\nimport {EnvironmentBodyToken} from \"../../SyntaxTree/Token/EnvironmentBodyToken\";\nimport {EnvironmentAndPackage} from \"../../LatexStyle/Item/Environment\";\nimport {Command} from \"../../LatexStyle/Item/Symbol/Command\";\nimport {SpaceToken} from \"../../SyntaxTree/Token/SpaceToken\";\nimport {SymbolToken} from \"../../SyntaxTree/Token/SymbolToken\";\nimport {ParameterToken} from \"../../SyntaxTree/Token/ParameterToken\";\nimport {CommandToken} from \"../../SyntaxTree/Token/CommandToken\";\nimport {Lexeme} from \"../Lexeme\";\nimport {Symbol as SymbolItem} from \"../../LatexStyle/Item/Symbol/index\";\nimport {isNumber, isString, mustNotBeUndefined} from \"../../Utils\";\n\n/**\n * Parse the next token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle the latex style\n * @return {?Token} the parsed token or undefined if the token cannot be parsed\n * @private\n */\nfunction parseToken_(context: Context, latexStyle: LatexStyle): Token | undefined {\n    let token: Token | undefined = parseSpaceToken_(context); // collect comments and try to parse a space token\n    if (!token) { // if cannot parse a space token\n        if (context.position >= context.source.length) return undefined;\n\n        const contextBackup = context.copy(); // backup the current context\n        if (!(token = parseEnvironmentToken_(context, latexStyle))) { // if cannot parse an environment token\n            contextBackup.copy(context); // restore the context\n            if (!(token = parseCommandToken_(context, latexStyle))) { // if cannot parse a command token\n                contextBackup.copy(context); // restore the context\n                if (!(token = parseSymbolsToken_(context, latexStyle))) { // if cannot parse a symbol token\n                    return undefined; // no token can be parsed\n                }\n            }\n        }\n    }\n    //noinspection JSCheckFunctionSignatures\n    processParsedToken_(context, token);\n    //noinspection JSValidateTypes\n    return token; // return the parsed token\n}\n\n\n/**\n * Parse a parameter token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle the latex style\n * @param {!Parameter} parameter the symbol or command parameter description\n * @param {string=} opt_endLabel\n *        the parameter end label or undefined if there should be a single token\n * @return {?ParameterToken} the parsed parameter token or undefined if cannot parse\n * @private\n */\nfunction parseParameterToken_(context: Context, latexStyle: LatexStyle, parameter: Parameter, opt_endLabel?: string) {\n    const currentTokenBackup = context.currentToken; // store the current token\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n    context.updateState(parameter.operations); // update the LaTeX state\n    if (opt_endLabel === undefined) { // if the parameter must be parsed as a single token\n        // has the param space prefix or not\n        const spacePrefixState = parseSpaceToken_(context) !== undefined;\n        if (context.source[context.position] === \"{\") { // if the parameter is bounded by brackets\n            // create the parameter token\n            context.currentToken =\n                new ParameterToken({hasBrackets: true, hasSpacePrefix: spacePrefixState});\n            ++context.position; // go to the sources next char\n            ++context.charNumber; // go to the current line next char\n            // exit if cannot parse until the closing bracket\n\n            if (!parseUntilLabel_(context, latexStyle, \"}\", parameter.lexeme)) return undefined;\n            ++context.position; // skip the bracket in the sources\n            ++context.charNumber; // skip the bracket in the current line\n        } else { // if the parameter is't bounded by brackets\n            // create the parameter token\n            context.currentToken =\n                new ParameterToken({hasBrackets: false, hasSpacePrefix: spacePrefixState});\n            // exit if cannot parse a parameter token\n            if (parseToken_(context, latexStyle) === undefined) return undefined;\n        }\n    } else { // if the parameter must be parsed until the end label\n        // create the parameter token\n        context.currentToken =\n            new ParameterToken({hasBrackets: false, hasSpacePrefix: false});\n\n        // return if cannot parse\n        if (!parseUntilLabel_(context, latexStyle, opt_endLabel, parameter.lexeme)) return undefined;\n    }\n    const parameterToken = context.currentToken; // the parsed parameter token\n    context.currentToken = currentTokenBackup; // restore the current token\n    //noinspection JSCheckFunctionSignatures\n    processParsedToken_(context, parameterToken);\n    //noinspection JSValidateTypes\n    return parameterToken;\n}\n\n\n/**\n * Parse an environment token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @return {?EnvironmentToken} the parsed token or undefined if cannot parse\n * @private\n */\nfunction parseEnvironmentToken_(context: Context, latexStyle: LatexStyle): EnvironmentToken | undefined {\n    if (context.source.substring(context.position).indexOf(\"\\\\begin\") !== 0) return undefined;\n    context.position += 6; // just after \"\\begin\"\n    parseSpaceToken_(context); // skip spaces\n    // try to obtain the environment name\n    const nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n    if (!nameMatch) return undefined; // exit if cannot bet the environment name\n    const name = nameMatch[1]; // the environment name\n    context.position += nameMatch[0].length; // skip the environment name in the sources\n    context.charNumber += nameMatch[0].length; // skip the environment name in the current line\n    const currentTokenBackup = context.currentToken; // store the current token\n    // try to get the corresponding environment\n    const environment: EnvironmentAndPackage = latexStyle.environments(context.currentState, name)[0];\n    const environmentToken = context.currentToken = environment ? // the environment token\n        new EnvironmentToken({environment: environment.environment}) :\n        new EnvironmentToken({name: name});\n    // TODO unknown environment notification\n    // try to parse the environment begin command\n    const symbols: Command[] = latexStyle.commands(context.currentState, name);\n    let beginCommandToken: Token | undefined = parsePatterns_(context, latexStyle, symbols);\n    if (beginCommandToken === undefined) { // if cannot parse a command\n        // TODO notification about the unrecognized command\n        // generate unrecognized command token\n        beginCommandToken = new CommandToken({name: name});\n    }\n    //noinspection JSCheckFunctionSignatures\n    processParsedToken_(context, beginCommandToken);\n    const environmentBodyToken = context.currentToken = new EnvironmentBodyToken();\n    const endFound = parseUntilLabel_(context, latexStyle, `\\\\end\\{${name}}`); // try to get to the end\n    context.currentToken = environmentToken;\n    processParsedToken_(context, environmentBodyToken); // process the body token\n    let endCommandToken: Token | undefined = undefined; // the environment end command token\n    if (endFound) { // if the environment end was reached\n        context.position += name.length + 6; // skip the environment name in the sources\n        context.charNumber += name.length + 6; // skip the environment name in the current line\n        endCommandToken = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, `end${name}`));\n    } else { // if cannot find the end of the environment\n        // TODO no environment end notification\n    }\n    if (endCommandToken === undefined) { // if cannot parse a command\n        // TODO notification about the unrecognized command\n        // generate unrecognized command token\n        endCommandToken = new CommandToken({name: \"end\" + name});\n    }\n    processParsedToken_(context, endCommandToken); // process the end command token\n    context.currentToken = currentTokenBackup; // restore the current token\n    return environmentToken;\n}\n\n\n/**\n * Parse a command token.\n *\n * By the rules of TeX syntax, the \"name\" of a macro that starts with a \\ (backslash) character must either\n * - consist of a single non-alphabetical character.\n *   Some examples:\n *     \\, (insert thin space),\n *     \\% ( the % character),\n *     \\\\ (insert line break),\n *     \\[ (open display math), and\n *     \\) (close inline math).\n * or\n * - contain only uppercase and lowercase alphabetical characters: a-z and A-Z. No numerals, and no other characters\n *   belonging to non-letter categories either. (Well, there are certain ways of assigning \"letter-category\" status to\n *   non-letter characters, but that's a topic for a different discussion.)\n *   (https://tex.stackexchange.com/questions/66666/command-macro-name-cannot-include-numbers-and-symbols/66695#66695)\n *\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @return {?CommandToken} the parsed token or undefined if cannot parse\n * @private\n *\n */\nfunction parseCommandToken_(context: Context, latexStyle: LatexStyle): Token | undefined {\n    // try to find a command name\n    // TODO [a-zA-Z] instead of [\\w]?\n    const cmdMatch = context.source.substring(context.position).match(/^\\\\((?:[\\w@]+\\*?)|(?:[^\\w]))/);\n\n    if (!cmdMatch)\n        return undefined; // exit if cannot find a command name\n\n    context.position += cmdMatch[0].length; // set position just after the command name\n    context.charNumber += cmdMatch[0].length; // skip all the command name chars\n\n    // try to parse a command token\n\n    let token: Token | undefined = parsePatterns_(context, latexStyle, latexStyle.commands(context.currentState, cmdMatch[1]));\n    if (token === undefined) { // if cannot parse a command token\n        // TODO notification about the unrecognized command\n        // generate unrecognized command token\n        token = new CommandToken({name: cmdMatch[1]});\n    }\n    //noinspection JSValidateTypes\n    return token;\n}\n\n\n/**\n * Parse symbols for a token\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @return {?Token} the parsed token or undefined if cannot parse\n * @private\n */\nfunction parseSymbolsToken_(context: Context, latexStyle: LatexStyle): Token | undefined {\n    // get the available symbols\n    const sourceCharacter = context.source[context.position]; // the current sources character\n\n    // get the symbols started with the current sources character\n    let token = parsePatterns_(context, latexStyle, latexStyle.symbols(context.currentState, sourceCharacter));\n\n    if (token === undefined) { // if cannot parse a symbol token\n        // TODO notification about the unrecognized symbol\n        ++context.position; // go to the next sources character\n\n        // go to the next line character (the line is the same, \\n was parsed for a space token)\n        ++context.charNumber;\n\n        // generate unrecognized symbol token\n        token = new SymbolToken({pattern: sourceCharacter});\n    } else { // if the token was parsed\n        // TODO parse words and numbers\n    }\n    return token;\n}\n\n\n/**\n * Try to parse a symbol pattern\n * @param {!Context} context the parsing context// generate unrecognized symbol token\n * @param {!LatexStyle} latexStyle the latex style\n * @param {!Array.<!Symbol>} symbols the symbol or command descriptions in the priority descending order\n * @return {?Token} the parsed symbol or command token or undefined if cannot parse\n * @private\n */\nfunction parsePatterns_(context: Context, latexStyle: LatexStyle, symbols: SymbolItem[]): Token | undefined {\n    const contextBackup = context.copy(); // backup the current context\n    let token: Token | undefined = undefined; // the parsed token\n\n    // TODO not how some() is meant to be used...?\n    symbols.some(symbol => { // for all the symbols until the parsing success\n        // stop if the token was parsed\n        if (token = parsePattern_(context, latexStyle, symbol)) {\n            return true;\n        } else {\n            contextBackup.copy(context); // restore the context\n            return false; // go to the next symbol\n        }\n    });\n    return token;\n}\n\n\n/**\n * Try to parse a symbol pattern\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @param {!Array.<!Symbol>} symbol the symbol or command description\n * @return {?Token} the parsed symbol or command token or undefined if cannot parse\n * @private\n */\nfunction parsePattern_(context: Context, latexStyle: LatexStyle, symbol: SymbolItem): Token | undefined {\n    const currentTokenBackup = context.currentToken; // store the current token\n    // if a command description is given\n    context.currentToken = symbol instanceof Command ?\n        new CommandToken({command: symbol}) : // generate a command token\n        new SymbolToken({symbol: symbol}); // generate a symbol token\n\n    const patternComponents = symbol.patternComponents; // the symbol pattern components\n    const nPatternComponents = patternComponents.length; // the pattern componen number\n    let iPatternComponent = 0; // the pattern component iterator\n    // for all the pattern components\n    for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n        const patternComponent = patternComponents[iPatternComponent]; // the pattern component\n        if (isNumber(patternComponent)) { // if a parameter is expected\n            const parameter: Parameter | undefined = symbol.parameter(patternComponent); // the parameter description\n            // try to get the end label for the parameter\n            const parameterEndLabel = patternComponents[iPatternComponent + 1];\n            if (typeof parameterEndLabel === \"string\") { // if there is a end label\n                // if can parse the parameter token\n                if (parseParameterToken_(context, latexStyle, mustNotBeUndefined(parameter), parameterEndLabel)) {\n                    // exit if there is no the end label at the positions\n                    if (context.source.substring(context.position).indexOf(parameterEndLabel) !== 0) return undefined;\n                    context.position += parameterEndLabel.length; // skip the end label in the sources\n                    context.charNumber += parameterEndLabel.length; // skip the end label in the line\n                    ++iPatternComponent; // skip the end label in the pattern\n                    continue; // go to the next pattern component\n                }\n            } else { // if there is no a end label\n                // go to the next pattern char if can parse the parameter token\n                if (parseParameterToken_(context, latexStyle, mustNotBeUndefined(parameter))) continue;\n            }\n        }\n        else if (isString(patternComponent)) {\n            while (parseCommentLine_(context)) {\n            } // skip all the comments\n            // if the sources fragment is equal the pattern component\n            if (context.source.substring(context.position).indexOf(patternComponent) === 0) {\n                context.position += patternComponent.length; // skip the pattern component in the sources\n                context.charNumber += patternComponent.length; // skip the pattern component in the line\n                continue; // go to the next pattern component\n            }\n        } else if (parseSpaceToken_(context))\n            continue;\n        break; // stop parsing if there was no continue call\n    }\n    // return if the pattern parsing was broken\n    if (iPatternComponent < nPatternComponents) return undefined;\n    const parsedToken = context.currentToken; // the parsed token to return\n    context.currentToken = currentTokenBackup; // restore the current token\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n    context.updateState(symbol.operations); // update the LaTeX state\n    return parsedToken;\n}\n\n\n/**\n * Parse tokens until the label\n * @param {!Context} context the parsing context\n * @param {!LatexStyle} latexStyle latex style\n * @param {string} endLabel the label to parse until\n * @param {Lexeme=} opt_lexeme the lexeme of the single token to parse\n * @return {boolean} true if the parsing was successful, false otherwise\n * @private\n */\nfunction parseUntilLabel_(context: Context, latexStyle: LatexStyle, endLabel: string, opt_lexeme?: Lexeme) {\n    switch (opt_lexeme) {\n        // TODO parse special lexemes\n        default: {\n            // while not reached the label\n            while (context.source.substring(context.position).indexOf(endLabel) !== 0) {\n                if (context.position >= context.source.length) { // if there is no more sources\n                    // TODO notification about unexpected sources end\n                    return false;\n                }\n                parseToken_(context, latexStyle);\n            }\n            return true;\n        }\n    }\n}\n\n/**\n * Parse a comment line\n * @param {!Context} context the parsing context\n * @return {boolean} true if there was a comment line, false otherwise\n * @private\n */\nfunction parseCommentLine_(context: Context): boolean {\n    // try to find a comment int the sources tail\n    const commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false; // return if there is no comment at this position\n\n    context.comments.push(commentMatch[1]); // store the comment string\n    context.position += commentMatch[0].length; // position just after the comment\n    if (!commentMatch[2]) { // if there were no line breaks\n        context.charNumber += commentMatch[0].length; // go to the last char\n    } else { // if there was a line break\n        ++context.lineNumber; // one more line\n        context.charNumber = commentMatch[2].length - 1; // skip all the space chars in the new line\n    }\n    return true;\n}\n\n\n/**\n * Fill the parsed token position, comments and parent\n * @param {!Context} context the parsing context\n * @param {!Token} token the token to process\n * @private\n */\nfunction processParsedToken_(context: Context, token: Token) {\n    // TODO process comments and position\n    if (context.currentToken) { // if there is a current token\n\n        // console.log(context.currentToken.toString())\n\n        //noinspection JSUnresolvedFunction\n        context.currentToken.insertChildSubtree(token); // store this token as a child of the current\n    }\n}\n\n/**\n * Parse space for a token (space or paragraph separator)\n * @param {!Context} context the parsing context\n * @return {?SpaceToken} the parsed token or undefined if cannot parse a space token\n * @private\n */\nfunction parseSpaceToken_(context: Context): SpaceToken | undefined {\n    let isSpace = false; // true is the sources fragment is a space token, false otherwise\n    let nLineBreaks = 0; // number of parsed line breaks\n    while (context.position < context.source.length) { // while there is something to parse\n        // go to the next iteration if there was a comment\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) { // depend on the sources current character\n            case \" \":\n            case \"\\t\": // if a space or a tabular\n                isSpace = true; // and one more parsed char\n                ++context.position; // go to the next sources char\n                ++context.charNumber; // the next char of the sources line\n                continue;\n            case \"\\n\": // if a line break\n                isSpace = true; // and one more parsed char\n                ++nLineBreaks; // one more parsed line\n                ++context.position; // go to the next sources char\n                ++context.lineNumber; // the next sources line\n                context.charNumber = 0; // the first char of the line\n                continue; // go to the next iteration\n        }\n        break; // stop if not a space char\n    }\n    // create a space token if needed\n    return isSpace ? new SpaceToken({lineBreakCount: nLineBreaks}) : undefined;\n}\n\n/**\n * LaTeX parser structure\n * @class\n * @property {!LatexStyle} latexStyle latexStyle - The LaTeX style description to be used for parsing\n */\nexport class LatexParser {\n    latexStyle: LatexStyle;\n\n    /**\n     * Constructor\n     * @param {!LatexStyle} latexStyle latexStyle LaTeX style description to be used for parsing\n     */\n    constructor(latexStyle: LatexStyle) {\n        if (!(latexStyle instanceof LatexStyle)) throw new TypeError(`\"latexStyle\" isn't a LatexStyle instance`);\n        this.latexStyle = latexStyle;\n    }\n\n\n    /**\n     * Parse LaTeX sources\n     * @param {string} source the sources to parse\n     * @param {(!Context|undefined)} opt_context the parsing context\n     * @return {!Array.<!Token>} the list of the parsed tokens\n     */\n    parse(source: string, opt_context?: Context): Token[] {\n        if (typeof source !== \"string\") throw new TypeError(`\"sources\" isn't a string`);\n        let context;\n\n        if (opt_context === undefined) { // if the parsing context isn't defined\n            context = new Context(source); // create the context\n        } else if (opt_context instanceof Context) { // if the parsing context is defined\n            context = opt_context;\n            context.source += source; // update the sources\n        } else { // if unexpected context type\n            throw new TypeError(`\"context\" isn't a LatexParser.Context instance`);\n        }\n\n        const parsedTokens: Token[] = []; // the list of the parsed tokens\n\n        // store the parsed token, stop when cannot parse a token\n        let parsedToken: Token | undefined;\n        while (parsedToken = parseToken_(context, this.latexStyle))\n            parsedTokens.push(parsedToken);\n\n        return parsedTokens;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex/Parser/Parser.ts","import {SymbolProperties} from \"./Item/Symbol/index\";\nimport {CommandProperties} from \"./Item/Symbol/Command\";\nimport {EnvironmentProperties} from \"./Item/Environment\";\n\n/**\n * LaTeX style package properties\n * @interface PackageProperties\n * @property {(!Array.<!SymbolProperties>|undefined)} symbols - The symbols of the package in the priority descending order\n * @property {(!Array.<!CommandProperties>|undefined)} commands - The commands of the package in the priority descending order\n * @property {(!Array.<!EnvironmentProperties>|undefined)} environments - The environments of the package\n */\nexport interface PackageProperties {\n    symbols?: SymbolProperties[];\n    commands?: CommandProperties[];\n    environments?: EnvironmentProperties[];\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function mustBePackageProperties(x: any): PackageProperties {\n    if (!isPackageProperties(x)) throw new Error(\"Invalid format for PackageProperties\");\n    return x;\n}\n\nexport function isPackageProperties(x: any): x is PackageProperties {\n    // TODO all props are optional...\n    // symbols?: SymbolProperties[];\n    // commands?: CommandProperties[];\n    // environments?: EnvironmentProperties[];\n\n    return !Object.keys(x).some(k => {\n        switch (k) {\n            case \"symbols\":\n            case \"commands\":\n            case \"environments\":\n                return false;\n            default:\n                return true;\n        }\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle/PackageProperties.ts","import {SyntaxTree} from \"./index\";\nimport {mustBeToken, Token} from \"./Token/index\";\n\n/**\n * LaTeX syntax tree structure\n * @class\n * @extends SyntaxTree\n */\nexport class LatexTree extends SyntaxTree {\n\n    /**\n     * @param {!Token} rootToken the root token (must have no parent and no tree)\n     * @param {string} source the source code that represents this syntax tree\n     */\n    constructor(rootToken: Token, source: string) {\n        const token = mustBeToken(rootToken, `\"rootToken\" isn't a Token instance`);\n\n        // TODO must have no parent and no tree\n        // if(token.parentNode)\n\n        super(\n            token,\n            source\n        );\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/LatexTree.ts","import {Token, TokenProperties} from \"./index\";\nimport {Lexeme, mustBeLexeme} from \"../../Latex/Lexeme\";\nimport {mustBeString} from \"../../Utils\";\n\n/**\n * LaTeX source fragment token properties\n * @interface SourceTokenProperties\n * @extends TokenProperties\n * @property {Lexeme} lexeme - The logical lexeme\n * @property {string} source - The source fragment\n */\nexport interface SourceTokenProperties\n    extends TokenProperties {\n    lexeme: Lexeme;\n    source: string;\n}\n\n/**\n * LaTeX source fragment token structure\n * @class\n * @extends Token\n * @property {string} source - The source fragment\n */\nexport class SourceToken extends Token {\n    private source: string;\n\n    /**\n     * Constructor\n     * @param {!SourceTokenProperties} initialProperties the initial property values\n     */\n    constructor(initialProperties: SourceTokenProperties) {\n        super(initialProperties);\n\n        this.lexeme = mustBeLexeme(initialProperties.lexeme, `\"initialProperties.lexeme\" isn't known`);\n        this.source = mustBeString(initialProperties.source, `\"initialProperties.sources\" isn't a string`);\n    }\n\n\n    /**\n     * Get the string representation of this node\n     * @param {boolean=false} skipNodeClass\n     *        true to not include the node class name into the output, false otherwise\n     * @return {string} the sources string\n     * @override\n     */\n    toString(skipNodeClass = false) {\n        return skipNodeClass\n            ? this.source\n            : \"SourceToken[\" + this.lexeme + \"]{\" + this.source + \"}\";\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree/Token/SourceToken.ts","// general JavaScript utils\nexport * from \"./lib/Utils\";\n\n// general LaTeX definitions\nexport * from \"./lib/Latex/Lexeme\";\nexport * from \"./lib/Latex/Mode\";\nexport * from \"./lib/Latex/Operation\";\nexport * from \"./lib/Latex/State\";\n\nexport * from \"./lib/Latex/Directive/index\";\nexport * from \"./lib/Latex/Directive/GROUP\";\n\n// LaTeX parser class\nexport * from \"./lib/Latex/Parser/Parser\";\nexport * from \"./lib/Latex/Parser/Context\";\n\n// LaTeX style structures\nexport * from \"./lib/LatexStyle/index\";\nexport * from \"./lib/LatexStyle/PackageProperties\";\nexport * from \"./lib/LatexStyle/Item/index\";\nexport * from \"./lib/LatexStyle/Item/Environment\";\nexport * from \"./lib/LatexStyle/Item/Parameter\";\nexport * from \"./lib/LatexStyle/Item/Symbol/index\";\nexport * from \"./lib/LatexStyle/Item/Symbol/Command\";\n\n// (LaTeX) syntax tree structure elements\nexport * from \"./lib/SyntaxTree/index\";\nexport * from \"./lib/SyntaxTree/LatexTree\";\nexport * from \"./lib/SyntaxTree/Node\";\nexport * from \"./lib/SyntaxTree/Token/index\";\nexport * from \"./lib/SyntaxTree/Token/CommandToken\";\nexport * from \"./lib/SyntaxTree/Token/EnvironmentBodyToken\";\nexport * from \"./lib/SyntaxTree/Token/EnvironmentToken\";\nexport * from \"./lib/SyntaxTree/Token/ParameterToken\";\nexport * from \"./lib/SyntaxTree/Token/SourceToken\";\nexport * from \"./lib/SyntaxTree/Token/SpaceToken\";\nexport * from \"./lib/SyntaxTree/Token/SymbolToken\";\n\n\n// WEBPACK FOOTER //\n// ./sources/main.ts"],"sourceRoot":""}